// check.cog

import cog;

func checkModule(
    session: Session)
{
	checkModule(session, session.moduleDecl);
}

// Explicit entry point for checking a given module
func checkModule(
	session: Session,
	moduleDecl: ModuleDecl)
{
	var sharedContext : SharedCheckContext;
	sharedContext.session = session;

	var context : CheckContext;
	context.shared = &sharedContext;

	checkModule(&context, moduleDecl);
}

struct SharedCheckContext
{
	var session : Session;
}

struct CheckContext
{
	var shared : SharedCheckContext*;
}

func getSink(
	context: CheckContext*) -> DiagnosticSink*
{
	return &context.shared.session.sink;
}

func checkModule(
	context: CheckContext*,
	moduleDecl:	ModuleDecl)
{
	checkDecls(context, moduleDecl);
}

func checkImportDecls(
	context: CheckContext*,
	containerDecl: ContainerDecl)
{
	foreach(decl in containerDecl.getDecls())
	{
		if(let importDecl = as<ImportDecl>(decl))
		{
	    	// Need to wire the import up into the current scope

	    	let module = findOrImportModule(context.shared.session, importDecl.loc, importDecl.name);

	    	attachToScope(importDecl.scope, module);
		}
	}
	
}

func checkDecls(
	context: 		CheckContext*,
	containerDecl: 	ContainerDecl)
{
	checkImportDecls(context, containerDecl);

	foreach(decl in containerDecl.getDecls())
	{
		checkDecl(context, decl);
	}
}

func attachToScope(
	scope:	Scope*,
	decl: 	ContainerDecl)
{
    let link = cast<Ptr<ScopeLink> >(malloc(sizeof(ScopeLink)));
	link.container = decl;
	link.next = nullptr;

	link.next = scope.directLink.next;
	scope.directLink.next = link;
}

func checkDecl(
	context: 	CheckContext*,
	decl:		Decl)
{
	// don't check decl we've already checked
	if(decl.checkState == kDeclCheckState_Checked)
		return;

	if(decl.checkState != kDeclCheckState_Unchecked)
	{
		// we are already checking this one!
		diagnose(getSink(context), decl.loc, kDiagnostic_unimplemented, "circularity");
		return;
	}

	decl.checkState = kDeclCheckState_CheckingHead;
	checkDeclImpl(context, decl);
	decl.checkState = kDeclCheckState_Checked;
}

func checkDeclImpl(
	context: 	CheckContext*,
	decl:		Decl)
{
	if(let classDecl = as<ClassDecl>(decl))
	{
		checkClassDecl(context, classDecl);
	}
	else if(let structDecl = as<StructDecl>(decl))
	{
		checkStructDecl(context, structDecl);
	}
	else if(let funcDecl = as<FuncDeclBase>(decl))
	{
		checkFuncDecl(context, funcDecl);
	}
	else if(let varDecl = as<VarDeclBase>(decl))
	{
		checkVarDecl(context, varDecl);
	}
	else if(let genericDecl = as<GenericDecl>(decl))
	{
		checkGenericDecl(context, genericDecl);
	}
	else if(let typeAliasDecl = as<TypeAliasDecl>(decl))
	{
		checkTypeAliasDecl(context, typeAliasDecl);
	}
	else if(let genericParamDecl = as<GenericParamDecl>(decl))
	{
		// TODO: implement
	}
    else if(let importDecl = as<ImportDecl>(decl))
    {
    	// Skip in this phase
    }
	else
	{
		//	diagnose(getSink(context), decl.loc, kDiagnostic_unimplemented, decl.directClass.name);	
	}
}

func checkGenericDecl(
	context: CheckContext*,
	decl: GenericDecl)
{
//    fprintf(stderr, "CHECKING GENERIC\n");

	// check params
	checkDecls(context, decl);

	decl.checkState = kDeclCheckState_CheckedHead;

	// check inner decl
	checkDecl(context, decl.inner);
}

func checkTypeAliasDecl(
	context: CheckContext*,
	decl: TypeAliasDecl)
{
	// TODO: implement this...
}

func checkVarDecl(
	context: CheckContext*,
	decl: VarDeclBase)
{
	// check type, if any
	checkTypeExp(context, &decl.type);
    var type = decl.type.type;

    var initExpr = decl.init;
    if(initExpr)
    {
        initExpr = checkTerm(context, initExpr);
        if(type)
        {
            initExpr = coerce(context, initExpr, type);
        }
        else
        {
            // TODO: must coerce to usable...

            type = initExpr.type;
        }
    }
    else
    {
        if(!type)
        {
            diagnose(getSink(context), decl.loc, kDiagnostic_unimplemented, "decl without init must have type");
            type = createErrorType(context);
        }
    }

//    fprintf(stderr, "VAR(%s) TYPE(",
//    	getText(decl.name).begin);
//    printType(stderr, type);
//    fprintf(stderr, ")\n");

    decl.init = initExpr;
    decl.type.type = type;
}

func checkFuncDecl(
	context: CheckContext*,
	decl: FuncDeclBase)
{
	// check parameters
	checkDecls(context, decl);

	// check result type clause, if any
	checkTypeExp(context, &decl.resultType);
    if(!asBool(decl.resultType))
    {
        decl.resultType.type = getBuiltinType(context, decl.loc, "Void");
    }

	decl.checkState = kDeclCheckState_CheckedHead;    

	if(let body = decl.body)
	{
		decl.body = checkStmt(context, body);
	}
}

func checkClassDecl(
	context: CheckContext*,
	decl: ClassDecl)
{
	checkAggTypeDeclCommon(context, decl);
}

func checkStructDecl(
	context: CheckContext*,
	decl: StructDecl)
{
	checkAggTypeDeclCommon(context, decl);
}

func checkAggTypeDeclCommon(
	context: CheckContext*,
	decl: AggTypeDecl)
{
	// check base clause, if any
	checkTypeExp(context, &decl.base);

	decl.checkState = kDeclCheckState_CheckedHead;

	// TODO: validate that the base (if any)
	// names a class, and satisfies any constraints

	// check members in the context of the parent
	checkDecls(context, decl);
}

//

func checkPrediateExpr(
	context: CheckContext*,
	expr: Exp)
	-> Exp
{
	// TODO: add coercion step
	return checkExp(context, expr);
}

func checkStmt(
	context: CheckContext*,
	stmt: Stmt)
	-> Stmt
{
    if(!stmt)
        return nullptr;

	if(let blockStmt = as<BlockStmt>(stmt))
	{
		return checkBlockStmt(context, blockStmt);
	}
    else if(let decl = as<Decl>(stmt))
    {
        checkDecl(context, decl);
        return decl;
    }
    else if(let exp = as<Exp>(stmt))
    {
        return checkExp(context, exp);
    }
    else if(let ifStmt = as<IfStmt>(stmt))
    {
        ifStmt.condition = checkPrediateExpr(context, ifStmt.condition);
        ifStmt.thenStmt = checkStmt(context, ifStmt.thenStmt);
        ifStmt.elseStmt = checkStmt(context, ifStmt.elseStmt);
        return ifStmt;
    }
    else if(let ifLetStmt = as<IfLetStmt>(stmt))
    {
        ifLetStmt.init =     checkExp (context, ifLetStmt.init);
        ifLetStmt.thenStmt = checkStmt(context, ifLetStmt.thenStmt);
        ifLetStmt.elseStmt = checkStmt(context, ifLetStmt.elseStmt);
        return ifLetStmt;
    }
    else if(let whileStmt = as<WhileStmt>(stmt))
    {
        whileStmt.condition = checkPrediateExpr(context, whileStmt.condition);
        whileStmt.body = checkStmt(context, whileStmt.body);
        return whileStmt;
    }
    else if(let forStmt = as<ForStmt>(stmt))
    {
        forStmt.init = checkStmt(context, forStmt.init);
        forStmt.condition = checkPrediateExpr(context, forStmt.condition);
        forStmt.iter = checkExp(context, forStmt.iter);
        forStmt.body = checkStmt(context, forStmt.body);
        return forStmt;
    }
    else if(let forEachStmt = as<ForEachStmt>(stmt))
    {
		// TODO: need to introduce a name binding in the scope here...
        forEachStmt.exp = checkExp(context, forEachStmt.exp);
        forEachStmt.body = checkStmt(context, forEachStmt.body);
        return forEachStmt;
    }
    else if(let returnStmt = as<ReturnStmt>(stmt))
    {
        // TODO: coerce value to type expected in context
        returnStmt.value = checkExp(context, returnStmt.value);
        return returnStmt;
    }
    else if(let breakStmt = as<BreakStmt>(stmt))
    {
        // TODO: check that we are inside a breakable context
        return breakStmt;
    }
    else if(let continueStmt = as<ContinueStmt>(stmt))
    {
        // TODO: check that we are inside a breakable context
        return continueStmt;
    }
    else if(let switchStmt = as<SwitchStmt>(stmt))
    {
        switchStmt.condition = checkExp(context, switchStmt.condition);
		for(var c = switchStmt.cases; c; c = c.next)
		{
			for(var a = c.values; a; a = a.next)
			{
				a.exp = checkExp(context, a.exp);
			}

			c.body = checkStmt(context, c.body);
		}

        return switchStmt;
    }
	else
	{
        diagnose(getSink(context), stmt.loc, kDiagnostic_unimplemented, stmt.directClass.name);
		cogAssert(!"unimplemented");
	}
}

func checkBlockStmt(
	context: CheckContext*,
	stmt: BlockStmt)
	-> Stmt
{
	foreach(stmt in stmt.stmts)
	{
		checkStmt(context, stmt);
	}

	return stmt;
}

//

func checkExp(
	context: CheckContext*,
	exp: Exp)
	-> Exp
{
	// TODO: what?
	return coerceToExp(context, checkTerm(context, exp));	
}

func coerceToExp(
	context: CheckContext*,
	term: Syntax)
	-> Exp
{
	if(!term)
		return nullptr;

    if(let exp = as<Exp>(term))
    {
        return exp;
    }

    cogAssert(!"need an exp");
}

//

func checkType(
	context: CheckContext*,
	exp: Exp)
	-> Type
{
	// TODO: what?
	return coerceToType(context, checkTerm(context, exp));
}

func checkTypeExp(
	context: CheckContext*,
	typeExp: TypeExp*)
{
	let exp = typeExp.exp;
	if(!exp)
		return;

	let type = checkType(context, exp);
	typeExp.type = type;
}

func coerceToType(
	context: CheckContext*,
	exp: Exp)
	-> Type
{
	let expType = exp.type;
	if(let typeType = as<TypeType>(expType))
	{
		return typeType.type;
	}
    else if(let errorType = as<ErrorType>(expType))
    {
        return errorType;
    }
	else
	{
        diagnose(getSink(context), exp.loc, kDiagnostic_unimplemented, expType.directClass.name);
		cogAssert(!"unimplemented");
	}
}

//

func checkTerm(
	context: CheckContext*,
	exp: Exp)
	-> Exp
{
	if(!exp) return nullptr;

	if(let nameExp = as<NameExp>(exp))
	{
		let scope = nameExp.scope;
        let result = lookup(scope, nameExp.name);
        if(result.isEmpty())
		{
			// TODO: error
			diagnose(getSink(context), nameExp.loc, kDiagnostic_undefinedIdentifier, nameExp.name);
            return createErrorExp(context, nameExp.loc);
		}
        else if(!result.isOverloaded())
        {
            // form a decl-ref
            let declRef = CompactDeclRef(result.getDecl());
            let declRefExp = createObject<DeclRefExp>();
            declRefExp.loc = exp.loc;
            declRefExp.declRef = declRef;
            declRefExp.type = getTypeForDeclRef(context, declRef);
            return declRefExp;            
        }
		else
		{
            let overloadedExpr = createObject<OverloadedExpr>();
            overloadedExpr.loc = exp.loc;
            overloadedExpr.lookupResult = result;
            overloadedExpr.type =  createObject<OverloadGroupType>();
            return overloadedExpr;
		}
	}
    else if(let memberExp = as<MemberExp>(exp))
    {
        return checkMemberExp(context, memberExp);

    }
    else if(let intLitExp = as<IntLitExp>(exp))
    {
        // TODO: allow more robust inference here...
        intLitExp.type = getBuiltinType(context, intLitExp.loc, "Int");
        return intLitExp;
    }
    else if(let stringLitExp = as<StringLitExp>(exp))
    {
        // TODO: allow more robust inference here...
        stringLitExp.type = getBuiltinType(context, stringLitExp.loc, "String");
        return stringLitExp;
    }
    else if(let charLitExp = as<CharacterLitExp>(exp))
    {
        // TODO: allow more robust inference here...
        charLitExp.type = getBuiltinType(context, charLitExp.loc, "Char");
        return charLitExp;
    }
    else if(let assignExp = as<AssignExp>(exp))
    {
        let left = checkExp(context, assignExp.left);
        var right = checkTerm(context, assignExp.right);
        right = coerce(context, right, left.type);

        assignExp.left = left;
        assignExp.right = right;
        assignExp.type = left.type; // TODO: should probably be `Void`
        return assignExp;
    }
    else if(let indexExp = as<IndexExp>(exp))
    {
        let base = checkTerm(context, indexExp.base);
        indexExp.base = base;
        foreach(arg in indexExp.args)
        {
            arg.exp = checkTerm(context, arg.exp);
        }

        // If the base expression or any argument is in error,
        // en don't bother trying to resolve things
        if(as<ErrorExp>(base) || as<ErrorType>(base.type))
        {
            return createErrorExp(context, indexExp.loc);
        }

        var overloadContext : OverloadResolveContext;
        overloadContext.checkContext = context;
        overloadContext.appExp = indexExp;
        overloadContext.baseExp = base;

        let baseType = base.type;
        if(let baseDeclRefType = as<DeclRefType>(baseType))
        {
            let baseDeclRef = baseDeclRefType.declRef;
            if(let aggTypeDeclRef = as<AggTypeDecl>(baseDeclRef))
            {
                // now scan through the type's members looking for a subscript

                foreach(memberDeclRef in getDecls(aggTypeDeclRef))
                {
                    if(let memberSubscriptDeclRef = as<SubscriptDecl>(memberDeclRef))
                    {
                        addSubscriptOverloadCandidate(&overloadContext, memberSubscriptDeclRef);
                    }

                }
            }
        }

        return completeOverload(&overloadContext);
    }
    else if(let appExp = as<AppExp>(exp))
    {
        let base = checkTerm(context, appExp.base);
        appExp.base = base;
        foreach(arg in appExp.args)
        {
            arg.exp = checkTerm(context, arg.exp);
        }

        // If the base expression or any argument is in error,
        // en don't bother trying to resolve things
        if(isError(context, base))
        {
            return createErrorExp(context, appExp);
        }

        var overloadContext : OverloadResolveContext;
        overloadContext.checkContext = context;
        overloadContext.appExp = appExp;
        overloadContext.baseExp = nullptr;


        if(let baseMemberRef = as<MemberExp>(base))
        {
            overloadContext.baseExp = baseMemberRef.base;
        }

        addAppOverloadCandidates(
            &overloadContext,
            base);

        return completeOverload(&overloadContext);
    }
	else if(let appExp = as<AppExpBase>(exp))
	{
		let base = checkTerm(context, appExp.base);
        appExp.base = base;
		foreach(arg in appExp.args)
		{
			arg.exp = checkTerm(context, arg.exp);
		}

        // If the base expression or any argument is in error,
        // en don't bother trying to resolve things
        if(as<ErrorExp>(base))
        {
            return createErrorExp(context, appExp.loc);
        }


		// inspect the base expression, and check it against
		// the operands...
		if(let baseDeclRefExp = as<DeclRefExp>(base))
		{
			// the base refers to an explicit declaration, so we can
			// check for how to apply it...
            let baseDeclRef = baseDeclRefExp.declRef;
            if(let patternDeclRef = as<PatternDecl>(baseDeclRef))
			{
				var argIter : Arg = appExp.args.head;

				foreach(declRef in getDecls(patternDeclRef))
				{
					let paramRef = as<ParamDecl>(declRef);
					if(!paramRef) continue;

					let arg : Arg = argIter;
					argIter = argIter.next;

					// try to match things up!
				}

				//
				appExp.type = getResultType(context, patternDeclRef);
				return appExp;
			}
			else if(let genericDeclRef = as<GenericDecl>(baseDeclRef))
			{
				var argIter = appExp.args.head;

				foreach(decl in getDecls(genericDeclRef))
				{
					let param = as<GenericParamDecl>(decl);
					if(!param) continue;

					let arg = argIter;
					argIter = argIter.next;

					// try to match things up!
				}

                let specializations = createObject<Specializations>();
                specializations.genericDeclRef = genericDeclRef;

                var specArgLink = &specializations.args.head;
                argIter = appExp.args.head;
                foreach(decl in getDecls(genericDeclRef))
                {
                    let param = as<GenericParamDecl>(decl);
                    if(!param) continue;

                    let arg = argIter;
                    argIter = argIter.next;

                    // try to match things up!
                    let specArg = createObject<SpecializationArg>();
					specArg.param = param;
                    specArg.value = extractVal(arg.exp);

                    *specArgLink = specArg;
                    specArgLink = &specArg.next;
                }

                let innerDeclRef = DeclRefVal(genericDeclRef.getDecl().inner, specializations);

                return createDeclRefExp(
                    context,
                    innerDeclRef,
                    appExp.loc);
			}
		}

		diagnose(getSink(context), exp.loc, kDiagnostic_unimplemented, exp.directClass.name);
		cogAssert(!"unimplemented");
		return 0;
	}
	else if(let thisExpr = as<ThisExpr>(exp))
	{
		var scope = thisExpr.scope;
		while(scope)
		{
			let containerDecl = scope.directLink.container;
			let aggTypeDecl = as<AggTypeDecl>(containerDecl);
			if(aggTypeDecl)
			{
				thisExpr.type = createDeclRefType(
					context,
					DeclRefVal(aggTypeDecl));
				return thisExpr;
			}

			scope = scope.parent;
		}

		// TODO: need to fill in the type!

		diagnose(getSink(context), exp.loc, kDiagnostic_unimplemented, "this expression type");

		return createErrorExp(context, exp);
	}
	else if(let castExpr = as<CastExpr>(exp))
	{
		checkTypeExp(context, &castExpr.toType);
		castExpr.arg = checkTerm(context, castExpr.arg);

		// TODO: should validate the cast

		castExpr.type = castExpr.toType.type;
		return castExpr;
	}
	else if(let parenExpr = as<ParenExp>(exp))
	{
		let base = checkTerm(context, parenExpr.base);
		parenExpr.base = base;
		parenExpr.type = base.type;
		return parenExpr;
	}
	else
	{
		diagnose(getSink(context), exp.loc, kDiagnostic_unimplemented, exp.directClass.name);
		cogAssert(!"unimplemented");
		return 0;
	}
}

//

func extractVal(
	exp: Exp)
    -> Val
{
    if(let typeType = as<TypeType>(exp.type))
    {
        return typeType.type;
    }
    else
    {
        cogAssert(!"unimplemented");
    }
}

//

func checkMemberExp(
	context: CheckContext*,
	exp: MemberExp)
    -> Exp
{
    var base = exp.base;
    base = checkTerm(context, base);

    let memberName = exp.memberName;

    // If there was an error in the base expression,
    // en just return an error so we don't cascade
    if(isError(context, base))
    {
        return createErrorExp(context, exp);
    }

    let baseType = base.type;
    if(let baseDeclRefType = as<DeclRefType>(baseType))
    {
        let baseDeclRef = baseDeclRefType.declRef;
        if(let aggTypeDeclRef = as<AggTypeDecl>(baseDeclRef))
        {
            // look up in the scope of that decl...

            // TODO: inheritance and all that...

            let lookupResult = lookupDirect(
                aggTypeDeclRef,
                memberName);

            if(lookupResult.isUnique())
            {
                return createDeclRefExp(
                    context,
                    CompactDeclRef(lookupResult.getDecl()),
                    exp.loc,
                    base);
            }
            else if(lookupResult.isOverloaded())
            {
                let overloadedExpr = createObject<OverloadedExpr>();
                overloadedExpr.loc = exp.loc;
                overloadedExpr.lookupResult = lookupResult;
                overloadedExpr.type =  createObject<OverloadGroupType>();
                overloadedExpr.base = base;
                return overloadedExpr;
            }
        }
    }


    diagnose(getSink(context), exp.loc, kDiagnostic_noMemberOfNameInType, memberName, baseType);
    return createErrorExp(context, exp);
}

//

func addAppOverloadCandidates(
	context: OverloadResolveContext*,
	baseExp: Exp)
{
//    fprintf(stderr, "<<<\n");
    if(let typeType = as<TypeType>(baseExp.type))
    {
//        fprintf(stderr, "AAA \n");
//        formatType(stderr, typeType.type);
        addTypeOverloadCandidates(context, baseExp, typeType.type);
    }
    else if(let declRefExp = as<DeclRefExp>(baseExp))
    {
//        fprintf(stderr, "BBB\n");
        // We have a declaration, and we are trying to call it
        addDeclRefOverloadCandidates(context, declRefExp.declRef);
    }
    else if(let overloadedExpr = as<OverloadedExpr>(baseExp))
    {
        cogAssert(!context.baseExp);
        context.baseExp = overloadedExpr.base;

//        fprintf(stderr, "CCC\n");
        cogAssert(overloadedExpr.lookupResult.items.getCount() != 0);
        foreach(item in overloadedExpr.lookupResult)
        {
//            fprintf(stderr, "item: %s\n", getText(item.decl->name).begin);
            addDeclRefOverloadCandidates(
                context,
                DeclRefVal(item.decl));
        }
    }
    else
    {
//        diagnose(getSink(context->checkContext), baseExp->loc, kDiagnostic_unimplemented, "can't apply this!");
    }
//    fprintf(stderr, ">>>\n");
}


func createFuncType(
	context: CheckContext*,
	funcDeclRef: DeclRefValImpl<FuncDeclBase>)
    -> Type
{
    let funcType = createObject<FuncType>();
    return funcType;
}

//

func createDeclRefType(
	context: CheckContext*,
	declRef: DeclRefVal)
	-> Type
{
	let type = createObject<DeclRefType>();
	type.declRef = CompactDeclRef(declRef);
	return type;
}

func createDeclRefTypeType(
	context: CheckContext*,
	declRef: DeclRefVal)
	-> Type
{
	let type = createDeclRefType(context, declRef);
	let typeType = createTypeType(context, type);
	return typeType;
}

func createTypeType(
	context: CheckContext*,
	type: Type)
	-> TypeType
{
	let typeType = createObject<TypeType>();
	typeType.type = type;
	return typeType;
}

func specializeTypeForDeclRef(
	context: 	CheckContext*,
	type:		Type,
	declRef:	DeclRefVal)
	-> Type
{
	return specializeType(
		type,
		declRef.specializations);
}

//

func getTypeForDeclRefImpl(
	context: CheckContext*,
	declRef: DeclRefVal)
	-> Type
{
    let decl = declRef.getDecl();

    ensureDecl(context, decl);

    if(let varDecl = as<VarDeclBase>(decl))
	{
		// TODO: need to force decl here?
		return specializeTypeForDeclRef(context, varDecl.type.type, declRef);
	}
	else if(let aggTypeDecl = as<AggTypeDecl>(decl))
	{
        return createDeclRefTypeType(context, declRef);
	}
    else if(let typeVarDecl = as<TypeVarDecl>(decl))
    {
        return createDeclRefTypeType(context, declRef);
    }
    else if(let genericDecl = as<GenericDecl>(decl))
    {
        return createDeclRefTypeType(context, declRef);
    }
    else if(let funcDeclRef = as<FuncDeclBase>(declRef))
    {
        return createFuncType(context, funcDeclRef);
    }
	else
	{
		cogAssert(!"unimplemented");
        return 0;
	}
}

func getTypeForDeclRef(
	context: CheckContext*,
	declRef: DeclRefVal)
	-> Type
{
    let result = getTypeForDeclRefImpl(context, declRef);
//    fprintf(stderr, "getTypeForDeclRef(%s) = ",
//        getText(declRef.decl.name).begin);
//    printType(stderr, result);
//    fprintf(stderr, "\n");
    return result;
}

func getTypeForDeclRef(
	context: CheckContext*,
	declRef: CompactDeclRef)
	-> Type
{
	return getTypeForDeclRef(
		context,
		DeclRefVal(declRef));
}

func createErrorType(
	context: CheckContext*)
	-> Type
{
    return createObject<ErrorType>();
}

func getBuiltinType(
	context: CheckContext*,
	loc: SourceLoc,
	name: ConstPtr<Char>)
    -> Type
{
    let cogModuleName = getName(context.shared.session, "cog");
    var cogModule : ModuleDecl = nullptr;
    if(context.shared.session.moduleDecl.name == cogModuleName)
    {
        cogModule = context.shared.session.moduleDecl;
    }
    else
    {
        cogModule = findOrImportModule(context.shared.session, loc, cogModuleName);        
    }

    let nameSpan = TerminatedStringSpan(name);
    foreach(decl in cogModule.getDecls())
    {
        if(decl.name && getText(decl.name) == nameSpan)
        {
            let type = createObject<DeclRefType>();
            type.declRef = CompactDeclRef(decl);

            return type;
        }
    }

    diagnose(getSink(context), loc, kDiagnostic_failedToFindBuiltinType, name);
    return createErrorType(context);
}

func getResultType(
	context: CheckContext*,
	decl: DeclRefValImpl<PatternDecl>)
	-> Type
{
    // TODO(tfoley): this should be simplified to
    // just use the `FuncDeclBaseRef`
	if(let funcDeclRef = as<FuncDecl>(decl))
	{
		return getResultType(funcDeclRef);
	}
    else if(let subscriptDeclRef = as<SubscriptDecl>(decl))
    {
        return getResultType(subscriptDeclRef);
    }
    else if(let typeDeclRef = as<AggTypeDecl>(decl))
    {
        return createDeclRefType(context,
            CompactDeclRef(typeDeclRef));
    }
	else
	{
		// TODO: need to return the `Void` type...
        diagnose(getSink(context), decl.decl.loc, kDiagnostic_unimplemented, "result type");
		return 0;
	}
}

func createErrorExp(
	context: CheckContext*,
	exp: Exp)
    -> Exp
{
    exp.type = createErrorType(context);
    return exp;
}

func createErrorExp(
	context: CheckContext*,
	loc: SourceLoc)
    -> Exp
{
    let exp = createObject<ErrorExp>();
    exp.loc = loc;
    return createErrorExp(context, exp);
}

func isSameVal(
	left: Val,
	right: Val)
    -> Bool
{
    if(let leftType = as<Type>(left))
    {
        if(let rightType = as<Type>(right))
        {
            return isSameType(leftType, rightType);

        }
    }

    //

    cogAssert(!"unimplemented");
    return false;
}

func isSameSpecializations(
	left: Specializations,
    right: Specializations)
    -> Bool
{
    // Null specializations are equal.
    if(!left || !right)
        return left == right;

    if(!isSameDeclRef(
        left.genericDeclRef,
        right.genericDeclRef))
    {
        return false;
    }

    var leftCursor = left.args.begin();
    var rightCursor = right.args.begin();

    while(leftCursor != left.args.end())
    {
        let leftArg = *leftCursor;
        let rightArg = *rightCursor;

        if(!isSameVal(
            leftArg.value,
            rightArg.value))
        {
            return false;
        }


        ++leftCursor;
        ++rightCursor;
    }

    return true;
}


func isSameDeclRef(
	left: ConstRef<DeclRefVal>,
	right: ConstRef<DeclRefVal>)
    -> Bool
{
    if(left.decl != right.decl)
        return false;

    return isSameSpecializations(
        left.specializations,
        right.specializations);
}

func isSameType(
	left: Type,
	right: Type)
    -> Bool
{
    if(left.directClass != right.directClass)
        return false;

    if(let leftDeclRefType = as<DeclRefType>(left))
    {
        if(let rightDeclRefType = as<DeclRefType>(right))
        {
            // check that they reference the same thing!
            if(isSameDeclRef(
                leftDeclRefType.declRef,
                rightDeclRefType.declRef))
            {
                return true;
            }
        }
    }

    return false;
}

func tryCoerceImpl(
	context: 	CheckContext*,
    fromExp: 	Exp,
    fromType: 	Type,
    toExp: 		Exp*,
    toType:		Type)
    -> Bool
{
    if(isSameType(fromType, toType))
    {
        if(toExp)
        {
            *toExp = fromExp;
        }

        return true;
    }

    if(isError(fromType) || isError(toType))
    {
        if(toExp)
        {
            *toExp = fromExp;
        }
        return true;
    }

//    fprintf(stderr, "FAILED: tryCoerceImpl(from:");
//    formatType(stderr, fromType);
//    fprintf(stderr, ", to:");
//    formatType(stderr, toType);
//    fprintf(stderr, ")\n");

    return false;
}

func tryCoerceImpl(
	context: 	CheckContext*,
    fromExp: 	Exp,
    toExp: 		Exp*,
    toType:		Type)
    -> Bool
{
    if(let fromOverloadedExpr = as<OverloadedExpr>(fromExp))
    {
        // TODO: implement this case!

        cogAssert(!"unimplemented");
    }
    else
    {
        return tryCoerceImpl(
            context,
            fromExp,
            fromExp.type,
            toExp,
            toType);
    }
}

func coerce(
	context: 	CheckContext*,
    exp: 		Exp,
    type: 		Type)
    -> Exp
{
    var result : Exp = nullptr;
    if(tryCoerceImpl(
        context,
        exp,
        &result,
        type))
    {
        return result;
    }

    diagnose(getSink(context), exp.loc, kDiagnostic_cannotConvertType, type, exp.type);
    return createErrorExp(context, exp);
}

func canCoerce(
	context: 	CheckContext*,
    exp: 		Exp,
    type: 		Type)
    -> Bool
{
    return tryCoerceImpl(
        context,
        exp,
        nullptr,
        type);
}

enum OverloadCandidateState
{
    kOverloadCandidateState_Unchecked,
    kOverloadCandidateState_GenericArgumentInferenceFailed,
    kOverloadCandidateState_CheckedArity,
    kOverloadCandidateState_CheckedTypes,
    kOverloadCandidateState_Applicable,
}


struct OverloadCandidate
{
	var state 		: OverloadCandidateState;
	var declRef 	: DeclRefVal;
	var resultType 	: Type;
}

enum OverloadResolveMode
{
    kOverloadResolveMode_justTrying,
    kOverloadResolveMode_forReal,
}

struct OverloadResolveContext
{
	var checkContext 	: CheckContext*;
    var appExp 			: AppExpBase;
    var baseExp 		: Exp = nullptr;

    var mode : OverloadResolveMode = kOverloadResolveMode_justTrying;

    // candidates being considered
    var candidates : Array<OverloadCandidate>;
}

func checkOverloadCandidateArity(
	context: OverloadResolveContext*,
    candidate: Ref<OverloadCandidate>)
    -> Bool
{
    let args = &context.appExp.args;
    let argCursor = args.begin();
    let argEnd = args.end();

    if(let funcDeclRef = as<FuncDeclBase>(candidate.declRef))
    {
        foreach(dd in getDecls(funcDeclRef))
        {
            if(let paramDeclRef = as<ParamDecl>(dd))
            {
                if(!(argCursor != argEnd))
                {
                    // not enough args!
                    return false;
                }

                ++argCursor;
            }
            else
            {}
        }

        if(argCursor != argEnd)
        {
            // too many args!
            return false;
        }

        return true;
    }
    else
    {
        // TODO: other cases here?
        return false;
    }
}

func checkOverloadCandidateTypes(
	context: OverloadResolveContext*,
    candidate: Ref<OverloadCandidate>)
    -> Bool
{
    let args = &context.appExp.args;
    let argCursor = args.begin();
    let argEnd = args.end();

    if(let funcDeclRef = as<FuncDeclBase>(candidate.declRef))
    {
        foreach(dd in getDecls(funcDeclRef))
        {
            if(let paramDeclRef = as<ParamDecl>(dd))
            {
                if(!(argCursor != argEnd))
                {
                    cogAssert(false);
                    // not enough args!
                    return false;
                }

                let arg = *argCursor;
                let argExpr = &arg.exp;

                let paramType = getType(paramDeclRef);

                if(context.mode == kOverloadResolveMode_justTrying)
                {
                    if(!canCoerce(
                        context.checkContext,
                        *argExpr,
                        paramType))
                    {
                        return false;
                    }
                }
                else
                {
                    *argExpr = coerce(
                        context.checkContext,
                        *argExpr,
                        paramType);
                }

                ++argCursor;
            }
            else
            {}
        }

        if(argCursor != argEnd)
        {
            cogAssert(false);
            // too many args!
            return false;
        }

        return true;
    }
    else
    {
        // TODO: other cases here?
        return false;
    }
}

func checkOverloadCandidateDirections(
    context: OverloadResolveContext*,
    candidate: Ref<OverloadCandidate>)
    -> Bool
{
    return true;
}

func checkOverloadCandidateImpl(
    context: OverloadResolveContext*,
    candidate: Ref<OverloadCandidate>)
{
    // check arity
    candidate.state = kOverloadCandidateState_Unchecked;
    if(!checkOverloadCandidateArity(context, candidate))
        return;
    candidate.state = kOverloadCandidateState_CheckedArity;
    if(!checkOverloadCandidateTypes(context, candidate))
        return;
    candidate.state = kOverloadCandidateState_CheckedTypes;
    if(!checkOverloadCandidateDirections(context, candidate))
        return;
    candidate.state = kOverloadCandidateState_Applicable;

    // consider other costs...
}

func checkOverloadCandidate(
    context: OverloadResolveContext*,
    candidate: Ref<OverloadCandidate>)
{
    checkOverloadCandidateImpl(context, candidate);
//    fprintf(stderr, "CANDIDATE STATE: %d\n", (int) candidate.state);
}

func compareCandidates(
	left: Ref<OverloadCandidate>,
	right: Ref<OverloadCandidate>)
    -> Int
{
    // a higher state value is better (lower cost)
    if(left.state != right.state)
        return int(right.state) - int(left.state);

    // TODO: more detailed comparisons

    // otherwise they are un-ordered
    return 0;
}

func addCheckedOverloadCandidate(
    context: OverloadResolveContext*,
    candidate: Ref<OverloadCandidate>)
{
    // We now need to filter our set of candidates,
    // and eliminate those that are strictly
    // worse than this one (we also can check if
    // is one is strictly worse than any)

    var anyBetter : Bool = false;
    var anyWorse : Bool = false;

    // Note: check count inside loop because we are
    // modifying it on the fly
    for(var ii : UInt = 0; ii < context.candidates.getCount(); ++ii)
    {
        let compareResult = compareCandidates(
            candidate,
            context.candidates[ii]);

//        fprintf(stderr, "COMPARE: %d\n", compareResult);

        if(compareResult < 0)
        {
//            fprintf(stderr, "REMOVING OLD: %d\n", (int)ii);
            // new candidate is better/cheaper
            context.candidates.fastRemoveAt(ii);

            anyBetter = true;

            // retry the same index, because of removal...
            --ii;
        }
        else if(compareResult > 0)
        {
//            fprintf(stderr, "SKIPPING NEW: %d\n", (int)ii);
            // old candidate is beter/cheaper
            anyWorse = true;
        }
    }

    if(anyWorse)
    {
        cogAssert(!anyBetter);

        // our candidate was strictly worse
        // an at least one alternative,
        // so we should give up
        return;
    }

    // is candidate is worth looking at, it seems
    context.candidates.append(candidate);
}

func addOverloadCandidate(
    context: OverloadResolveContext*,
    candidate: Ref<OverloadCandidate>)
{
    checkOverloadCandidate(context, candidate);
    addCheckedOverloadCandidate(context, candidate);
}

func addSubscriptOverloadCandidate(
    context: OverloadResolveContext*,
    declRef: DeclRefValImpl<SubscriptDecl>)
{
    // TODO: actually do stuff!

	ensureDecl(context.checkContext, declRef.getDecl());

    var candidate: OverloadCandidate;
    candidate.declRef = declRef;
    candidate.resultType = getResultType(context.checkContext, declRef);

    addOverloadCandidate(context, candidate);
}

func addFuncOverloadCandidate(
    context: OverloadResolveContext*,
    declRef: DeclRefValImpl<FuncDeclBase>)
{
	ensureDecl(context.checkContext, declRef.getDecl());

    var candidate: OverloadCandidate;
    candidate.declRef = declRef;
    candidate.resultType = getResultType(context.checkContext, declRef);

    addOverloadCandidate(context, candidate);
}

func addInitializerOverloadCandidate(
    context: 	OverloadResolveContext*,
    type: 		Type,
    declRef: 	DeclRefValImpl<InitializerDecl>)
{
    var candidate: OverloadCandidate;
    candidate.declRef = declRef;
    candidate.resultType = type;
    addOverloadCandidate(context, candidate);
}

func createDeclRefExp(
	context: CheckContext*,
	declRef: CompactDeclRef,
	loc: SourceLoc,
	baseExp: Exp)
    -> Exp
{
    var declRefExp: DeclRefExp = nullptr;
    if(baseExp)
    {
        let memberRefExp = createObject<MemberExp>();
        memberRefExp.base = baseExp;
        declRefExp = memberRefExp;
    }
    else
    {
        declRefExp = createObject<DeclRefExp>();
    }

    declRefExp.loc = loc;
    declRefExp.declRef = declRef;
    declRefExp.type = getTypeForDeclRef(context, declRef);
    return declRefExp;
}

func createDeclRefExp(
	context: CheckContext*,
	declRef: DeclRefVal,
	loc: SourceLoc,
	baseExp: Exp)
    -> Exp
{

    let decl = declRef.getDecl();
    if(let specializations = declRef.getSpecializations())
    {
        let specializedDecl = createObject<SpecializedDecl>();
        specializedDecl.decl = decl;
        specializedDecl.specializations = specializations;

        return createDeclRefExp(context, CompactDeclRef(specializedDecl), loc, baseExp);
    }
    else
    {
        return createDeclRefExp(context, CompactDeclRef(decl), loc, baseExp);
    }
}

// TODO(tfoley): support default arguments
func createDeclRefExp(
	context: CheckContext*,
	declRef: DeclRefVal,
	loc: SourceLoc)
    -> Exp
{
	return createDeclRefExp(context, declRef, loc, nullptr);
}

func completeOverload(
    overloadContext: OverloadResolveContext*)
    -> Exp
{
    let context = overloadContext.checkContext;
    let appExp = overloadContext.appExp;

    let count = overloadContext.candidates.getCount();

    var baseName : Name* = nullptr;
    if(let declRefExp = as<DeclRefExp>(appExp.base))
    {
        baseName = declRefExp.declRef.getDecl().name;
    }
    else if(let nameExp = as<NameExp>(appExp.base))
    {
        baseName = nameExp.name;
    }
    else if(let overloadedExpr = as<OverloadedExpr>(appExp.base))
    {
        baseName = overloadedExpr.lookupResult.items[0].decl.name;
    }

    if(count == 1)
    {
        // exactly one best candidate found

        let candidate = &overloadContext.candidates[0];
        if(candidate.state == kOverloadCandidateState_Applicable)
        {
            // we can use it!
            let baseExp = createDeclRefExp(
                context,
                candidate.declRef,
                appExp.loc,
                overloadContext.baseExp);

            appExp.base = baseExp;
            appExp.type = candidate.resultType;
            return appExp;            
        }
        else
        {
            // TODO: re-check to get good errors

            overloadContext.mode = kOverloadResolveMode_forReal;
            checkOverloadCandidate(
                overloadContext,
                *candidate);
            return createErrorExp(context, appExp.loc);
        }
    }
    else if(count == 0)
    {
        // no candidates were considered!
        diagnose(getSink(context), appExp.loc, kDiagnostic_noOverloadCandidatesFound, baseName);

        if(let overloadedExpr = as<OverloadedExpr>(appExp.base))
        {
            foreach( item in overloadedExpr.lookupResult)
            {
                diagnose(getSink(context), item.decl.loc, kDiagnostic_candidate, DeclRefVal(item.decl));                
            }
        }

        return createErrorExp(context, appExp.loc);
    }
    else
    {
        // must have been multiple candidates
        if(overloadContext.candidates[0].state == kOverloadCandidateState_Applicable)
        {
            // ey were applicable, so this is ambiguous!
            diagnose(getSink(context), appExp.loc, kDiagnostic_ambiguousCallToOverload, baseName, ArgTypeList(appExp.args.head));

            foreach( cc in overloadContext.candidates)
            {
                diagnose(getSink(context), cc.declRef.getDecl().loc, kDiagnostic_candidate, cc.declRef);
            }

            return createErrorExp(context, appExp.loc);
        }
        else
        {
            // ey were applicable, so this is ambiguous!
            diagnose(getSink(context), appExp.loc, kDiagnostic_noApplicableOverloadForCall, baseName, ArgTypeList(appExp.args.head));

            foreach(cc in overloadContext.candidates)
            {
                diagnose(getSink(context), cc.declRef.getDecl().loc, kDiagnostic_candidate, cc.declRef);
            }

            return createErrorExp(context, appExp.loc);
        }
    }
}

func isError(
	type: Type)
    -> Bool
{
    return as<ErrorType>(type) != nullptr;
}

func isError(
	context: CheckContext*,
	exp: Exp)
    -> Bool
{
    return as<ErrorExp>(exp) || isError(exp.type);
}

func addTypeOverloadCandidates(
	context: OverloadResolveContext*,
	typeExp: Exp,
	type: Type)
{
    if(let declRefType = as<DeclRefType>(type))
    {
        if(let aggTypeDeclRef = as<AggTypeDecl>(declRefType.declRef))
        {
            // Need to look for constructors

            foreach( memberDeclRef in getDecls(aggTypeDeclRef))
            {
                if(let initializerDeclRef = as<InitializerDecl>(memberDeclRef))
                {
                    addInitializerOverloadCandidate(context, type, initializerDeclRef);
                }
            }
        }
    }

}

struct GenericInferenceArg
{
	var paramDeclRef: DeclRefValImpl<GenericParamDecl>;
	var val: Val = nullptr;
}

struct GenericInferenceContext
{
	var checkContext: CheckContext*;
	var args: GenericInferenceArg*;
	var argCount: Int;
}

func doInferenceForVals(
	context: GenericInferenceContext*,
	argVal: Val,
	paramVal: Val)
    -> Bool
{
    if(let argType = as<Type>(argVal))
    {
        if(let paramType = as<Type>(paramVal))
        {
            return doInferenceForTypes(context, argType, paramType);
        }
    }

    // no other types of values right now...
    return false;
}

func doInferenceForSpecializations(
	context: GenericInferenceContext*,
    argSpec: Specializations,
    paramSpec: Specializations)
    -> Bool
{
	// Empty specializations only match empty ones
    if(!argSpec || !paramSpec)
    {
    	return argSpec == paramSpec;
    }

    // Make sure we can align the generic being referened
    if(!doInferenceForDeclRefs(
        context,
        argSpec.genericDeclRef,
        paramSpec.genericDeclRef))
    {
        return false;
    }


    // Now walk through the arguments and try to unify
    var aa = argSpec.args.head;
    var pp = paramSpec.args.head;
    while(aa)
    {
        if(!doInferenceForVals(context, aa.value, pp.value))
            return false;

        aa = aa.next;
        pp = pp.next;
    }

    return true;
}

func doInferenceForDeclRefs(
	context: 		GenericInferenceContext*,
    argDeclRef:		DeclRefVal,
    paramDeclRef: 	DeclRefVal)
    -> Bool
{
    // TODO: need to handle possible inheritance here!
    if(paramDeclRef.getDecl()
        != argDeclRef.getDecl())
    {
        return false;
    }

    // Okay, they name the same type, so we need
    // to go ahead and recurse on their specializations.
    return doInferenceForSpecializations(
        context,
        argDeclRef.specializations,
        paramDeclRef.specializations);    
}

func findGenericInferenceArg(
	context: GenericInferenceContext*,
	paramDeclRef: DeclRefValImpl<GenericParamDecl>)
	-> GenericInferenceArg*
{
	for(var ii : Int = 0; ii < context.argCount; ++ii)
	{
		if(isSameDeclRef(context.args[ii].paramDeclRef, paramDeclRef))
			return &context.args[ii];
	}
	return nullptr;
}

func doInferenceForTypes(
    context: GenericInferenceContext*,
    argType: Type,
    paramType: Type)
    -> Bool
{
    //
    if(isSameType(argType, paramType))
        return true;

    if(let paramDeclRefType = as<DeclRefType>(paramType))
    {
        if(let genericParamDeclRef = as<GenericParamDecl>(paramDeclRefType.declRef))
        {
			// The type in parameter position is a generic parameter (we hope
			// that it is a generic parameter of the declaration we hope to specialize).
			// We should note this, so that the argument type will be used to
			// replace the parameter type.


			let genericInferenceArg = findGenericInferenceArg(context, genericParamDeclRef);
			if(genericInferenceArg)
			{
				// TODO: this isn't quite right...
				genericInferenceArg.val = argType;
				return true;
			}
        }

        // Is the argument type a reference to the same
        // type declaration (maybe with different parameters)?
        if(let argDeclRefType = as<DeclRefType>(argType))
        {
            return doInferenceForDeclRefs(
                context,
                argDeclRefType.declRef,
                paramDeclRefType.declRef);
        }
    }

    // no match!
    return false;
}


func doInferenceForArgAndParam(
    context: GenericInferenceContext*,
    argExpr: Exp,
    paramDeclRef: DeclRefValImpl<ParamDecl>)
    -> Bool
{
    return doInferenceForTypes(
        context,
        argExpr.type,
        getType(paramDeclRef));
}

func inferGenericArgsForApp(
    context: CheckContext*,
    genericDeclRef: DeclRefValImpl<GenericDecl>,
    appExpr: AppExpBase)
    -> Specializations
{
    // Need to find a suitable value to substitute
    // for each parameter of the given generic.
    //
    // We can do this by trying to "unify" the
    // argument and parameter types, and find
    // constraints that they place on each parameter

    let innerDeclRef = getInner(genericDeclRef);
    let innerFuncDeclRef = as<FuncDeclBase>(innerDeclRef);
    if(!innerFuncDeclRef)
    {
        // TODO: consider generic types...
        return nullptr;
    }


    var args: Array<GenericInferenceArg>;
    foreach( member in getDecls(genericDeclRef))
    {
        if(let genericParamDeclRef = as<GenericParamDecl>(member))
        {
            var arg: GenericInferenceArg;
            arg.paramDeclRef = genericParamDeclRef;

            args.append(arg);
        }
        else
        {
            // TODO: handle non-type parameters!
        }
    }

    var inferenceContext : GenericInferenceContext;
    inferenceContext.checkContext = context;
    inferenceContext.args = &args[0];
	inferenceContext.argCount = args.getCount();

    var aa = appExpr.args.begin();
    let ae = appExpr.args.end();
    foreach(member in getDecls(innerFuncDeclRef))
    {
        let paramDeclRef = as<ParamDecl>(member);
        if(!paramDeclRef)
            continue;

        if(!(aa != ae))
        {
            // Too few args!
            return nullptr;
        }

        let arg = *aa;
        ++aa;

        // We have an arg and param,
        // and need to match them up!
        if(!doInferenceForArgAndParam(
            &inferenceContext,
            arg.exp,
            paramDeclRef))
        {
            return nullptr;
        }
    }
    if(aa != ae)
    {
        // Too few args!
        return nullptr;
    }

    // Now let's see if the arguments can be inferred from what
    // we've seen!
    foreach(arg in args)
    {
        if(!arg.val)
            return nullptr;
    }


    return nullptr;
}

func addGenericOverloadCandidate(
    context: OverloadResolveContext*,
    genericDeclRef: DeclRefValImpl<GenericDecl>)
{
	ensureDecl(context.checkContext, genericDeclRef.getDecl());

    // Need to infer argument types and then apply
    // based on those.
    //
    // Long-term we probably want to infer using
    // something like a constraint solver, but
    // for right now lets just do the easy thing
    // and use a local inference step.

    let innerDeclRef = getInner(genericDeclRef);
    let specializations = inferGenericArgsForApp(
        context.checkContext,
        genericDeclRef,
        context.appExp);
    if(specializations)
    {
        innerDeclRef.specializations = specializations;
    }

    // TODO: probably need to add an asosciated cost
    // so that this overload is considered "worse"
    // an an explicit match...

    addDeclRefOverloadCandidates(context, innerDeclRef);
}

func addDeclRefOverloadCandidates(
    context: OverloadResolveContext*,
    val: DeclRefVal)
{
    if(let funcDeclRef = as<FuncDeclBase>(val))
    {
        addFuncOverloadCandidate(context, funcDeclRef);
    }
    else if(let genericDeclRef = as<GenericDecl>(val))
    {
        addGenericOverloadCandidate(context, genericDeclRef);
    }
    else
    {
//        diagnose(getSink(context->checkContext), val.getDecl()->loc, kDiagnostic_unimplemented, "can't apply this!");
    }
}

//

func findSpecialization(
	specializations:	Specializations,
	decl:				Decl)
	-> Val
{
	foreach(arg in specializations.args)
	{
		if(decl == arg.param)
		{
			return arg.value;
		}
	}

	return nullptr;
}

func specializeDeclRef(
	declRef: DeclRefVal,
	specializations: Specializations)
	-> DeclRefVal
{
	let oldDecl = declRef.getDecl();
	let oldSpecializations = declRef.getSpecializations();

	// Is the decl one we should specialize?
	if(let genericTypeParamDecl = as<GenericParamDecl>(oldDecl))
	{
		// Is it one being specialized?
		if(let newVal = findSpecialization(specializations, genericTypeParamDecl))
		{
			if(let typeDeclRef = as<DeclRefType>(newVal))
				return typeDeclRef.declRef;
		}

		cogAssert(!"unimplemented");
	}

	if(!oldSpecializations)
		return declRef;

	// otherwise we need to specialize the specializations themselves


	cogAssert(!"unimplemented");

	return DeclRefVal();
}

func specializeType(
	type: Type,
	specializations: Specializations)
	-> Type
{
	if(!specializations)
		return type;

	if(let declRefType = as<DeclRefType>(type))
	{
		// TODO: scavenge memory as needed
		let specDeclRef = specializeDeclRef(declRefType.declRef, specializations);

		let specType = createObject<DeclRefType>();
		specType.declRef = CompactDeclRef(specDeclRef);
		return specType;
	}

	if(let errorType = as<ErrorType>(type))
		return errorType;

	cogAssert(!"unimplemented");
	return nullptr;
}

//

func ensureDecl(
	context: CheckContext*,
	decl: Decl,
	state: DeclCheckState)
{
	if(decl.checkState >= state)
		return;

	checkDecl(context, decl);
}

func ensureDecl(
	context: CheckContext*,
	decl: Decl)
{
	ensureDecl(context, decl, kDeclCheckState_CheckedHead);
}