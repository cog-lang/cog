// check.cog

import cog;

func checkModule(
    session: Session)
{
	checkModule(session, session.moduleDecl);
}

// Explicit entry point for checking a given module
func checkModule(
	session: Session,
	moduleDecl: ModuleDecl)
{
	var sharedContext : SharedCheckContext;
	sharedContext.session = session;

	var context : CheckContext;
	context.shared = &sharedContext;

	addWorkItem(&sharedContext, moduleDecl, kDeclCheckPhase_PreCheckHead);

	while(sharedContext.workList.getCount() != UInt(0))
	{
		let count = sharedContext.workList.getCount();
		let item = sharedContext.workList[count-UInt(1)];
		sharedContext.workList.removeAt(count-UInt(1));

		checkDecl(&context, item.decl, item.state);

		if(item.state != kDeclCheckPhase_CheckBody)
		{
			addWorkItem(&context, item.decl,
				cast<DeclCheckState>(item.state + 1));
		}
	}
}

// One item that we need to process during semantic checking.
//
// This represents a request to ensure that `decl` has
// been checked enough to satisfy the state `state.
struct CheckWorkItem
{
	var decl : Decl;
	var state : DeclCheckState;
}

struct SharedCheckContext
{
	var session : Session;

	var workList : Array<CheckWorkItem>;
}

func addWorkItem(
	shared: SharedCheckContext*,
	decl: Decl,
	state: DeclCheckState)
{
	var item : CheckWorkItem;
	item.decl = decl;
	item.state = state;
	shared.workList.append(item);
}

func addWorkItem(
	context: CheckContext*,
	decl: Decl,
	state: DeclCheckState)
{
	addWorkItem(context.shared, decl, state);
}

struct CheckContext
{
	var shared : SharedCheckContext*;
}

func getSink(
	context: CheckContext*) -> DiagnosticSink*
{
	return &context.shared.session.sink;
}

func checkImportDecls(
	context: CheckContext*,
	containerDecl: ContainerDecl,
	state: DeclCheckState)
{
	if(state != kDeclCheckPhase_PreCheckHead)
		return;

	foreach(decl in containerDecl.getDecls())
	{
		if(let importDecl = as<ImportDecl>(decl))
		{
	    	// Need to wire the import up into the current scope

	    	let module = findOrImportModule(context.shared.session, importDecl.loc, importDecl.name);

	    	attachToScope(importDecl.scope, module);
		}
	}
	
}

func checkDecls(
	context: 		CheckContext*,
	containerDecl: 	ContainerDecl,
	state: DeclCheckState)
{
	checkImportDecls(context, containerDecl, state);

	foreach(decl in containerDecl.getDecls())
	{
		checkDecl(context, decl, state);
	}
}

func attachToScope(
	scope:	Scope*,
	decl: 	ContainerDecl)
{
    let link = cast<Ptr<ScopeLink> >(malloc(sizeof(ScopeLink)));
	link.container = decl;
	link.next = null;

	link.next = scope.directLink.next;
	scope.directLink.next = link;
}

func checkDecl(
	context: CheckContext*,
	decl: Decl,
	state: DeclCheckState)
{
	if(let classDecl = as<ClassDecl>(decl))
	{
		checkClassDecl(context, classDecl, state);
	}
	else if(let structDecl = as<StructDecl>(decl))
	{
		checkStructDecl(context, structDecl, state);
	}
	else if(let funcDecl = as<FuncDeclBase>(decl))
	{
		checkFuncDecl(context, funcDecl, state);
	}
	else if(let varDecl = as<VarDeclBase>(decl))
	{
		checkVarDecl(context, varDecl, state);
	}
	else if(let genericDecl = as<GenericDecl>(decl))
	{
		checkGenericDecl(context, genericDecl, state);
	}
	else if(let typeAliasDecl = as<TypeAliasDecl>(decl))
	{
		checkTypeAliasDecl(context, typeAliasDecl, state);
	}
	else if(let genericParamDecl = as<GenericParamDecl>(decl))
	{
		checkGenericParamDecl(context, genericParamDecl, state);
	}
    else if(let importDecl = as<ImportDecl>(decl))
    {
    	// Skip in this phase
    }
	else if(let moduleDecl = as<ModuleDecl>(decl))
	{
		checkModuleDecl(context, moduleDecl, state);
	}
	else if(let enumDecl = as<EnumDecl>(decl))
	{
		checkEnumDecl(context, enumDecl, state);
	}
	else
	{
		diagnose(getSink(context), decl.loc, kDiagnostic_unimplemented, decl.directClass.name);	
	}
}

func checkEnumDecl(
	context: CheckContext*,
	decl: EnumDecl,
	state: DeclCheckState)
{
	// TODO: implement!
}

func checkModuleDecl(
	context: CheckContext*,
	decl: ModuleDecl,
	state: DeclCheckState)
{
	checkDecls(context, decl, state);
}

func checkGenericParamDecl(
	context: CheckContext*,
	decl: GenericParamDecl,
	state: DeclCheckState)
{
	checkTypeExp(context, &decl.bound);
}

func checkGenericDecl(
	context: CheckContext*,
	decl: GenericDecl,
	state: DeclCheckState)
{
	checkDecls(context, decl, state);
	checkDecl(context, decl.inner, state);
}

func checkTypeAliasDecl(
	context: CheckContext*,
	decl: TypeAliasDecl,
	state: DeclCheckState)
{
	// TODO: implement this...
}

func checkVarDecl(
	context: CheckContext*,
	decl: VarDeclBase,
	state: DeclCheckState)
{
	switch(state)
	{
	case kDeclCheckPhase_CheckHead:
		{
			// check type, if any
			checkTypeExp(context, &decl.type);
		}
		break;

	case kDeclCheckPhase_CheckBody:
		{
			var type = decl.type.type;
			var initExpr = decl.init;
			if(initExpr)
			{
				initExpr = checkTerm(context, initExpr);
				if(type)
				{
					initExpr = coerce(context, initExpr, type);
				}
				else
				{
					// TODO: must coerce to usable...

					type = initExpr.type;
					cogAssert(type);
				}
			}
			else
			{
				if(!type)
				{
					diagnose(getSink(context), decl.loc, kDiagnostic_unimplemented, "decl without init must have type");
					type = createErrorType(context);
				}
			}

			cogAssert(type);

		//    fprintf(stderr, "VAR(%s) TYPE(",
		//    	getText(decl.name).begin);
		//    printType(stderr, type);
		//    fprintf(stderr, ")\n");

			decl.init = initExpr;
			decl.type.type = type;
		}
		break;
	}
}

func checkFuncDecl(
	context: CheckContext*,
	decl: FuncDeclBase,
	state: DeclCheckState)
{
	// check parameters
	checkDecls(context, decl, state);

	switch(state)
	{
	case kDeclCheckPhase_CheckHead:
		{
			// check result type clause, if any
			checkTypeExp(context, &decl.resultType);
			if(!asBool(decl.resultType))
			{
				decl.resultType.type = getBuiltinType(context, decl.loc, "Void");
			}
		}
		break;

	case kDeclCheckPhase_CheckBody:
		{
			if(let body = decl.body)
			{
				decl.body = checkStmt(context, body);
			}
		}
		break;
	}
}

func checkClassDecl(
	context: CheckContext*,
	decl: ClassDecl,
	state: DeclCheckState)
{
	checkAggTypeDeclCommon(context, decl, state);
}

func checkStructDecl(
	context: CheckContext*,
	decl: StructDecl,
	state: DeclCheckState)
{
	checkAggTypeDeclCommon(context, decl, state);
}

func checkAggTypeDeclCommon(
	context: CheckContext*,
	decl: AggTypeDecl,
	state: DeclCheckState)
{
	switch(state)
	{
	case kDeclCheckPhase_CheckHead:
		{
			checkTypeExp(context, &decl.base);
		}
		break;
	}

	// check members up to the same level as the parent
	checkDecls(context, decl, state);
}

//

func checkPrediateExpr(
	context: CheckContext*,
	expr: Exp)
	-> Exp
{
	// TODO: add coercion step
	return checkExp(context, expr);
}

func checkDeclFully(
	context: CheckContext*,
	decl: Decl)
{
	let state : Int = kDeclCheckPhase_PreCheckHead;
	while(state <= kDeclCheckPhase_CheckBody)
	{
		checkDecl(context, decl, cast<DeclCheckState>(state));
		state = state + 1;
	}
}

func checkStmt(
	context: CheckContext*,
	stmt: Stmt)
	-> Stmt
{
    if(!stmt)
        return null;

	if(let blockStmt = as<BlockStmt>(stmt))
	{
		return checkBlockStmt(context, blockStmt);
	}
    else if(let exp = as<Exp>(stmt))
    {
        return checkExp(context, exp);
    }
    else if(let ifStmt = as<IfStmt>(stmt))
    {
        ifStmt.condition = checkPrediateExpr(context, ifStmt.condition);
        ifStmt.thenStmt = checkStmt(context, ifStmt.thenStmt);
        ifStmt.elseStmt = checkStmt(context, ifStmt.elseStmt);
        return ifStmt;
    }
    else if(let ifLetStmt = as<IfLetStmt>(stmt))
    {
        ifLetStmt.init =     checkExp (context, ifLetStmt.init);
        ifLetStmt.thenStmt = checkStmt(context, ifLetStmt.thenStmt);
        ifLetStmt.elseStmt = checkStmt(context, ifLetStmt.elseStmt);
        return ifLetStmt;
    }
    else if(let whileStmt = as<WhileStmt>(stmt))
    {
        whileStmt.condition = checkPrediateExpr(context, whileStmt.condition);
        whileStmt.body = checkStmt(context, whileStmt.body);
        return whileStmt;
    }
    else if(let forStmt = as<ForStmt>(stmt))
    {
        forStmt.init = checkStmt(context, forStmt.init);
        forStmt.condition = checkPrediateExpr(context, forStmt.condition);
        forStmt.iter = checkExp(context, forStmt.iter);
        forStmt.body = checkStmt(context, forStmt.body);
        return forStmt;
    }
    else if(let forEachStmt = as<ForEachStmt>(stmt))
    {
		// TODO: need to introduce a name binding in the scope here...
        forEachStmt.exp = checkExp(context, forEachStmt.exp);
        forEachStmt.body = checkStmt(context, forEachStmt.body);
        return forEachStmt;
    }
    else if(let returnStmt = as<ReturnStmt>(stmt))
    {
        // TODO: coerce value to type expected in context
        returnStmt.value = checkExp(context, returnStmt.value);
        return returnStmt;
    }
    else if(let breakStmt = as<BreakStmt>(stmt))
    {
        // TODO: check that we are inside a breakable context
        return breakStmt;
    }
    else if(let continueStmt = as<ContinueStmt>(stmt))
    {
        // TODO: check that we are inside a breakable context
        return continueStmt;
    }
    else if(let switchStmt = as<SwitchStmt>(stmt))
    {
        switchStmt.condition = checkExp(context, switchStmt.condition);
		foreach(c in switchStmt.cases)
		{
			foreach(a in c.values)
			{
				a.exp = checkExp(context, a.exp);
			}

			c.body = checkStmt(context, c.body);
		}

        return switchStmt;
    }
    else if(let decl = as<Decl>(stmt))
    {
        checkDeclFully(context, decl);
        return decl;
    }
	else
	{
        diagnose(getSink(context), stmt.loc, kDiagnostic_unimplemented, stmt.directClass.name);
		cogAssert(!"unimplemented");
		return null;
	}
}

func checkBlockStmt(
	context: CheckContext*,
	stmt: BlockStmt)
	-> Stmt
{
	foreach(stmt in stmt.stmts)
	{
		checkStmt(context, stmt);
	}

	return stmt;
}

//

func checkExp(
	context: CheckContext*,
	exp: Exp)
	-> Exp
{
	// TODO: what?
	return coerceToExp(context, checkTerm(context, exp));	
}

func coerceToExp(
	context: CheckContext*,
	term: Syntax)
	-> Exp
{
	if(!term)
		return null;

    if(let exp = as<Exp>(term))
    {
        return exp;
    }

    cogAssert(!"need an exp");
    return null;
}

//

func checkType(
	context: CheckContext*,
	exp: Exp)
	-> Type
{
	// TODO: what?
	return coerceToType(context, checkTerm(context, exp));
}

func checkTypeExp(
	context: CheckContext*,
	typeExp: TypeExp*)
{
	let exp = typeExp.exp;
	if(!exp)
		return;

	let type = checkType(context, exp);
	typeExp.type = type;
}

func tryCoerceToTypeExpr(
	context: CheckContext*,
	exp: Exp)
	-> Exp
{
	let expType = exp.type;
	if(let typeType = as<TypeType>(expType))
	{
		return exp;
	}
    else if(let errorType = as<ErrorType>(expType))
    {
        return exp;
    }
	else
	{
		return null;
	}
}


func tryCoerceToType(
	context: CheckContext*,
	exp: Exp)
	-> Type
{
	let typeExpr = tryCoerceToTypeExpr(context, exp);
	if(!typeExpr)
		return null;

	let exprType = typeExpr.type;
	if(let typeType = as<TypeType>(exprType))
	{
		return typeType.type;
	}
    else if(let errorType = as<ErrorType>(exprType))
    {
        return errorType;
    }
	else
	{
		return null;
	}
}

func coerceToType(
	context: CheckContext*,
	exp: Exp)
	-> Type
{
	if(let type = tryCoerceToType(context, exp))
	{
		return type;
	}
	else
	{
        diagnose(getSink(context), exp.loc, kDiagnostic_unimplemented, exp.type.directClass.name);
		return createErrorType(context);
	}
}

func coerceToTypeExpr(
	context: CheckContext*,
	exp: Exp)
	-> Exp
{
	if(let typeExpr = tryCoerceToTypeExpr(context, exp))
	{
		return typeExpr;
	}
	else
	{
        diagnose(getSink(context), exp.loc, kDiagnostic_unimplemented, exp.type.directClass.name);
		return createErrorExp(context, exp);
	}
}

//

func makeErrorExpr(
	context: CheckContext*,
	expr: Exp)
	-> Exp
{
	let errorType = createObject<ErrorType>();
	expr.type = errorType;
	return expr;
}

func checkTerm(
	context: CheckContext*,
	exp: Exp)
	-> Exp
{
	if(!exp) return null;

	if(let nameExp = as<NameExp>(exp))
	{
		let scope = nameExp.scope;
        let result = lookup(scope, nameExp.name);
        if(result.isEmpty())
		{
			// TODO: error
			diagnose(getSink(context), nameExp.loc, kDiagnostic_undefinedIdentifier, nameExp.name);
            return createErrorExp(context, nameExp.loc);
		}
        else if(!result.isOverloaded())
        {
            // form a decl-ref
            let declRef = CompactDeclRef(result.getDecl());
            let declRefExp = createObject<DeclRefExp>();
            declRefExp.loc = exp.loc;
            declRefExp.declRef = declRef;
            declRefExp.type = getTypeForDeclRef(context, declRef);
            return declRefExp;            
        }
		else
		{
            let overloadedExpr = createObject<OverloadedExpr>();
            overloadedExpr.loc = exp.loc;
            overloadedExpr.lookupResult = result;
            overloadedExpr.type =  createObject<OverloadGroupType>();
            return overloadedExpr;
		}
	}
    else if(let memberExp = as<MemberExp>(exp))
    {
        return checkMemberExp(context, memberExp);

    }
    else if(let intLitExp = as<IntLitExp>(exp))
    {
        // TODO: allow more robust inference here...
        intLitExp.type = getBuiltinType(context, intLitExp.loc, "Int");
        return intLitExp;
    }
    else if(let stringLitExp = as<StringLitExp>(exp))
    {
        // TODO: allow more robust inference here...
        stringLitExp.type = getBuiltinType(context, stringLitExp.loc, "String");
        return stringLitExp;
    }
    else if(let charLitExp = as<CharacterLitExp>(exp))
    {
        // TODO: allow more robust inference here...
        charLitExp.type = getBuiltinType(context, charLitExp.loc, "Char");
        return charLitExp;
    }
    else if(let assignExp = as<AssignExp>(exp))
    {
        let left = checkExp(context, assignExp.left);
        var right = checkTerm(context, assignExp.right);
        right = coerce(context, right, left.type);

        assignExp.left = left;
        assignExp.right = right;
        assignExp.type = left.type; // TODO: should probably be `Void`
        return assignExp;
    }
    else if(let indexExp = as<IndexExp>(exp))
    {
        let base = checkTerm(context, indexExp.base);
        indexExp.base = base;
        foreach(arg in indexExp.args)
        {
            arg.exp = checkTerm(context, arg.exp);
        }

        // If the base expression or any argument is in error,
        // en don't bother trying to resolve things
        if(as<ErrorExp>(base) || as<ErrorType>(base.type))
        {
            return createErrorExp(context, indexExp.loc);
        }

        var overloadContext : OverloadResolveContext;
        overloadContext.checkContext = context;
        overloadContext.appExp = indexExp;
        overloadContext.baseExp = base;

        let baseType = base.type;
        if(let baseDeclRefType = as<DeclRefType>(baseType))
        {
            let baseDeclRef = baseDeclRefType.declRef;
            let aggTypeDeclRef = as<AggTypeDecl>(baseDeclRef);
            if(aggTypeDeclRef.decl)
            {
                // now scan through the type's members looking for a subscript

                foreach(memberDeclRef in getDecls(aggTypeDeclRef))
                {
                	let memberSubscriptDeclRef = as<SubscriptDecl>(memberDeclRef);
                    if(memberSubscriptDeclRef.decl)
                    {
                        addSubscriptOverloadCandidate(&overloadContext, memberSubscriptDeclRef);
                    }

                }
            }
        }

        return completeOverload(&overloadContext);
    }
	else if(let postfixExp = as<PostfixExp>(exp))
	{
		let uncheckedBase = postfixExp.base;
		checkAppExpArgs(context, postfixExp);

		if(let argTypeExpr = tryCoerceToTypeExpr(context, postfixExp.args[0].exp))
		{
			let argType = as<TypeType>(argTypeExpr.type).type;

			// Okay, we have a reference to a type, so lets see if
			// the operator is postfix `*`.
			if(let baseNameExp = as<NameExp>(uncheckedBase))
			{
				if(getText(baseNameExp.name) == TerminatedStringSpan("*"))
				{
					let ptrType = getPtrType(context, exp.loc, argType);
					let ptrTypeExpr = createObject<PtrTypeExpr>();
					ptrTypeExpr.base = argTypeExpr;
					ptrTypeExpr.type = createTypeType(context, ptrType);
					return ptrTypeExpr;
				}
			}
		}

		return checkAppExpWithCheckedArgs(context, postfixExp);
	}
    else if(let appExp = as<AppExp>(exp))
    {
		return checkAppExp(context, appExp);
    }
	else if(let subscriptExpr = as<IndexExp>(exp))
	{
		diagnose(getSink(context), exp.loc, kDiagnostic_unimplemented, exp.directClass.name);
		return makeErrorExpr(context, exp);
	}
	else if(let genericAppExpr = as<GenericAppExp>(exp))
	{
        let base = checkTerm(context, genericAppExpr.base);
        genericAppExpr.base = base;
        foreach(arg in genericAppExpr.args)
        {
            arg.exp = checkTerm(context, arg.exp);
        }

        // If the base expression or any argument is in error,
        // en don't bother trying to resolve things
        if(isError(context, base))
        {
            return createErrorExp(context, exp);
        }

        var overloadContext : OverloadResolveContext;
        overloadContext.checkContext = context;
        overloadContext.appExp = genericAppExpr;
        overloadContext.baseExp = null;

        if(let baseMemberRef = as<MemberExp>(base))
        {
            overloadContext.baseExp = baseMemberRef.base;
        }

        addGenericAppOverloadCandidates(
            &overloadContext,
            base);

        return completeOverload(&overloadContext);
	}
	else if(let thisExpr = as<ThisExpr>(exp))
	{
		var scope = thisExpr.scope;
		while(scope)
		{
			let containerDecl = scope.directLink.container;
			let aggTypeDecl = as<AggTypeDecl>(containerDecl);
			if(aggTypeDecl)
			{
				thisExpr.type = createDeclRefType(
					DeclRefVal(aggTypeDecl));
				return thisExpr;
			}

			scope = scope.parent;
		}

		// TODO: need to fill in the type!

		diagnose(getSink(context), exp.loc, kDiagnostic_unimplemented, "this expression type");

		return createErrorExp(context, exp);
	}
	else if(let castExpr = as<CastExpr>(exp))
	{
		checkTypeExp(context, &castExpr.toType);
		castExpr.arg = checkTerm(context, castExpr.arg);

		// TODO: should validate the cast

		castExpr.type = castExpr.toType.type;
		return castExpr;
	}
	else if(let parenExpr = as<ParenExp>(exp))
	{
		let base = checkTerm(context, parenExpr.base);
		parenExpr.base = base;
		parenExpr.type = base.type;
		return parenExpr;
	}
	else if(let nullLitExpr = as<NullLitExpr>(exp))
	{
		nullLitExpr.type = getBuiltinType(context, nullLitExpr.loc, "Null");
		return nullLitExpr;
	}
	else
	{
		diagnose(getSink(context), exp.loc, kDiagnostic_unimplemented, exp.directClass.name);
		cogAssert(!"unimplemented");
		return 0;
	}
}

func checkAppExp(
	context: CheckContext*,
	appExp: AppExp)
	-> Exp
{
	checkAppExpArgs(context, appExp);
	return checkAppExpWithCheckedArgs(context, appExp);
}

func checkAppExpArgs(
	context: CheckContext*,
	appExp: AppExp)
{
    let base = checkTerm(context, appExp.base);
    appExp.base = base;
    foreach(arg in appExp.args)
    {
        arg.exp = checkTerm(context, arg.exp);
    }
}

func checkAppExpWithCheckedArgs(
	context: CheckContext*,
	appExp: AppExp)
	-> Exp
{
    // If the base expression or any argument is in error,
    // then don't bother trying to resolve things
	let base = appExp.base;
    if(isError(context, base))
    {
        return createErrorExp(context, appExp);
    }
	foreach(arg in appExp.args)
	{
		if(isError(context, arg.exp))
		{
			return createErrorExp(context, appExp);
		}
	}

    var overloadContext : OverloadResolveContext;
    overloadContext.checkContext = context;
    overloadContext.appExp = appExp;
    overloadContext.baseExp = null;


    if(let baseMemberRef = as<MemberExp>(base))
    {
        overloadContext.baseExp = baseMemberRef.base;
    }

    addAppOverloadCandidates(
        &overloadContext,
        base);

    return completeOverload(&overloadContext);
}

//

func extractVal(
	exp: Exp)
    -> Val
{
    if(let typeType = as<TypeType>(exp.type))
    {
        return typeType.type;
    }
    else
    {
        cogAssert(!"unimplemented");
        return null;
    }
}

//

func lookUpMemberInType(
	context:	CheckContext*,
	exp:		MemberExp,
	base:		Exp,
	baseType:	Type,
	memberName:	Name*)
	-> Exp
{
    if(let baseDeclRefType = as<DeclRefType>(baseType))
    {
        let baseDeclRef = baseDeclRefType.declRef;
        let aggTypeDeclRef = as<AggTypeDecl>(baseDeclRef);
        if(aggTypeDeclRef.decl)
        {
            // look up in the scope of that decl...

            // TODO: inheritance and all that...

            let lookupResult = lookupDirect(
                aggTypeDeclRef.getDecl(),
                memberName);

            if(lookupResult.isUnique())
            {
                return createDeclRefExp(
                    context,
                    CompactDeclRef(lookupResult.getDecl()),
                    exp.loc,
                    base);
            }
            else if(lookupResult.isOverloaded())
            {
                let overloadedExpr = createObject<OverloadedExpr>();
                overloadedExpr.loc = exp.loc;
                overloadedExpr.lookupResult = lookupResult;
                overloadedExpr.type =  createObject<OverloadGroupType>();
                overloadedExpr.base = base;
                return overloadedExpr;
            }
        }
		else
		{
			let genericParamDeclRef = as<GenericParamDecl>(baseDeclRef);
			if(genericParamDeclRef.decl)
			{
				// we have a generic type param, so we really need to base things on
				// the *bound* for the type parameter
				//
				let genericParamBoundType = getBoundType(genericParamDeclRef);
				return lookUpMemberInType(
					context,
					exp,
					base,
					genericParamBoundType,
					memberName);			
			}
		}
    }

	return null;
}

func checkMemberExp(
	context: CheckContext*,
	exp: MemberExp)
    -> Exp
{
    var base = exp.base;
    base = checkTerm(context, base);

    let memberName = exp.memberName;

    // If there was an error in the base expression,
    // en just return an error so we don't cascade
    if(isError(context, base))
    {
        return createErrorExp(context, exp);
    }

    let baseType = base.type;

	if(let result = lookUpMemberInType(context, exp, base, baseType, memberName))
	{
		return result;
	}

    diagnose(getSink(context), exp.loc, kDiagnostic_noMemberOfNameInType, memberName, baseType);
    return createErrorExp(context, exp);
}

//

func addAppOverloadCandidates(
	context: OverloadResolveContext*,
	baseExp: Exp)
{
//    fprintf(stderr, "<<<\n");
    if(let typeType = as<TypeType>(baseExp.type))
    {
//        fprintf(stderr, "AAA \n");
//        formatType(stderr, typeType.type);
        addTypeOverloadCandidates(context, baseExp, typeType.type);
    }
    else if(let declRefExp = as<DeclRefExp>(baseExp))
    {
//        fprintf(stderr, "BBB\n");
        // We have a declaration, and we are trying to call it
        addDeclRefOverloadCandidates(context, DeclRefVal(declRefExp.declRef));
    }
    else if(let overloadedExpr = as<OverloadedExpr>(baseExp))
    {
        cogAssert(!context.baseExp);
        context.baseExp = overloadedExpr.base;

//        fprintf(stderr, "CCC\n");
        cogAssert(overloadedExpr.lookupResult.items.getCount() != 0);
        foreach(item in overloadedExpr.lookupResult)
        {
//            fprintf(stderr, "item: %s\n", getText(item.decl->name).begin);
            addDeclRefOverloadCandidates(
                context,
                DeclRefVal(item.decl));
        }
    }
    else
    {
//        diagnose(getSink(context->checkContext), baseExp->loc, kDiagnostic_unimplemented, "can't apply this!");
    }
//    fprintf(stderr, ">>>\n");
}

//

func addGenericGenericOverloadCandidate(
    context: OverloadResolveContext*,
	genericDeclRef: DeclRefValImpl<GenericDecl>)
{
//	ensureDecl(context.checkContext, genericDeclRef.getDecl());

    var candidate: OverloadCandidate;
    candidate.declRef = genericDeclRef;
    candidate.resultType = null;

    addOverloadCandidate(context, candidate);
}

func addDeclRefGenericOverloadCandidates(
    context: OverloadResolveContext*,
    val: DeclRefVal)
{
	let genericDeclRef = as<GenericDecl>(val);
    if(genericDeclRef.decl)
    {
        addGenericGenericOverloadCandidate(context, genericDeclRef);
    }
    else
    {
//        diagnose(getSink(context->checkContext), val.getDecl()->loc, kDiagnostic_unimplemented, "can't apply this!");
    }
}


func addGenericAppOverloadCandidates(
	context: OverloadResolveContext*,
	baseExp: Exp)
{
	if(let declRefExp = as<DeclRefExp>(baseExp))
    {
        addDeclRefGenericOverloadCandidates(context, declRefExp.declRef);
    }
    else if(let overloadedExpr = as<OverloadedExpr>(baseExp))
    {
        cogAssert(!context.baseExp);
        context.baseExp = overloadedExpr.base;

        cogAssert(overloadedExpr.lookupResult.items.getCount() != 0);
        foreach(item in overloadedExpr.lookupResult)
        {
            addDeclRefGenericOverloadCandidates(
                context,
                DeclRefVal(item.decl));
        }
    }
    else
    {
//        diagnose(getSink(context->checkContext), baseExp->loc, kDiagnostic_unimplemented, "can't apply this!");
    }
}



func createFuncType(
	context: CheckContext*,
	funcDeclRef: DeclRefValImpl<FuncDeclBase>)
    -> Type
{
    let funcType = createObject<FuncType>();
    return funcType;
}

//

func getSyntaxClassForDeclRef(
	declRef: DeclRefVal)
	-> Class*
{
	let decl = declRef.getDecl();

	if(let declRefClassAttr = decl.findAttr<DeclRefClassAttr>())
	{
		if(let declRefSyntaxClass = declRefClassAttr.syntaxClass)
		{
			return declRefSyntaxClass;
		}
	}

	if(let classDecl = as<ClassDecl>(decl))
	{
		return getClass<ClassType>();
	}

	return getClass<DeclRefType>();
}

func createDeclRefType(
	declRef: DeclRefVal)
	-> Type
{
	let syntaxClass = getSyntaxClassForDeclRef(declRef);
	let type = cast<DeclRefType>(createObject(syntaxClass));
	type.declRef = CompactDeclRef(declRef);
	return type;
}

func createDeclRefTypeType(
	context: CheckContext*,
	declRef: DeclRefVal)
	-> Type
{
	let type = createDeclRefType(declRef);
	let typeType = createTypeType(context, type);
	return typeType;
}

func createTypeType(
	context: CheckContext*,
	type: Type)
	-> TypeType
{
	let typeType = createObject<TypeType>();
	typeType.type = type;
	return typeType;
}

func specializeTypeForDeclRef(
	context: 	CheckContext*,
	type:		Type,
	declRef:	DeclRefVal)
	-> Type
{
	return specializeType(
		type,
		declRef.specializations);
}

//

func getTypeForDeclRefImpl(
	context: CheckContext*,
	declRef: DeclRefVal)
	-> Type
{
    let decl = declRef.getDecl();

//    ensureDecl(context, decl, kDeclCheckState_CheckedHead);

    if(let varDecl = as<VarDeclBase>(decl))
	{
		// TODO: need to force decl here?
		return specializeTypeForDeclRef(context, varDecl.type.type, declRef);
	}
	else if(let aggTypeDecl = as<AggTypeDecl>(decl))
	{
        return createDeclRefTypeType(context, declRef);
	}
    else if(let typeVarDecl = as<TypeVarDecl>(decl))
    {
        return createDeclRefTypeType(context, declRef);
    }
    else if(let genericDecl = as<GenericDecl>(decl))
    {
        return createDeclRefTypeType(context, declRef);
    }

    let funcDeclRef = as<FuncDeclBase>(declRef);
    if(funcDeclRef.decl)
    {
        return createFuncType(context, funcDeclRef);
    }
	else
	{
		cogAssert(!"unimplemented");
        return 0;
	}
}

func getTypeForDeclRef(
	context: CheckContext*,
	declRef: DeclRefVal)
	-> Type
{
    let result = getTypeForDeclRefImpl(context, declRef);
//    fprintf(stderr, "getTypeForDeclRef(%s) = ",
//        getText(declRef.decl.name).begin);
//    printType(stderr, result);
//    fprintf(stderr, "\n");
    return result;
}

func getTypeForDeclRef(
	context: CheckContext*,
	declRef: CompactDeclRef)
	-> Type
{
	return getTypeForDeclRef(
		context,
		DeclRefVal(declRef));
}

func createErrorType(
	context: CheckContext*)
	-> Type
{
    return createObject<ErrorType>();
}

func getPtrType(
	context: CheckContext*,
	loc: SourceLoc,
	valueType: Type)
	-> Type
{
	if(let ptrTypeDecl = getBuiltinDecl(context, loc, "Ptr"))
	{
		if(let ptrGeneric = as<GenericDecl>(ptrTypeDecl))
		{
			var specArg = createObject<SpecializationArg>();
			specArg.param = ptrGeneric.getDecls()[0];
			specArg.value = valueType;

			var spec = createObject<Specializations>();
			spec.genericDeclRef = DeclRefValImpl<GenericDecl>(ptrGeneric, null);
			spec.args.append(specArg);

			let declRef = DeclRefVal(ptrGeneric.inner, spec);
			return createDeclRefType(declRef);
		}
	}
	return createErrorType(context);
}

func getBuiltinDecl(
	context: CheckContext*,
	loc: SourceLoc,
	name: ConstPtr<Char>)
    -> Decl
{
    let cogModuleName = getName(context.shared.session, "cog");
    var cogModule : ModuleDecl = null;
    if(context.shared.session.moduleDecl.name == cogModuleName)
    {
        cogModule = context.shared.session.moduleDecl;
    }
    else
    {
        cogModule = findOrImportModule(context.shared.session, loc, cogModuleName);        
    }

    let nameSpan = TerminatedStringSpan(name);
    foreach(decl in cogModule.getDecls())
    {
        if(decl.name && getText(decl.name) == nameSpan)
        {
			return decl;
        }
    }

    diagnose(getSink(context), loc, kDiagnostic_failedToFindBuiltinType, name);
	return null;
}

func getBuiltinType(
	context: CheckContext*,
	loc: SourceLoc,
	name: ConstPtr<Char>)
    -> Type
{
	if(let decl = getBuiltinDecl(context, loc, name))
	{
		return createDeclRefType(DeclRefVal(decl));
	}
    return createErrorType(context);
}

func getResultType(
	context: CheckContext*,
	decl: DeclRefValImpl<PatternDecl>)
	-> Type
{
    // TODO(tfoley): this should be simplified to
    // just use the `FuncDeclBaseRef`
    let funcDeclRef = as<FuncDecl>(decl);
	if(funcDeclRef.decl)
	{
		return getResultType(funcDeclRef);
	}


	let subscriptDeclRef = as<SubscriptDecl>(decl);
    if(subscriptDeclRef.decl)
    {
        return getResultType(subscriptDeclRef);
    }

    let typeDeclRef = as<AggTypeDecl>(decl);
    if(typeDeclRef.decl)
    {
        return createDeclRefType(
            CompactDeclRef(typeDeclRef));
    }
	else
	{
		// TODO: need to return the `Void` type...
        diagnose(getSink(context), decl.decl.loc, kDiagnostic_unimplemented, "result type");
		return 0;
	}
}

func createErrorExp(
	context: CheckContext*,
	exp: Exp)
    -> Exp
{
    exp.type = createErrorType(context);
    return exp;
}

func createErrorExp(
	context: CheckContext*,
	loc: SourceLoc)
    -> Exp
{
    let exp = createObject<ErrorExp>();
    exp.loc = loc;
    return createErrorExp(context, exp);
}

func isSameVal(
	left: Val,
	right: Val)
    -> Bool
{
    if(let leftType = as<Type>(left))
    {
        if(let rightType = as<Type>(right))
        {
            return isSameType(leftType, rightType);

        }
    }

    //

    cogAssert(!"unimplemented");
    return false;
}

func isSameSpecializations(
	left: Specializations,
    right: Specializations)
    -> Bool
{
    // Null specializations are equal.
    if(!left || !right)
        return left == right;

    if(!isSameDeclRef(
        left.genericDeclRef,
        right.genericDeclRef))
    {
        return false;
    }

    var leftCursor = left.args.begin();
    var rightCursor = right.args.begin();

    while(leftCursor != left.args.end())
    {
        let leftArg = *leftCursor;
        let rightArg = *rightCursor;

        if(!isSameVal(
            leftArg.value,
            rightArg.value))
        {
            return false;
        }


        ++leftCursor;
        ++rightCursor;
    }

    return true;
}


func isSameDeclRef(
	left: ConstRef<DeclRefVal>,
	right: ConstRef<DeclRefVal>)
    -> Bool
{
    if(left.decl != right.decl)
        return false;

    return isSameSpecializations(
        left.specializations,
        right.specializations);
}

func isSameType(
	left: Type,
	right: Type)
    -> Bool
{
    if(left.directClass != right.directClass)
        return false;

    if(let leftDeclRefType = as<DeclRefType>(left))
    {
        if(let rightDeclRefType = as<DeclRefType>(right))
        {
            // check that they reference the same thing!
            if(isSameDeclRef(
                leftDeclRefType.declRef,
                rightDeclRefType.declRef))
            {
                return true;
            }
        }
    }

    return false;
}

func createCastExpr(
	toType:		Type,
	fromExp:	Exp)
	-> Exp
{
	let castExpr = createObject<CastExpr>();
	castExpr.loc = fromExp.loc;
	castExpr.toType.type = toType;
	castExpr.type = toType;
	castExpr.arg = fromExp;
	return castExpr;
}

func tryCoerceImpl(
	context: 	CheckContext*,
    fromExp: 	Exp,
    fromType: 	Type,
    toExp: 		Exp*,
    toType:		Type)
    -> Bool
{
    if(isSameType(fromType, toType))
    {
        if(toExp)
        {
            *toExp = fromExp;
        }

        return true;
    }

    if(isError(fromType) || isError(toType))
    {
        if(toExp)
        {
            *toExp = fromExp;
        }
        return true;
    }

	if(let fromNullType = as<NullType>(fromType))
	{
		if(let toClassType = as<ClassType>(toType))
		{
			if(toExp)
			{
				*toExp = createCastExpr(toType, fromExp);
			}
			return true;
		}
		if(let toPtrType = as<PtrType>(toType))
		{
			if(toExp)
			{
				*toExp = createCastExpr(toType, fromExp);
			}
			return true;
		}
	}

//    fprintf(stderr, "FAILED: tryCoerceImpl(from:");
//    formatType(stderr, fromType);
//    fprintf(stderr, ", to:");
//    formatType(stderr, toType);
//    fprintf(stderr, ")\n");

    return false;
}

func tryCoerceImpl(
	context: 	CheckContext*,
    fromExp: 	Exp,
    toExp: 		Exp*,
    toType:		Type)
    -> Bool
{
    if(let fromOverloadedExpr = as<OverloadedExpr>(fromExp))
    {
        // TODO: implement this case!

        cogAssert(!"unimplemented");
        return false;
    }
    else
    {
        return tryCoerceImpl(
            context,
            fromExp,
            fromExp.type,
            toExp,
            toType);
    }
}

func coerce(
	context: 	CheckContext*,
    exp: 		Exp,
    type: 		Type)
    -> Exp
{
    var result : Exp = null;
    if(tryCoerceImpl(
        context,
        exp,
        &result,
        type))
    {
        return result;
    }

    diagnose(getSink(context), exp.loc, kDiagnostic_cannotConvertType, type, exp.type);
    return createErrorExp(context, exp);
}

func canCoerce(
	context: 	CheckContext*,
    exp: 		Exp,
    type: 		Type)
    -> Bool
{
    return tryCoerceImpl(
        context,
        exp,
        null,
        type);
}

enum OverloadCandidateState
{
    kOverloadCandidateState_Unchecked,
    kOverloadCandidateState_GenericArgumentInferenceFailed,
    kOverloadCandidateState_CheckedArity,
    kOverloadCandidateState_CheckedTypes,
    kOverloadCandidateState_Applicable,
}


struct OverloadCandidate
{
	var state 		: OverloadCandidateState;
	var declRef 	: DeclRefVal;
	var resultType 	: Type;
}

enum OverloadResolveMode
{
    kOverloadResolveMode_justTrying,
    kOverloadResolveMode_forReal,
}

struct OverloadResolveContext
{
	var checkContext 	: CheckContext*;
    var appExp 			: AppExpBase;
    var baseExp 		: Exp = null;

    var mode : OverloadResolveMode = kOverloadResolveMode_justTrying;

    // candidates being considered
    var candidates : Array<OverloadCandidate>;
}

func issueTooFewArgsError(
	context: OverloadResolveContext*)
{
	if(context.mode == kOverloadResolveMode_justTrying)
	{}
	else
	{
		diagnose(getSink(context.checkContext), context.appExp.loc, kDiagnostic_tooFewArgs);
	}
}

func issueTooManyArgsError(
	context: OverloadResolveContext*)
{
	if(context.mode == kOverloadResolveMode_justTrying)
	{}
	else
	{
		diagnose(getSink(context.checkContext), context.appExp.loc, kDiagnostic_tooManyArgs);
	}
}

func checkOverloadCandidateArity(
	context: OverloadResolveContext*,
    candidate: Ref<OverloadCandidate>)
    -> Bool
{
    let args = &context.appExp.args;
    let argCursor = args.begin();
    let argEnd = args.end();

    let funcDeclRef = as<FuncDeclBase>(candidate.declRef);
    if(funcDeclRef.decl)
    {
        foreach(dd in getDecls(funcDeclRef))
        {
        	let paramDeclRef = as<ParamDecl>(dd);
            if(paramDeclRef.decl)
            {
                if(!(argCursor != argEnd))
                {
                    // not enough args!
					issueTooFewArgsError(context);
                    return false;
                }

                ++argCursor;
            }
            else
            {}
        }

        if(argCursor != argEnd)
        {
            // too many args!
			issueTooManyArgsError(context);
            return false;
        }

        return true;
    }

    let genericDeclRef = as<GenericDecl>(candidate.declRef);
	if(genericDeclRef.decl)
	{
		foreach(dd in getDecls(genericDeclRef))
		{
			let genericParamDeclRef = as<GenericParamDecl>(dd);
			if(genericParamDeclRef.decl)
			{
				if(!(argCursor != argEnd))
				{
					// not enough arg!
					issueTooFewArgsError(context);
					return false;
				}

				++argCursor;
			}
			else
			{}
		}

        if(argCursor != argEnd)
        {
            // too many args!
			issueTooManyArgsError(context);
            return false;
        }

        return true;
	}
    else
    {
        // TODO: other cases here?
        return false;
    }
}

func checkOverloadCandidateTypes(
	context: OverloadResolveContext*,
    candidate: Ref<OverloadCandidate>)
    -> Bool
{
    let args = &context.appExp.args;
    let argCursor = args.begin();
    let argEnd = args.end();

    let funcDeclRef = as<FuncDeclBase>(candidate.declRef);
    if(funcDeclRef.decl)
    {
        foreach(dd in getDecls(funcDeclRef))
        {
        	let paramDeclRef = as<ParamDecl>(dd);
            if(paramDeclRef.decl)
            {
                if(!(argCursor != argEnd))
                {
                    cogAssert(false);
                    // not enough args!
                    return false;
                }

                let arg = *argCursor;
                let argExpr = &arg.exp;

                let paramType = getType(paramDeclRef);

                if(context.mode == kOverloadResolveMode_justTrying)
                {
                    if(!canCoerce(
                        context.checkContext,
                        *argExpr,
                        paramType))
                    {
                        return false;
                    }
                }
                else
                {
                    *argExpr = coerce(
                        context.checkContext,
                        *argExpr,
                        paramType);
                }

                ++argCursor;
            }
            else
            {}
        }

        if(argCursor != argEnd)
        {
            cogAssert(false);
            // too many args!
            return false;
        }

        return true;
    }

    let genericDeclRef = as<GenericDecl>(candidate.declRef);
	if(genericDeclRef.decl)
	{
        foreach(dd in getDecls(genericDeclRef))
        {
        	let paramDeclRef = as<GenericParamDecl>(dd);
            if(paramDeclRef.decl)
            {
                if(!(argCursor != argEnd))
                {
                    cogAssert(false);
                    // not enough args!
                    return false;
                }

                let arg = *argCursor;
                let argExpr = &arg.exp;

                if(context.mode == kOverloadResolveMode_justTrying)
                {
					if(let type = tryCoerceToType(context.checkContext, *argExpr))
					{}
					else
					{
						return false;
					}
                }
                else
                {
					*argExpr = coerceToTypeExpr(context.checkContext, *argExpr);
                }

                ++argCursor;
            }
            else
            {}
        }

        if(argCursor != argEnd)
        {
            cogAssert(false);
            // too many args!
            return false;
        }

        return true;

	}
    else
    {
        // TODO: other cases here?
        return false;
    }
}

func checkOverloadCandidateDirections(
    context: OverloadResolveContext*,
    candidate: Ref<OverloadCandidate>)
    -> Bool
{
    return true;
}

func checkOverloadCandidateImpl(
    context: OverloadResolveContext*,
    candidate: Ref<OverloadCandidate>)
{
    // check arity
    candidate.state = kOverloadCandidateState_Unchecked;
    if(!checkOverloadCandidateArity(context, candidate))
        return;
    candidate.state = kOverloadCandidateState_CheckedArity;
    if(!checkOverloadCandidateTypes(context, candidate))
        return;
    candidate.state = kOverloadCandidateState_CheckedTypes;
    if(!checkOverloadCandidateDirections(context, candidate))
        return;
    candidate.state = kOverloadCandidateState_Applicable;

    // consider other costs...
}

func checkOverloadCandidate(
    context: OverloadResolveContext*,
    candidate: Ref<OverloadCandidate>)
{
    checkOverloadCandidateImpl(context, candidate);
//    fprintf(stderr, "CANDIDATE STATE: %d\n", (int) candidate.state);
}

func compareCandidates(
	left: Ref<OverloadCandidate>,
	right: Ref<OverloadCandidate>)
    -> Int
{
    // a higher state value is better (lower cost)
    if(left.state != right.state)
        return int(right.state) - int(left.state);

    // TODO: more detailed comparisons

    // otherwise they are un-ordered
    return 0;
}

func addCheckedOverloadCandidate(
    context: OverloadResolveContext*,
    candidate: Ref<OverloadCandidate>)
{
    // We now need to filter our set of candidates,
    // and eliminate those that are strictly
    // worse than this one (we also can check if
    // is one is strictly worse than any)

    var anyBetter : Bool = false;
    var anyWorse : Bool = false;

    // Note: check count inside loop because we are
    // modifying it on the fly
    for(var ii : UInt = 0; ii < context.candidates.getCount(); ++ii)
    {
        let compareResult = compareCandidates(
            candidate,
            context.candidates[ii]);

//        fprintf(stderr, "COMPARE: %d\n", compareResult);

        if(compareResult < 0)
        {
//            fprintf(stderr, "REMOVING OLD: %d\n", (int)ii);
            // new candidate is better/cheaper
            context.candidates.fastRemoveAt(ii);

            anyBetter = true;

            // retry the same index, because of removal...
            --ii;
        }
        else if(compareResult > 0)
        {
//            fprintf(stderr, "SKIPPING NEW: %d\n", (int)ii);
            // old candidate is beter/cheaper
            anyWorse = true;
        }
    }

    if(anyWorse)
    {
        cogAssert(!anyBetter);

        // our candidate was strictly worse
        // an at least one alternative,
        // so we should give up
        return;
    }

    // is candidate is worth looking at, it seems
    context.candidates.append(candidate);
}

func addOverloadCandidate(
    context: OverloadResolveContext*,
    candidate: Ref<OverloadCandidate>)
{
    checkOverloadCandidate(context, candidate);
    addCheckedOverloadCandidate(context, candidate);
}

func addSubscriptOverloadCandidate(
    context: OverloadResolveContext*,
    declRef: DeclRefValImpl<SubscriptDecl>)
{
    // TODO: actually do stuff!

//	ensureDecl(context.checkContext, declRef.getDecl());

    var candidate: OverloadCandidate;
    candidate.declRef = declRef;
    candidate.resultType = getResultType(context.checkContext, declRef);

    addOverloadCandidate(context, candidate);
}

func addFuncOverloadCandidate(
    context: OverloadResolveContext*,
    declRef: DeclRefValImpl<FuncDeclBase>)
{
//	ensureDecl(context.checkContext, declRef.getDecl());

    var candidate: OverloadCandidate;
    candidate.declRef = declRef;
    candidate.resultType = getResultType(context.checkContext, declRef);

    addOverloadCandidate(context, candidate);
}

func addInitializerOverloadCandidate(
    context: 	OverloadResolveContext*,
    type: 		Type,
    declRef: 	DeclRefValImpl<InitializerDecl>)
{
    var candidate: OverloadCandidate;
    candidate.declRef = declRef;
    candidate.resultType = type;
    addOverloadCandidate(context, candidate);
}

func createDeclRefExp(
	context: CheckContext*,
	declRef: CompactDeclRef,
	loc: SourceLoc,
	baseExp: Exp)
    -> Exp
{
    var declRefExp: DeclRefExp = null;
    if(baseExp)
    {
        let memberRefExp = createObject<MemberExp>();
        memberRefExp.base = baseExp;
        declRefExp = memberRefExp;
    }
    else
    {
        declRefExp = createObject<DeclRefExp>();
    }

    declRefExp.loc = loc;
    declRefExp.declRef = declRef;
    declRefExp.type = getTypeForDeclRef(context, declRef);
    return declRefExp;
}

func createDeclRefExp(
	context: CheckContext*,
	declRef: DeclRefVal,
	loc: SourceLoc,
	baseExp: Exp)
    -> Exp
{

    let decl = declRef.getDecl();
    if(let specializations = declRef.getSpecializations())
    {
        let specializedDecl = createObject<SpecializedDecl>();
        specializedDecl.decl = decl;
        specializedDecl.specializations = specializations;

        return createDeclRefExp(context, CompactDeclRef(specializedDecl), loc, baseExp);
    }
    else
    {
        return createDeclRefExp(context, CompactDeclRef(decl), loc, baseExp);
    }
}

// TODO(tfoley): support default arguments
func createDeclRefExp(
	context: CheckContext*,
	declRef: DeclRefVal,
	loc: SourceLoc)
    -> Exp
{
	return createDeclRefExp(context, declRef, loc, null);
}

func getGenericArgVal(
	context: CheckContext*,
	expr:	Exp)
	-> Val
{
	let type = expr.type;
	if(let typeType = as<TypeType>(type))
	{
		return typeType.type;
	}
	if(let errorType = as<ErrorType>(type))
	{
		return errorType;
	}

	diagnose(getSink(context), expr.loc, kDiagnostic_unimplemented, "generic arg flavor");

	return createErrorType(context);
}

func completeOverloadCandidate(
	overloadContext: OverloadResolveContext*,
	candidate: OverloadCandidate*)
	-> Exp
{
    let context = overloadContext.checkContext;
    let appExp = overloadContext.appExp;
	let loc = appExp.loc;

	let funcDeclRef = as<FuncDeclBase>(candidate.declRef);
	if(funcDeclRef.decl)
	{
		let baseExp = createDeclRefExp(
			context,
			funcDeclRef,
			appExp.loc,
			overloadContext.baseExp);

		appExp.base = baseExp;
		appExp.type = candidate.resultType;
		return appExp;
	}

	let genericDeclRef = as<GenericDecl>(candidate.declRef);
	if(genericDeclRef.decl)
	{
		// We need to construct a representation of the inner declaration
		let innerDecl = genericDeclRef.getDecl().inner;
		let specializations = createObject<Specializations>();
		specializations.genericDeclRef = genericDeclRef;

		var argCursor = appExp.args.begin();

		foreach(dd in getDecls(genericDeclRef))
		{
			let paramDeclRef = as<GenericParamDecl>(dd);
			if(paramDeclRef.decl)
			{
				let arg = *argCursor;
				++argCursor;

				let specializationArg = createObject<SpecializationArg>();
				specializationArg.param = paramDeclRef.getDecl();
				specializationArg.value = getGenericArgVal(context, arg.exp);

				specializations.args.append(specializationArg);
			}
		}

		let innerDeclRef = DeclRefVal(innerDecl, specializations);
		return createDeclRefExp(
			context,
			innerDeclRef,
			appExp.loc,
			overloadContext.baseExp);
	}
	else
	{
		diagnose(getSink(context), loc, kDiagnostic_unimplemented, "overload candidate flavor");
		return null;
	}
}

func completeOverload(
    overloadContext: OverloadResolveContext*)
    -> Exp
{
    let context = overloadContext.checkContext;
    let appExp = overloadContext.appExp;

    let count = overloadContext.candidates.getCount();

    var baseName : Name* = null;
    if(let declRefExp = as<DeclRefExp>(appExp.base))
    {
        baseName = declRefExp.declRef.getDecl().name;
    }
    else if(let nameExp = as<NameExp>(appExp.base))
    {
        baseName = nameExp.name;
    }
    else if(let overloadedExpr = as<OverloadedExpr>(appExp.base))
    {
        baseName = overloadedExpr.lookupResult.items[0].decl.name;
    }

    if(count == 1)
    {
        // exactly one best candidate found

        let candidate = &overloadContext.candidates[0];
        if(candidate.state == kOverloadCandidateState_Applicable)
        {
			return completeOverloadCandidate(overloadContext, candidate);
        }
        else
        {
            // TODO: re-check to get good errors

            overloadContext.mode = kOverloadResolveMode_forReal;
            checkOverloadCandidate(
                overloadContext,
                *candidate);
            return createErrorExp(context, appExp.loc);
        }
    }
    else if(count == 0)
    {
        // no candidates were considered!
        diagnose(getSink(context), appExp.loc, kDiagnostic_noOverloadCandidatesFound, baseName);

        if(let overloadedExpr = as<OverloadedExpr>(appExp.base))
        {
            foreach( item in overloadedExpr.lookupResult)
            {
                diagnose(getSink(context), item.decl.loc, kDiagnostic_candidate, DeclRefVal(item.decl));                
            }
        }

        return createErrorExp(context, appExp.loc);
    }
    else
    {
        // must have been multiple candidates
        if(overloadContext.candidates[0].state == kOverloadCandidateState_Applicable)
        {
            // ey were applicable, so this is ambiguous!
            diagnose(getSink(context), appExp.loc, kDiagnostic_ambiguousCallToOverload, baseName, ArgTypeList(appExp.args));

            foreach( cc in overloadContext.candidates)
            {
                diagnose(getSink(context), cc.declRef.getDecl().loc, kDiagnostic_candidate, cc.declRef);
            }

            return createErrorExp(context, appExp.loc);
        }
        else
        {
            // ey were applicable, so this is ambiguous!
            diagnose(getSink(context), appExp.loc, kDiagnostic_noApplicableOverloadForCall, baseName, ArgTypeList(appExp.args));

            foreach(cc in overloadContext.candidates)
            {
                diagnose(getSink(context), cc.declRef.getDecl().loc, kDiagnostic_candidate, cc.declRef);
            }

            return createErrorExp(context, appExp.loc);
        }
    }
}

func isError(
	type: Type)
    -> Bool
{
    return as<ErrorType>(type) != null;
}

func isError(
	context: CheckContext*,
	exp: Exp)
    -> Bool
{
    return as<ErrorExp>(exp) || isError(exp.type);
}

func addTypeOverloadCandidates(
	context: OverloadResolveContext*,
	typeExp: Exp,
	type: Type)
{
    if(let declRefType = as<DeclRefType>(type))
    {
    	let aggTypeDeclRef = as<AggTypeDecl>(declRefType.declRef);
        if(aggTypeDeclRef.decl)
        {
            // Need to look for constructors

            foreach( memberDeclRef in getDecls(aggTypeDeclRef))
            {
            	let initializerDeclRef = as<InitializerDecl>(memberDeclRef);
                if(initializerDeclRef.decl)
                {
                    addInitializerOverloadCandidate(context, type, initializerDeclRef);
                }
            }
        }
    }

}

struct GenericInferenceArg
{
	var paramDeclRef: DeclRefValImpl<GenericParamDecl>;
	var val: Val = null;
}

struct GenericInferenceContext
{
	var checkContext: CheckContext*;
	var args: GenericInferenceArg*;
	var argCount: Int;
}

func doInferenceForVals(
	context: GenericInferenceContext*,
	argVal: Val,
	paramVal: Val)
    -> Bool
{
    if(let argType = as<Type>(argVal))
    {
        if(let paramType = as<Type>(paramVal))
        {
            return doInferenceForTypes(context, argType, paramType);
        }
    }

    // no other types of values right now...
    return false;
}

func doInferenceForSpecializations(
	context: GenericInferenceContext*,
    argSpec: Specializations,
    paramSpec: Specializations)
    -> Bool
{
	// Empty specializations only match empty ones
    if(!argSpec || !paramSpec)
    {
    	return argSpec == paramSpec;
    }

    // Make sure we can align the generic being referened
    if(!doInferenceForDeclRefs(
        context,
        argSpec.genericDeclRef,
        paramSpec.genericDeclRef))
    {
        return false;
    }

    // Now walk through the arguments and try to unify
    var aa = argSpec.args.begin();
	var ae = argSpec.args.end();

    var pp = paramSpec.args.begin();
    while(aa != ae)
    {
        if(!doInferenceForVals(context, (*aa).value, (*pp).value))
            return false;

		++aa;
		++pp;
    }

    return true;
}

func doInferenceForDeclRefs(
	context: 		GenericInferenceContext*,
    argDeclRef:		DeclRefVal,
    paramDeclRef: 	DeclRefVal)
    -> Bool
{
    // TODO: need to handle possible inheritance here!
    if(paramDeclRef.getDecl()
        != argDeclRef.getDecl())
    {
        return false;
    }

    // Okay, they name the same type, so we need
    // to go ahead and recurse on their specializations.
    return doInferenceForSpecializations(
        context,
        argDeclRef.specializations,
        paramDeclRef.specializations);    
}

func findGenericInferenceArg(
	context: GenericInferenceContext*,
	paramDeclRef: DeclRefValImpl<GenericParamDecl>)
	-> GenericInferenceArg*
{
	for(var ii : Int = 0; ii < context.argCount; ++ii)
	{
		if(isSameDeclRef(context.args[ii].paramDeclRef, paramDeclRef))
			return &context.args[ii];
	}
	return null;
}

func doInferenceForTypes(
    context: GenericInferenceContext*,
    argType: Type,
    paramType: Type)
    -> Bool
{
    //
    if(isSameType(argType, paramType))
        return true;

    if(let paramDeclRefType = as<DeclRefType>(paramType))
    {
    	let genericParamDeclRef = as<GenericParamDecl>(paramDeclRefType.declRef);
        if(genericParamDeclRef.decl)
        {
			// The type in parameter position is a generic parameter (we hope
			// that it is a generic parameter of the declaration we hope to specialize).
			// We should note this, so that the argument type will be used to
			// replace the parameter type.


			let genericInferenceArg = findGenericInferenceArg(context, genericParamDeclRef);
			if(genericInferenceArg)
			{
				// TODO: this isn't quite right...
				genericInferenceArg.val = argType;
				return true;
			}
        }

        // Is the argument type a reference to the same
        // type declaration (maybe with different parameters)?
        if(let argDeclRefType = as<DeclRefType>(argType))
        {
            return doInferenceForDeclRefs(
                context,
                argDeclRefType.declRef,
                paramDeclRefType.declRef);
        }
    }

    // no match!
    return false;
}


func doInferenceForArgAndParam(
    context: GenericInferenceContext*,
    argExpr: Exp,
    paramDeclRef: DeclRefValImpl<ParamDecl>)
    -> Bool
{
    return doInferenceForTypes(
        context,
        argExpr.type,
        getType(paramDeclRef));
}

func inferGenericArgsForApp(
    context: CheckContext*,
    genericDeclRef: DeclRefValImpl<GenericDecl>,
    appExpr: AppExpBase)
    -> Specializations
{
    // Need to find a suitable value to substitute
    // for each parameter of the given generic.
    //
    // We can do this by trying to "unify" the
    // argument and parameter types, and find
    // constraints that they place on each parameter

    let innerDeclRef = getInner(genericDeclRef);
    let innerFuncDeclRef = as<FuncDeclBase>(innerDeclRef);
    if(!innerFuncDeclRef.decl)
    {
        // TODO: consider generic types...
        return null;
    }


    var args: Array<GenericInferenceArg>;
    foreach( member in getDecls(genericDeclRef))
    {
    	let genericParamDeclRef = as<GenericParamDecl>(member);
        if(genericParamDeclRef.decl)
        {
            var arg: GenericInferenceArg;
            arg.paramDeclRef = genericParamDeclRef;

            args.append(arg);
        }
        else
        {
            // TODO: handle non-type parameters!
        }
    }

    var inferenceContext : GenericInferenceContext;
    inferenceContext.checkContext = context;
    inferenceContext.args = &args[0];
	inferenceContext.argCount = args.getCount();

    var aa = appExpr.args.begin();
    let ae = appExpr.args.end();
    foreach(member in getDecls(innerFuncDeclRef))
    {
        let paramDeclRef = as<ParamDecl>(member);
        if(!paramDeclRef.decl)
            continue;

        if(!(aa != ae))
        {
            // Too few args!
            return null;
        }

        let arg = *aa;
        ++aa;

        // We have an arg and param,
        // and need to match them up!
        if(!doInferenceForArgAndParam(
            &inferenceContext,
            arg.exp,
            paramDeclRef))
        {
            return null;
        }
    }
    if(aa != ae)
    {
        // Too few args!
        return null;
    }

    // Now let's see if the arguments can be inferred from what
    // we've seen!
    foreach(arg in args)
    {
        if(!arg.val)
            return null;
    }

	// Seems like we are good, so construct the specializations
	let spec = createObject<Specializations>();
	spec.genericDeclRef = genericDeclRef;

	foreach(arg in args)
	{
		let specArg = createObject<SpecializationArg>();
		specArg.param = arg.paramDeclRef.getDecl();
		specArg.value = arg.val;

		spec.args.append(specArg);
	}

	return spec;
}

func addGenericOverloadCandidate(
    context: OverloadResolveContext*,
    genericDeclRef: DeclRefValImpl<GenericDecl>)
{
//	ensureDecl(context.checkContext, genericDeclRef.getDecl());

    // Need to infer argument types and then apply
    // based on those.
    //
    // Long-term we probably want to infer using
    // something like a constraint solver, but
    // for right now lets just do the easy thing
    // and use a local inference step.

    let innerDeclRef = getInner(genericDeclRef);
    let specializations = inferGenericArgsForApp(
        context.checkContext,
        genericDeclRef,
        context.appExp);
    if(specializations)
    {
        innerDeclRef.specializations = specializations;
    }

    // TODO: probably need to add an asosciated cost
    // so that this overload is considered "worse"
    // an an explicit match...

    addDeclRefOverloadCandidates(context, innerDeclRef);
}

func addDeclRefOverloadCandidates(
    context: OverloadResolveContext*,
    val: DeclRefVal)
{
	let funcDeclRef = as<FuncDeclBase>(val);
    if(funcDeclRef.decl)
    {
        addFuncOverloadCandidate(context, funcDeclRef);
        return;
    }

    let genericDeclRef = as<GenericDecl>(val);
    if(genericDeclRef.decl)
    {
        addGenericOverloadCandidate(context, genericDeclRef);
    }
    else
    {
//        diagnose(getSink(context->checkContext), val.getDecl()->loc, kDiagnostic_unimplemented, "can't apply this!");
    }
}

//

func specializeVal(
	val: Val,
	specializations: Specializations)
	-> Val
{
	if(let type = as<Type>(val))
	{
		return specializeType(type, specializations);
	}

	cogAssert(!"unimplemented");
	return null;
}

func findSpecialization(
	specializations:	Specializations,
	decl:				Decl)
	-> Val
{
	foreach(arg in specializations.args)
	{
		if(decl == arg.param)
		{
			return arg.value;
		}
	}

	return null;
}

func specializeDeclRef(
	declRef: DeclRefVal,
	specializations: Specializations)
	-> DeclRefVal
{
	let oldDecl = declRef.getDecl();
	let oldSpecializations = declRef.getSpecializations();

	// Is the decl one we should specialize?
	if(let genericTypeParamDecl = as<GenericParamDecl>(oldDecl))
	{
		// Is it one being specialized?
		if(let newVal = findSpecialization(specializations, genericTypeParamDecl))
		{
			if(let typeDeclRef = as<DeclRefType>(newVal))
				return typeDeclRef.declRef;
		}

		cogAssert(!"unimplemented");
	}

	if(!oldSpecializations)
		return declRef;

	// otherwise we need to specialize the specializations themselves

	let newSpec = createObject<Specializations>();
	newSpec.genericDeclRef = as<GenericDecl>(specializeDeclRef(
		oldSpecializations.genericDeclRef,
		specializations));

	foreach(arg in oldSpecializations.args)
	{
		// TODO: need to substitute params too?

		let newSpecArg = createObject<SpecializationArg>();
		newSpecArg.param = arg.param;
		newSpecArg.value = specializeVal(arg.value, specializations);

		newSpec.args.append(newSpecArg);
	}

	return DeclRefVal(oldDecl, newSpec);
}

func specializeType(
	type: Type,
	specializations: Specializations)
	-> Type
{
	if(!specializations)
		return type;

	if(let declRefType = as<DeclRefType>(type))
	{
		// TODO: scavenge memory as needed
		let specDeclRef = specializeDeclRef(declRefType.declRef, specializations);

		return createDeclRefType(specDeclRef);
	}

	if(let errorType = as<ErrorType>(type))
		return errorType;

	cogAssert(!"unimplemented");
	return null;
}

//
