// syntax.cog

import cog;

struct TypeExp
{
	var exp : Exp = null;
	var type : Type = null;

	/*
	operator Exp*()
	{
		return exp;
	}
	*/
}

func asBool(typeExp: TypeExp) -> Bool
{
	return typeExp.exp;
}

struct SyntaxListIterator<T : Syntax>
{
	var current : T;

	init(
		current: T)
	{
		this.current = current;
	}

	func *() -> T
	{
		return current;
	}

	func ++()
	{
		current = cast<T>(current.next);
	}
}

func !=(
	left: SyntaxListIterator<T>,
	right: SyntaxListIterator<T>)
	-> Bool
{
	return left.current != right.current;
}

struct SyntaxList<T>
{
	var head: T;

	subscript(index: UInt) -> T
	{
        var item = head;
        for(var ii : UInt = UInt(0); ii < index; ++ii)
        {
            item = cast<T>(item.next);
        }
        return item;
    }

	func begin() -> SyntaxListIterator<T>
	{
		return SyntaxListIterator<T>(head);
	}

	func end() -> SyntaxListIterator<T>
	{
		return SyntaxListIterator<T>(0);
	}

	init()
	{
		this.head = 0;
	}

	init(head: T)
	{
		this.head = head;
	}
}

struct SyntaxListBuilder<T> : SyntaxList<T>
{
	var link : Ptr<T>;

	init()
	{
		this.link = &this.head;
	}

	init(other: SyntaxList<T>)
	{
		this.head = other.head;
		this.link = &this.head;

		adjust();
	}

	func adjust()
	{
		while (*link)
		{
			link = cast<Ptr<T> >(&(*link).next);
		}
	}

	func add(element: T)
	{
		adjust();

		*link = element;
		element.next = 0;
	}

	func append(other: SyntaxListBuilder<T>)
	{
		adjust();

		if(other.head)
		{
			*link = other.head;
			link = other.link;
		}
	}
}

struct FilteredSyntaxListIterator<T,U>
{
	var current : T;

	init(current: U)
	{
		this.current = adjust(current);
	}

	func !=(other: FilteredSyntaxListIterator<T,U>) -> Bool
	{
        return current != other.current;
	}

    func *() -> T { return current; }

	func ++()
    {
        current = adjust(current.next);
    }

	func adjust(obj: U) -> T
	{
		while(obj)
		{
			let t = as<T>(obj);
			if(t)
				return t;
			obj = obj.next;
		}
		return null;
	}

}


struct FilteredSyntaxList<T,U>
{
	var head : U;


	func begin() -> FilteredSyntaxListIterator<T,U>
	{
		return FilteredSyntaxListIterator<T,U>(head);
	}

	func end() -> FilteredSyntaxListIterator<T,U>
	{
		return FilteredSyntaxListIterator<T,U>(null);
	}

	init()
	{
		this.head = null;
	}

	init(head: U)
	{
		this.head = head;
	}

	init(list: ConstRef<SyntaxList<U> >)
	{
		this.head = list.head;
	}
}

class Syntax
{
	var loc : SourceLoc;
}

class Attr : Syntax
{
	var next : Attr;
}

class BuiltinAttr : Attr
{
	var name : Ptr<Name>;
}

class Stmt : Syntax
{
	var attrs : SyntaxList<Attr>;

	var next : Stmt;

	func findAttrImpl(attrClass: Ptr<Class>) -> Attr
	{
		foreach(a in attrs)
		{
			// TODO: support `if let`
			let match = as(a, attrClass);
			if(match)
				return cast<Attr>(match);
		}
		return null;
	}

	func findAttr<T>() -> T
	{
		return cast<T>(findAttrImpl(getClass<T>()));
	}
}

enum DeclCheckState
{
	kDeclCheckState_Unchecked = 0,
	kDeclCheckState_CheckingHead,
	kDeclCheckState_CheckedHead,
	kDeclCheckState_Checked,
}

class Decl : Stmt
{
	var name : Ptr<Name>;
	var parent : ContainerStmt;
	var checkState : DeclCheckState = kDeclCheckState_Unchecked;

	func getParent() -> ContainerStmt
	{
		return parent;
	}
}

class SpecializationArg : Object
{
	var next : SpecializationArg;

	var param : Decl;
	var value : Val;
}

class Specializations : Object
{
	var genericDeclRef : DeclRefValImpl<GenericDecl>;
	var args : SyntaxList<SpecializationArg>;
}


class SpecializedDecl : Object
{
	var decl : Decl;
	var specializations: Specializations;
}

// Values

// A value is a literal, and thus not syntax
// the intention is that values are hashed so
// that we can compare them with pointer equality
class Val : Object
{
}

class ContainerStmt : Decl
{
	var stmts : SyntaxList<Stmt>;

	func getStmts() -> SyntaxList<Stmt>
	{
		return stmts;
	}

	func getDecls() -> FilteredSyntaxList<Decl, Stmt>
	{
		return FilteredSyntaxList<Decl, Stmt>(stmts);
	}
}

class ContainerDecl : ContainerStmt
{
	// TODO: this used to be by-reference, and that is probably counted on somewhere

	func getDecls() -> Ref<SyntaxList<Decl> > { return *cast<Ptr<SyntaxList<Decl> > >(&stmts); }
}

struct DeclRefListIterator<T>
{
	var decl : Decl;
	var specializations : Specializations;

	init(decl: Decl, specializations: Specializations)
	{
		this.decl = decl;
		this.specializations = specializations;

		adjust();
	}

	func ++()
	{
		if(!decl)
			return;
		decl = cast<Decl>(decl.next);
		adjust();
	}

	func *() -> DeclRefValImpl<T>
	{
		return DeclRefValImpl<T>(
			cast<T>(decl),
			specializations);
	}

	func adjust()
	{
		while(decl)
		{
			let declAsT = as<T>(decl);
			if(declAsT)
				return;

			decl = cast<Decl>(decl.next);
		}
	}
}

struct DeclRefList<T>
{
	var decl : Decl;
	var specializations : Specializations;

	func begin() -> DeclRefListIterator<T>
	{
		return DeclRefListIterator<T>(decl, specializations);
	}

	func end() -> DeclRefListIterator<T>
	{
		return DeclRefListIterator<T>(null, null);
	}

	init()
	{
		this.decl = null;
		this.specializations = null;
	}

	init(decl: Decl, specializations: Specializations)
	{
		this.decl = decl;
		this.specializations = specializations;
	}
}

func != <T>(
	left: DeclRefListIterator<T>,
	right: DeclRefListIterator<T>) -> Bool
{
	return left.decl != right.decl;
}

func getDecls(container: DeclRefValImpl<ContainerDecl>)
	-> DeclRefList<Decl>
{
	return DeclRefList<Decl>(
		container.getDecl().getDecls().head,
		container.specializations);
}

class GenericDecl : ContainerDecl
{
	var inner : Decl;
}

func getInner(declRef: DeclRefValImpl<GenericDecl>)
	-> DeclRefVal
{
	return DeclRefVal(
		declRef.getDecl().inner,
		declRef.specializations);
}

class TypeVarDecl : Decl
{
	var bound : TypeExp;
	var init : TypeExp;
}

class ImportDecl : Decl
{
	// The scope to extend
	var scope : Ptr<Scope>;

	var name : Ptr<Name>;
}

class GenericParamDecl : TypeVarDecl
{
}

class TypeAliasDecl : TypeVarDecl
{
}

class ModuleDecl : ContainerDecl
{
}

class PatternDecl : ContainerDecl
{
}

class AggTypeDecl : PatternDecl
{
	var base : TypeExp;
}

class ClassDecl : AggTypeDecl
{
}

class StructDecl : AggTypeDecl
{
}

class FuncDeclBase : PatternDecl
{
	var resultType : TypeExp;
	var body : Stmt;
}

func getResultType(
	declRef: DeclRefValImpl<FuncDeclBase>)
	-> Type
{
	return specializeType(
		declRef.getDecl().resultType.type,
		declRef.specializations);
}

class FuncDecl : FuncDeclBase
{
}

class SubscriptDecl : FuncDeclBase
{
}

class InitializerDecl : FuncDeclBase
{
}

class VarDeclBase : Decl
{
	var type : TypeExp;
	var init : Exp;
}

func getType(declRef: DeclRefValImpl<VarDeclBase>) -> Type
{
	return specializeType(
		declRef.getDecl().type.type,
		declRef.specializations);
}

class VarDecl : VarDeclBase
{
}

class LetDecl : VarDeclBase
{
}

class ParamDecl : LetDecl
{
}

class SyntaxDecl : Decl
{
	var syntaxClass : Ptr<Class>;
	var callback : SyntaxCallback;
}

// Statements

class IfStmtBase : Stmt
{
	var thenStmt : Stmt;
	var elseStmt : Stmt;
}


class IfStmt : IfStmtBase
{
	var condition : Exp;
}

class IfLetStmt : IfStmtBase
{
	var name : Name*;
	var init : Exp;
}


class WhileStmt : Stmt
{
	var condition : Exp;
	var body : Stmt;
}

class ForStmt : ContainerStmt
{
	var init : Stmt;
	var condition : Exp;
	var iter : Exp;
	var body : Stmt;
}

class ReturnStmt : Stmt
{
	var value : Exp;
}

class BreakStmt : Stmt
{
}

class ContinueStmt : Stmt
{
}

class SwitchCase : Syntax
{
	var values : Arg;
	var body : Stmt;
	var next : SwitchCase;
}

class SwitchStmt : Stmt
{
	var condition : Exp;
	var cases : SwitchCase;
}

// Arguments

class Arg : Syntax
{
	var exp : Exp;
	var next : Arg;
}

class PositionalArg : Arg
{
}


// expressions

class Exp : Stmt
{
	var type : Type;
}

class LitExp : Exp
{
}

typealias IntLitVal = Int64;

class IntLitExp : LitExp
{
	var val : IntLitVal;
}

class StringLitExp : LitExp
{
	var val : String;
}

class CharacterLitExp : LitExp
{
	var val : String;
}


class AppExpBase : Exp
{
	var base : Exp;
	var args : SyntaxList<Arg>;
}

class GenericAppExp : AppExpBase
{
}

class AppExp : AppExpBase
{
}

class IndexExp : AppExpBase
{
}

class OperatorAppExp : AppExp
{
}

class InfixExp : OperatorAppExp
{
}

class PrefixExp : OperatorAppExp
{
}

class PostfixExp : OperatorAppExp
{
}

class AssignExp : Exp
{
	var left : Exp;
	var right : Exp;
}

class DeclRefExp : Exp
{
	var declRef : CompactDeclRef;
}

class NameExp : DeclRefExp
{
	var name : Ptr<Name>;
	var scope : Ptr<Scope>;
}


class MemberExp : DeclRefExp
{
	var base : Exp;
	var memberName : Ptr<Name>;
}

class ErrorExp : Exp
{
}

struct LookupResultItem
{
	// TODO: should be a declref
	var decl : Decl;

	init()
	{
		this.decl = null;
	}

//    LookupResultItem(
//        LookupResultItem const& other) = default;

	init(decl: Decl)
	{
		this.decl = decl;
	}
}

struct LookupResult
{
	var items : Array<LookupResultItem>;

	func begin() -> Ptr<LookupResultItem> { return items.begin(); }
	func end() -> Ptr<LookupResultItem> { return items.end(); }


	func isEmpty() -> Bool { return items.getCount() == 0; }
    func isUnique() -> Bool { return items.getCount() == 1; }
    func isOverloaded() -> Bool { return items.getCount() > 1; }

    func getDecl() -> Decl
    {
        cogAssert(isUnique());
        return items[0].decl;
    }

//    func filterImpl(Class* _class);

//	func filter<T>()
//	{
//		filterImpl(getClass<T>());
//	}
}


class OverloadedExpr : Exp
{
	var lookupResult : LookupResult;
	var base : Exp;
}

// Statements

class BlockStmt : ContainerDecl
{
}

// Types

// A type is a value, since it is immutable
class Type : Val
{
}

// A type that is formed via a declaration reference
class DeclRefType : Type
{
	var declRef : CompactDeclRef;
}

// The "type" of another type
class TypeType : Type
{
	var type : Type;
}

// the type of a function
class FuncType : Type
{
    // TODO: domain/range types here
}

// The tyep of an errorneous term
class ErrorType : Type
{
}

// The type of a reference to an overload group
class OverloadGroupType : Type
{
}


// HACK: TODO: fill these in

class EnumDecl : AggTypeDecl
{}

class EnumTagDecl : VarDeclBase
{}

class ForEachStmt : Stmt
{
	var name : Name*;
	var exp: Exp;
	var body: Stmt;
}

class ParenExp : Exp
{
	var base: Exp;
}

//

class ThisExpr : Exp
{
	var scope : Scope*;
}

class CastExpr : Exp
{
	var toType : TypeExp;
	var arg : Exp;
}