#include "runtime/runtime.h"
namespace cogc {


#line 3 "check.cog"
 

#line 5 "check.cog"
 

#line 12 "check.cog"
 

#line 25 "check.cog"
 struct SharedCheckContext;


#line 30 "check.cog"
 struct CheckContext;


#line 38 "diagnostic.cog"
 struct DiagnosticSink;


#line 35 "check.cog"
 

#line 41 "check.cog"
 

#line 48 "check.cog"
 

#line 66 "check.cog"
 

#line 5 "scope.cog"
 struct ScopeLink;


#line 11 "scope.cog"
 struct Scope;


#line 78 "check.cog"
 

#line 90 "check.cog"
 

#line 110 "check.cog"
 

#line 152 "check.cog"
 

#line 167 "check.cog"
 

#line 174 "check.cog"
 

#line 215 "check.cog"
 

#line 237 "check.cog"
 

#line 244 "check.cog"
 

#line 251 "check.cog"
 

#line 269 "check.cog"
 

#line 278 "check.cog"
 

#line 372 "check.cog"
 

#line 387 "check.cog"
 

#line 396 "check.cog"
 

#line 414 "check.cog"
 

#line 5 "syntax.cog"
 struct TypeExp;


#line 423 "check.cog"
 

#line 435 "check.cog"
 

#line 456 "check.cog"
 

#line 480 "check.cog"
 

#line 496 "check.cog"
 

#line 514 "check.cog"
 

#line 524 "check.cog"
 

#line 856 "check.cog"
 

#line 5 "string.cog"
 struct StringSpan;


#line 87 "string.cog"
 struct TerminatedStringSpan;


#line 5 "name.cog"
 struct Name;


#line 872 "check.cog"
 

#line 929 "check.cog"
 

#line 1518 "check.cog"
 enum OverloadResolveMode : int;


#line 1501 "check.cog"
 enum OverloadCandidateState : int;


#line 1511 "check.cog"
 struct OverloadCandidate;


#line 1524 "check.cog"
 struct OverloadResolveContext;


#line 959 "check.cog"
 

#line 1000 "check.cog"
 

#line 1013 "check.cog"
 

#line 1028 "check.cog"
 

#line 1057 "check.cog"
 

#line 1068 "check.cog"
 

#line 1090 "check.cog"
 

#line 1100 "check.cog"
 

#line 1110 "check.cog"
 

#line 1120 "check.cog"
 

#line 1133 "check.cog"
 

#line 1170 "check.cog"
 

#line 1183 "check.cog"
 

#line 1193 "check.cog"
 

#line 5 "source.cog"
 struct SourceLoc;


#line 1200 "check.cog"
 

#line 1230 "check.cog"
 

#line 1258 "check.cog"
 

#line 1267 "check.cog"
 

#line 1277 "check.cog"
 

#line 1297 "check.cog"
 

#line 1337 "check.cog"
 

#line 1350 "check.cog"
 

#line 1375 "check.cog"
 

#line 1388 "check.cog"
 

#line 1444 "check.cog"
 

#line 1468 "check.cog"
 

#line 1488 "check.cog"
 

#line 1536 "check.cog"
 

#line 1547 "check.cog"
 

#line 1558 "check.cog"
 

#line 1630 "check.cog"
 

#line 1743 "check.cog"
 

#line 1751 "check.cog"
 

#line 1770 "check.cog"
 

#line 1778 "check.cog"
 

#line 1793 "check.cog"
 

#line 1848 "check.cog"
 

#line 1856 "check.cog"
 

#line 1871 "check.cog"
 

#line 1884 "check.cog"
 

#line 1895 "check.cog"
 

#line 1920 "check.cog"
 

#line 1944 "check.cog"
 

#line 1953 "check.cog"
 

#line 1973 "check.cog"
 

#line 2030 "check.cog"
 

#line 2118 "check.cog"
 

#line 2125 "check.cog"
 

#line 2133 "check.cog"
 

#line 2156 "check.cog"
 struct GenericInferenceArg;


#line 2162 "check.cog"
 struct GenericInferenceContext;


#line 2169 "check.cog"
 

#line 2187 "check.cog"
 

#line 2225 "check.cog"
 

#line 2246 "check.cog"
 

#line 2259 "check.cog"
 

#line 2304 "check.cog"
 

#line 2316 "check.cog"
 

#line 2416 "check.cog"
 

#line 2447 "check.cog"
 

#line 2467 "check.cog"
 

#line 2481 "check.cog"
 

#line 2497 "check.cog"
 

#line 2542 "check.cog"
 

#line 166 "syntax.cog"
 enum DeclCheckState : int;


#line 2567 "check.cog"
 

#line 2578 "check.cog"
 

#line 3 "diagnostic.cog"
 

#line 5 "diagnostic.cog"
 enum Severity : int;


#line 13 "diagnostic.cog"
 enum DiagnosticID : int;


#line 44 "diagnostic.cog"
 struct ArgTypeList;


#line 59 "diagnostic.cog"
 enum DiagnosticArgFlavor : int;


#line 14 "token.cog"
 enum TokenCode : int;


#line 70 "diagnostic.cog"
 struct DiagnosticArg;


#line 135 "diagnostic.cog"
 

#line 143 "diagnostic.cog"
 

#line 154 "diagnostic.cog"
 

#line 232 "diagnostic.cog"
 

#line 246 "diagnostic.cog"
 

#line 271 "diagnostic.cog"
 

#line 307 "diagnostic.cog"
 

#line 366 "diagnostic.cog"
 

#line 3 "emit.cog"
 

#line 5 "emit.cog"
 struct EmitContext;


#line 12 "emit.cog"
 

#line 17 "emit.cog"
 enum DeclEmitMode : int;


#line 24 "emit.cog"
 

#line 31 "emit.cog"
 

#line 38 "emit.cog"
 

#line 45 "emit.cog"
 

#line 58 "emit.cog"
 

#line 68 "emit.cog"
 

#line 99 "emit.cog"
 

#line 144 "emit.cog"
 

#line 152 "emit.cog"
 

#line 187 "emit.cog"
 

#line 199 "emit.cog"
 

#line 210 "emit.cog"
 

#line 222 "emit.cog"
 

#line 252 "emit.cog"
 

#line 260 "emit.cog"
 

#line 392 "emit.cog"
 

#line 404 "emit.cog"
 

#line 420 "emit.cog"
 

#line 429 "emit.cog"
 

#line 457 "emit.cog"
 

#line 594 "emit.cog"
 

#line 664 "emit.cog"
 

#line 708 "emit.cog"
 

#line 733 "emit.cog"
 

#line 740 "emit.cog"
 

#line 793 "emit.cog"
 

#line 850 "emit.cog"
 

#line 911 "emit.cog"
 

#line 1032 "emit.cog"
 

#line 1043 "emit.cog"
 struct DeclSortContext;


#line 1049 "emit.cog"
 

#line 1056 "emit.cog"
 

#line 1060 "emit.cog"
 

#line 1106 "emit.cog"
 

#line 1136 "emit.cog"
 

#line 1143 "emit.cog"
 

#line 1171 "emit.cog"
 

#line 1193 "emit.cog"
 

#line 1285 "emit.cog"
 

#line 3 "eval.cog"
 

#line 6 "eval.cog"
 

#line 3 "lexer.cog"
 

#line 26 "source.cog"
 struct SourceFile;


#line 5 "token.cog"
 typedef 

#line 5 "token.cog"
                        UInt16 TokenFlags;


#line 5 "lexer.cog"
 struct Lexer;


#line 15 "lexer.cog"
 

#line 31 "lexer.cog"
 

#line 36 "lexer.cog"
 

#line 43 "lexer.cog"
 

#line 48 "lexer.cog"
 

#line 54 "lexer.cog"
 

#line 61 "lexer.cog"
 

#line 67 "lexer.cog"
 

#line 74 "lexer.cog"
 

#line 79 "lexer.cog"
 

#line 84 "lexer.cog"
 

#line 89 "lexer.cog"
 

#line 94 "lexer.cog"
 

#line 123 "lexer.cog"
 

#line 141 "lexer.cog"
 

#line 185 "lexer.cog"
 

#line 200 "lexer.cog"
 

#line 215 "lexer.cog"
 

#line 234 "lexer.cog"
 

#line 266 "lexer.cog"
 

#line 282 "lexer.cog"
 

#line 327 "lexer.cog"
 

#line 57 "token.cog"
 struct Token;


#line 508 "lexer.cog"
 

#line 555 "lexer.cog"
 

#line 605 "lexer.cog"
 

#line 613 "lexer.cog"
 

#line 72 "token.cog"
 struct TokenSpan;


#line 682 "lexer.cog"
 

#line 3 "main.cog"
 

#line 5 "main.cog"
 

#line 103 "main.cog"
 

#line 3 "name.cog"
 

#line 11 "name.cog"
 

#line 38 "name.cog"
 

#line 47 "name.cog"
 

#line 3 "parser.cog"
 

#line 5 "parser.cog"
 typedef 

#line 5 "parser.cog"
                         UInt32 ParserFlags;


#line 7 "parser.cog"
 enum ParserFlag : int;


#line 13 "parser.cog"
 struct Parser;


#line 29 "parser.cog"
 

#line 43 "parser.cog"
 

#line 57 "parser.cog"
 

#line 72 "parser.cog"
 

#line 90 "parser.cog"
 

#line 94 "parser.cog"
 

#line 107 "parser.cog"
 

#line 115 "parser.cog"
 

#line 123 "parser.cog"
 

#line 129 "parser.cog"
 

#line 135 "parser.cog"
 

#line 141 "parser.cog"
 

#line 147 "parser.cog"
 

#line 153 "parser.cog"
 

#line 159 "parser.cog"
 

#line 168 "parser.cog"
 

#line 177 "parser.cog"
 

#line 193 "parser.cog"
 

#line 208 "parser.cog"
 

#line 264 "parser.cog"
 

#line 284 "parser.cog"
 

#line 297 "parser.cog"
 

#line 309 "parser.cog"
 

#line 328 "parser.cog"
 

#line 340 "parser.cog"
 

#line 352 "parser.cog"
 

#line 364 "parser.cog"
 

#line 381 "parser.cog"
 

#line 611 "syntax.cog"
 struct LookupResultItem;


#line 630 "syntax.cog"
 struct LookupResult;


#line 395 "parser.cog"
 

#line 405 "parser.cog"
 

#line 422 "parser.cog"
 

#line 435 "parser.cog"
 

#line 444 "parser.cog"
 

#line 451 "parser.cog"
 

#line 494 "parser.cog"
 

#line 504 "parser.cog"
 

#line 527 "parser.cog"
 

#line 572 "parser.cog"
 

#line 531 "syntax.cog"
 typedef 

#line 531 "syntax.cog"
                       Int64 IntLitVal;


#line 595 "parser.cog"
 

#line 639 "parser.cog"
 

#line 689 "parser.cog"
 

#line 778 "parser.cog"
 

#line 789 "parser.cog"
 

#line 805 "parser.cog"
 

#line 823 "parser.cog"
 

#line 831 "parser.cog"
 

#line 901 "parser.cog"
 

#line 918 "parser.cog"
 

#line 961 "parser.cog"
 

#line 968 "parser.cog"
 

#line 979 "parser.cog"
 

#line 1054 "parser.cog"
 

#line 1124 "parser.cog"
 

#line 1159 "parser.cog"
 

#line 1169 "parser.cog"
 

#line 1184 "parser.cog"
 

#line 1193 "parser.cog"
 

#line 1250 "parser.cog"
 

#line 1279 "parser.cog"
 

#line 1296 "parser.cog"
 

#line 1320 "parser.cog"
 

#line 1330 "parser.cog"
 

#line 1339 "parser.cog"
 

#line 1360 "parser.cog"
 

#line 1387 "parser.cog"
 

#line 1415 "parser.cog"
 

#line 1441 "parser.cog"
 

#line 1471 "parser.cog"
 

#line 1477 "parser.cog"
 

#line 1483 "parser.cog"
 

#line 1524 "parser.cog"
 

#line 1549 "parser.cog"
 

#line 1559 "parser.cog"
 

#line 1576 "parser.cog"
 

#line 1584 "parser.cog"
 

#line 1592 "parser.cog"
 

#line 1607 "parser.cog"
 

#line 1613 "parser.cog"
 

#line 1628 "parser.cog"
 

#line 1640 "parser.cog"
 

#line 1673 "parser.cog"
 

#line 1683 "parser.cog"
 

#line 1733 "parser.cog"
 

#line 1752 "parser.cog"
 

#line 1819 "parser.cog"
 

#line 1830 "parser.cog"
 

#line 1837 "parser.cog"
 

#line 1844 "parser.cog"
 

#line 1853 "parser.cog"
 

#line 1866 "parser.cog"
 

#line 1873 "parser.cog"
 

#line 1922 "parser.cog"
 

#line 1959 "parser.cog"
 

#line 1990 "parser.cog"
 

#line 2022 "parser.cog"
 

#line 2029 "parser.cog"
 

#line 2044 "parser.cog"
 

#line 2050 "parser.cog"
 

#line 2064 "parser.cog"
 

#line 2073 "parser.cog"
 

#line 2139 "parser.cog"
 

#line 3 "scope.cog"
 

#line 17 "scope.cog"
 

#line 34 "scope.cog"
 

#line 44 "scope.cog"
 

#line 60 "scope.cog"
 

#line 3 "session.cog"
 

#line 5 "session.cog"
 using Session = struct SessionImpl* ;
struct SessionImpl;


#line 22 "session.cog"
 

#line 29 "session.cog"
 

#line 34 "session.cog"
 

#line 46 "session.cog"
 

#line 53 "session.cog"
 

#line 60 "session.cog"
 

#line 67 "session.cog"
 

#line 73 "session.cog"
 

#line 83 "session.cog"
 

#line 3 "source.cog"
 

#line 17 "source.cog"
 struct Dummy;


#line 19 "source.cog"
 struct ExpandedSourceLoc;


#line 42 "source.cog"
 

#line 99 "source.cog"
 

#line 3 "string.cog"
 

#line 70 "string.cog"
 

#line 81 "string.cog"
 

#line 3 "syntax.cog"
 

#line 18 "syntax.cog"
 

#line 23 "syntax.cog"
 template<typename T >
struct SyntaxListIterator;


#line 44 "syntax.cog"
 

#line 52 "syntax.cog"
 template<typename T, typename U >
struct FilteredArrayIter;


#line 90 "syntax.cog"
 template<typename T, typename U >
struct FilteredArray;


#line 125 "syntax.cog"
 using Syntax = struct SyntaxImpl* ;
struct SyntaxImpl;


#line 130 "syntax.cog"
 using Attr = struct AttrImpl* ;
struct AttrImpl;


#line 134 "syntax.cog"
 using BuiltinAttr = struct BuiltinAttrImpl* ;
struct BuiltinAttrImpl;


#line 139 "syntax.cog"
 using DeclRefClassAttr = struct DeclRefClassAttrImpl* ;
struct DeclRefClassAttrImpl;


#line 144 "syntax.cog"
 using Stmt = struct StmtImpl* ;
struct StmtImpl;


#line 174 "syntax.cog"
 using Decl = struct DeclImpl* ;
struct DeclImpl;


#line 186 "syntax.cog"
 using SpecializationArg = struct SpecializationArgImpl* ;
struct SpecializationArgImpl;


#line 192 "syntax.cog"
 using Specializations = struct SpecializationsImpl* ;
struct SpecializationsImpl;


#line 199 "syntax.cog"
 using SpecializedDecl = struct SpecializedDeclImpl* ;
struct SpecializedDeclImpl;


#line 210 "syntax.cog"
 using Val = struct ValImpl* ;
struct ValImpl;


#line 214 "syntax.cog"
 using ContainerStmt = struct ContainerStmtImpl* ;
struct ContainerStmtImpl;


#line 229 "syntax.cog"
 using ContainerDecl = struct ContainerDeclImpl* ;
struct ContainerDeclImpl;


#line 236 "syntax.cog"
 template<typename T >
struct DeclRefListIterator;


#line 282 "syntax.cog"
 template<typename T >
struct DeclRefList;


#line 310 "syntax.cog"
 

#line 317 "syntax.cog"
 

#line 325 "syntax.cog"
 using GenericDecl = struct GenericDeclImpl* ;
struct GenericDeclImpl;


#line 330 "syntax.cog"
 

#line 338 "syntax.cog"
 using TypeVarDecl = struct TypeVarDeclImpl* ;
struct TypeVarDeclImpl;


#line 344 "syntax.cog"
 using ImportDecl = struct ImportDeclImpl* ;
struct ImportDeclImpl;


#line 352 "syntax.cog"
 using GenericParamDecl = struct GenericParamDeclImpl* ;
struct GenericParamDeclImpl;


#line 356 "syntax.cog"
 

#line 365 "syntax.cog"
 using TypeAliasDecl = struct TypeAliasDeclImpl* ;
struct TypeAliasDeclImpl;


#line 369 "syntax.cog"
 using ModuleDecl = struct ModuleDeclImpl* ;
struct ModuleDeclImpl;


#line 373 "syntax.cog"
 using PatternDecl = struct PatternDeclImpl* ;
struct PatternDeclImpl;


#line 377 "syntax.cog"
 using AggTypeDecl = struct AggTypeDeclImpl* ;
struct AggTypeDeclImpl;


#line 382 "syntax.cog"
 using ClassDecl = struct ClassDeclImpl* ;
struct ClassDeclImpl;


#line 386 "syntax.cog"
 using StructDecl = struct StructDeclImpl* ;
struct StructDeclImpl;


#line 390 "syntax.cog"
 using FuncDeclBase = struct FuncDeclBaseImpl* ;
struct FuncDeclBaseImpl;


#line 396 "syntax.cog"
 

#line 405 "syntax.cog"
 using FuncDecl = struct FuncDeclImpl* ;
struct FuncDeclImpl;


#line 409 "syntax.cog"
 using SubscriptDecl = struct SubscriptDeclImpl* ;
struct SubscriptDeclImpl;


#line 413 "syntax.cog"
 using InitializerDecl = struct InitializerDeclImpl* ;
struct InitializerDeclImpl;


#line 417 "syntax.cog"
 using VarDeclBase = struct VarDeclBaseImpl* ;
struct VarDeclBaseImpl;


#line 423 "syntax.cog"
 

#line 430 "syntax.cog"
 using VarDecl = struct VarDeclImpl* ;
struct VarDeclImpl;


#line 434 "syntax.cog"
 using LetDecl = struct LetDeclImpl* ;
struct LetDeclImpl;


#line 438 "syntax.cog"
 using ParamDecl = struct ParamDeclImpl* ;
struct ParamDeclImpl;


#line 442 "syntax.cog"
 using SyntaxDecl = struct SyntaxDeclImpl* ;
struct SyntaxDeclImpl;


#line 450 "syntax.cog"
 using IfStmtBase = struct IfStmtBaseImpl* ;
struct IfStmtBaseImpl;


#line 457 "syntax.cog"
 using IfStmt = struct IfStmtImpl* ;
struct IfStmtImpl;


#line 462 "syntax.cog"
 using IfLetStmt = struct IfLetStmtImpl* ;
struct IfLetStmtImpl;


#line 469 "syntax.cog"
 using WhileStmt = struct WhileStmtImpl* ;
struct WhileStmtImpl;


#line 475 "syntax.cog"
 using ForStmt = struct ForStmtImpl* ;
struct ForStmtImpl;


#line 483 "syntax.cog"
 using ReturnStmt = struct ReturnStmtImpl* ;
struct ReturnStmtImpl;


#line 488 "syntax.cog"
 using BreakStmt = struct BreakStmtImpl* ;
struct BreakStmtImpl;


#line 492 "syntax.cog"
 using ContinueStmt = struct ContinueStmtImpl* ;
struct ContinueStmtImpl;


#line 496 "syntax.cog"
 using SwitchCase = struct SwitchCaseImpl* ;
struct SwitchCaseImpl;


#line 502 "syntax.cog"
 using SwitchStmt = struct SwitchStmtImpl* ;
struct SwitchStmtImpl;


#line 510 "syntax.cog"
 using Arg = struct ArgImpl* ;
struct ArgImpl;


#line 515 "syntax.cog"
 using PositionalArg = struct PositionalArgImpl* ;
struct PositionalArgImpl;


#line 522 "syntax.cog"
 using Exp = struct ExpImpl* ;
struct ExpImpl;


#line 527 "syntax.cog"
 using LitExp = struct LitExpImpl* ;
struct LitExpImpl;


#line 533 "syntax.cog"
 using IntLitExp = struct IntLitExpImpl* ;
struct IntLitExpImpl;


#line 538 "syntax.cog"
 using StringLitExp = struct StringLitExpImpl* ;
struct StringLitExpImpl;


#line 543 "syntax.cog"
 using CharacterLitExp = struct CharacterLitExpImpl* ;
struct CharacterLitExpImpl;


#line 549 "syntax.cog"
 using AppExpBase = struct AppExpBaseImpl* ;
struct AppExpBaseImpl;


#line 555 "syntax.cog"
 using GenericAppExp = struct GenericAppExpImpl* ;
struct GenericAppExpImpl;


#line 559 "syntax.cog"
 using AppExp = struct AppExpImpl* ;
struct AppExpImpl;


#line 563 "syntax.cog"
 using IndexExp = struct IndexExpImpl* ;
struct IndexExpImpl;


#line 567 "syntax.cog"
 using OperatorAppExp = struct OperatorAppExpImpl* ;
struct OperatorAppExpImpl;


#line 571 "syntax.cog"
 using InfixExp = struct InfixExpImpl* ;
struct InfixExpImpl;


#line 575 "syntax.cog"
 using PrefixExp = struct PrefixExpImpl* ;
struct PrefixExpImpl;


#line 579 "syntax.cog"
 using PostfixExp = struct PostfixExpImpl* ;
struct PostfixExpImpl;


#line 583 "syntax.cog"
 using AssignExp = struct AssignExpImpl* ;
struct AssignExpImpl;


#line 589 "syntax.cog"
 using DeclRefExp = struct DeclRefExpImpl* ;
struct DeclRefExpImpl;


#line 594 "syntax.cog"
 using NameExp = struct NameExpImpl* ;
struct NameExpImpl;


#line 601 "syntax.cog"
 using MemberExp = struct MemberExpImpl* ;
struct MemberExpImpl;


#line 607 "syntax.cog"
 using ErrorExp = struct ErrorExpImpl* ;
struct ErrorExpImpl;


#line 657 "syntax.cog"
 using OverloadedExpr = struct OverloadedExprImpl* ;
struct OverloadedExprImpl;


#line 665 "syntax.cog"
 using BlockStmt = struct BlockStmtImpl* ;
struct BlockStmtImpl;


#line 672 "syntax.cog"
 using Type = struct TypeImpl* ;
struct TypeImpl;


#line 677 "syntax.cog"
 using DeclRefType = struct DeclRefTypeImpl* ;
struct DeclRefTypeImpl;


#line 683 "syntax.cog"
 using VoidType = struct VoidTypeImpl* ;
struct VoidTypeImpl;


#line 686 "syntax.cog"
 using NullType = struct NullTypeImpl* ;
struct NullTypeImpl;


#line 689 "syntax.cog"
 using PtrType = struct PtrTypeImpl* ;
struct PtrTypeImpl;


#line 693 "syntax.cog"
 using ClassType = struct ClassTypeImpl* ;
struct ClassTypeImpl;


#line 697 "syntax.cog"
 using TypeType = struct TypeTypeImpl* ;
struct TypeTypeImpl;


#line 703 "syntax.cog"
 using FuncType = struct FuncTypeImpl* ;
struct FuncTypeImpl;


#line 709 "syntax.cog"
 using ErrorType = struct ErrorTypeImpl* ;
struct ErrorTypeImpl;


#line 714 "syntax.cog"
 using OverloadGroupType = struct OverloadGroupTypeImpl* ;
struct OverloadGroupTypeImpl;


#line 721 "syntax.cog"
 using EnumDecl = struct EnumDeclImpl* ;
struct EnumDeclImpl;


#line 724 "syntax.cog"
 using EnumTagDecl = struct EnumTagDeclImpl* ;
struct EnumTagDeclImpl;


#line 727 "syntax.cog"
 using ForEachStmt = struct ForEachStmtImpl* ;
struct ForEachStmtImpl;


#line 734 "syntax.cog"
 using ParenExp = struct ParenExpImpl* ;
struct ParenExpImpl;


#line 741 "syntax.cog"
 using ThisExpr = struct ThisExprImpl* ;
struct ThisExprImpl;


#line 746 "syntax.cog"
 using CastExpr = struct CastExprImpl* ;
struct CastExprImpl;


#line 752 "syntax.cog"
 using NullLitExpr = struct NullLitExprImpl* ;
struct NullLitExprImpl;


#line 3 "token.cog"
 

#line 7 "token.cog"
 enum TokenFlag : int;


#line 3 "check.cog"
 

#line 5 "check.cog"
 void checkModule(

#line 6 "check.cog"
              Session session);


#line 12 "check.cog"
 void checkModule(

#line 13 "check.cog"
           Session session, 

#line 14 "check.cog"
              ModuleDecl moduleDecl);


#line 25 "check.cog"
 struct SharedCheckContext
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 27 "check.cog"
  

#line 27 "check.cog"
                Session session;
};


#line 30 "check.cog"
 struct CheckContext
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 32 "check.cog"
  

#line 32 "check.cog"
                                 

#line 32 "check.cog"
               SharedCheckContext

#line 32 "check.cog"
                                 * shared;
};


#line 38 "diagnostic.cog"
 struct DiagnosticSink
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 40 "diagnostic.cog"
  

#line 40 "diagnostic.cog"
                Session session;


#line 41 "diagnostic.cog"
  

#line 41 "diagnostic.cog"
                   Int errorCount;
};


#line 35 "check.cog"
 

#line 36 "check.cog"
                                           

#line 36 "check.cog"
                             DiagnosticSink

#line 36 "check.cog"
                                           * getSink(

#line 36 "check.cog"
                       

#line 36 "check.cog"
           CheckContext

#line 36 "check.cog"
                       * context);


#line 41 "check.cog"
 void checkModule(

#line 42 "check.cog"
                       

#line 42 "check.cog"
           CheckContext

#line 42 "check.cog"
                       * context, 

#line 43 "check.cog"
              ModuleDecl moduleDecl);


#line 48 "check.cog"
 void checkImportDecls(

#line 49 "check.cog"
                       

#line 49 "check.cog"
           CheckContext

#line 49 "check.cog"
                       * context, 

#line 50 "check.cog"
                 ContainerDecl containerDecl);


#line 66 "check.cog"
 void checkDecls(

#line 67 "check.cog"
                         

#line 67 "check.cog"
             CheckContext

#line 67 "check.cog"
                         * context, 

#line 68 "check.cog"
                  ContainerDecl containerDecl);


#line 5 "scope.cog"
 struct ScopeLink
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 7 "scope.cog"
  

#line 7 "scope.cog"
                  ContainerStmt container;


#line 8 "scope.cog"
  

#line 8 "scope.cog"
                

#line 8 "scope.cog"
             Ptr<

#line 8 "scope.cog"
                 ScopeLink>  next = 

#line 8 "scope.cog"
                              nullptr;
};


#line 11 "scope.cog"
 struct Scope
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 13 "scope.cog"
  

#line 13 "scope.cog"
                  

#line 13 "scope.cog"
               Ptr<

#line 13 "scope.cog"
                   Scope>  parent;


#line 14 "scope.cog"
  

#line 14 "scope.cog"
                   ScopeLink directLink;
};


#line 78 "check.cog"
 void attachToScope(

#line 79 "check.cog"
              

#line 79 "check.cog"
         Scope

#line 79 "check.cog"
              * scope, 

#line 80 "check.cog"
         ContainerDecl decl);


#line 90 "check.cog"
 void checkDecl(

#line 91 "check.cog"
                        

#line 91 "check.cog"
            CheckContext

#line 91 "check.cog"
                        * context, 

#line 92 "check.cog"
         Decl decl);


#line 110 "check.cog"
 void checkDeclImpl(

#line 111 "check.cog"
                        

#line 111 "check.cog"
            CheckContext

#line 111 "check.cog"
                        * context, 

#line 112 "check.cog"
         Decl decl);


#line 152 "check.cog"
 void checkGenericDecl(

#line 153 "check.cog"
                       

#line 153 "check.cog"
           CheckContext

#line 153 "check.cog"
                       * context, 

#line 154 "check.cog"
        GenericDecl decl);


#line 167 "check.cog"
 void checkTypeAliasDecl(

#line 168 "check.cog"
                       

#line 168 "check.cog"
           CheckContext

#line 168 "check.cog"
                       * context, 

#line 169 "check.cog"
        TypeAliasDecl decl);


#line 174 "check.cog"
 void checkVarDecl(

#line 175 "check.cog"
                       

#line 175 "check.cog"
           CheckContext

#line 175 "check.cog"
                       * context, 

#line 176 "check.cog"
        VarDeclBase decl);


#line 215 "check.cog"
 void checkFuncDecl(

#line 216 "check.cog"
                       

#line 216 "check.cog"
           CheckContext

#line 216 "check.cog"
                       * context, 

#line 217 "check.cog"
        FuncDeclBase decl);


#line 237 "check.cog"
 void checkClassDecl(

#line 238 "check.cog"
                       

#line 238 "check.cog"
           CheckContext

#line 238 "check.cog"
                       * context, 

#line 239 "check.cog"
        ClassDecl decl);


#line 244 "check.cog"
 void checkStructDecl(

#line 245 "check.cog"
                       

#line 245 "check.cog"
           CheckContext

#line 245 "check.cog"
                       * context, 

#line 246 "check.cog"
        StructDecl decl);


#line 251 "check.cog"
 void checkAggTypeDeclCommon(

#line 252 "check.cog"
                       

#line 252 "check.cog"
           CheckContext

#line 252 "check.cog"
                       * context, 

#line 253 "check.cog"
        AggTypeDecl decl);


#line 269 "check.cog"
 

#line 272 "check.cog"
     Exp checkPrediateExpr(

#line 270 "check.cog"
                       

#line 270 "check.cog"
           CheckContext

#line 270 "check.cog"
                       * context, 

#line 271 "check.cog"
        Exp expr);


#line 278 "check.cog"
 

#line 281 "check.cog"
     Stmt checkStmt(

#line 279 "check.cog"
                       

#line 279 "check.cog"
           CheckContext

#line 279 "check.cog"
                       * context, 

#line 280 "check.cog"
        Stmt stmt);


#line 372 "check.cog"
 

#line 375 "check.cog"
     Stmt checkBlockStmt(

#line 373 "check.cog"
                       

#line 373 "check.cog"
           CheckContext

#line 373 "check.cog"
                       * context, 

#line 374 "check.cog"
        BlockStmt stmt);


#line 387 "check.cog"
 

#line 390 "check.cog"
     Exp checkExp(

#line 388 "check.cog"
                       

#line 388 "check.cog"
           CheckContext

#line 388 "check.cog"
                       * context, 

#line 389 "check.cog"
       Exp exp);


#line 396 "check.cog"
 

#line 399 "check.cog"
     Exp coerceToExp(

#line 397 "check.cog"
                       

#line 397 "check.cog"
           CheckContext

#line 397 "check.cog"
                       * context, 

#line 398 "check.cog"
        Syntax term);


#line 414 "check.cog"
 

#line 417 "check.cog"
     Type checkType(

#line 415 "check.cog"
                       

#line 415 "check.cog"
           CheckContext

#line 415 "check.cog"
                       * context, 

#line 416 "check.cog"
       Exp exp);


#line 5 "syntax.cog"
 struct TypeExp
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 7 "syntax.cog"
  

#line 7 "syntax.cog"
            Exp exp = 

#line 7 "syntax.cog"
                  nullptr;


#line 8 "syntax.cog"
  

#line 8 "syntax.cog"
             Type type = 

#line 8 "syntax.cog"
                    nullptr;
};


#line 423 "check.cog"
 void checkTypeExp(

#line 424 "check.cog"
                       

#line 424 "check.cog"
           CheckContext

#line 424 "check.cog"
                       * context, 

#line 425 "check.cog"
                  

#line 425 "check.cog"
           TypeExp

#line 425 "check.cog"
                  * typeExp);


#line 435 "check.cog"
 

#line 438 "check.cog"
     Exp tryCoerceToTypeExpr(

#line 436 "check.cog"
                       

#line 436 "check.cog"
           CheckContext

#line 436 "check.cog"
                       * context, 

#line 437 "check.cog"
       Exp exp);


#line 456 "check.cog"
 

#line 459 "check.cog"
     Type tryCoerceToType(

#line 457 "check.cog"
                       

#line 457 "check.cog"
           CheckContext

#line 457 "check.cog"
                       * context, 

#line 458 "check.cog"
       Exp exp);


#line 480 "check.cog"
 

#line 483 "check.cog"
     Type coerceToType(

#line 481 "check.cog"
                       

#line 481 "check.cog"
           CheckContext

#line 481 "check.cog"
                       * context, 

#line 482 "check.cog"
       Exp exp);


#line 496 "check.cog"
 

#line 499 "check.cog"
     Exp coerceToTypeExpr(

#line 497 "check.cog"
                       

#line 497 "check.cog"
           CheckContext

#line 497 "check.cog"
                       * context, 

#line 498 "check.cog"
       Exp exp);


#line 514 "check.cog"
 

#line 517 "check.cog"
     Exp makeErrorExpr(

#line 515 "check.cog"
                       

#line 515 "check.cog"
           CheckContext

#line 515 "check.cog"
                       * context, 

#line 516 "check.cog"
        Exp expr);


#line 524 "check.cog"
 

#line 527 "check.cog"
     Exp checkTerm(

#line 525 "check.cog"
                       

#line 525 "check.cog"
           CheckContext

#line 525 "check.cog"
                       * context, 

#line 526 "check.cog"
       Exp exp);


#line 856 "check.cog"
 

#line 858 "check.cog"
        Val extractVal(

#line 857 "check.cog"
       Exp exp);


#line 5 "string.cog"
 struct StringSpan
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 7 "string.cog"
  

#line 7 "string.cog"
                 

#line 7 "string.cog"
              Ptr<

#line 7 "string.cog"
                  Char>  begin;


#line 8 "string.cog"
  

#line 8 "string.cog"
               

#line 8 "string.cog"
            Ptr<

#line 8 "string.cog"
                Char>  end;


#line 10 "string.cog"
  StringSpan();


#line 13 "string.cog"
  StringSpan(

#line 14 "string.cog"
             

#line 14 "string.cog"
          Ptr<

#line 14 "string.cog"
              Char>  begin, 

#line 15 "string.cog"
           

#line 15 "string.cog"
        Ptr<

#line 15 "string.cog"
            Char>  end);


#line 21 "string.cog"
  StringSpan(

#line 22 "string.cog"
                  

#line 22 "string.cog"
          ConstPtr<

#line 22 "string.cog"
                   Char>  begin, 

#line 23 "string.cog"
                

#line 23 "string.cog"
        ConstPtr<

#line 23 "string.cog"
                 Char>  end);


#line 29 "string.cog"
  

#line 29 "string.cog"
                      UInt getLength();


#line 34 "string.cog"
  

#line 34 "string.cog"
                                       Bool endsWith(

#line 34 "string.cog"
                        StringSpan suffix);


#line 44 "string.cog"
  

#line 44 "string.cog"
                                          Bool trimFromEnd(

#line 44 "string.cog"
                           StringSpan suffix);


#line 54 "string.cog"
  

#line 54 "string.cog"
                                   StringSpan suffixAfterLast(

#line 54 "string.cog"
                          Char c);
};


#line 87 "string.cog"
 struct TerminatedStringSpan : 

#line 87 "string.cog"
                               StringSpan
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 92 "string.cog"
  TerminatedStringSpan(

#line 92 "string.cog"
                     

#line 92 "string.cog"
             ConstPtr<

#line 92 "string.cog"
                      Char>  text);


#line 99 "string.cog"
  TerminatedStringSpan();


#line 102 "string.cog"
  TerminatedStringSpan(

#line 103 "string.cog"
             

#line 103 "string.cog"
          Ptr<

#line 103 "string.cog"
              Char>  begin, 

#line 104 "string.cog"
           

#line 104 "string.cog"
        Ptr<

#line 104 "string.cog"
            Char>  end);


#line 110 "string.cog"
  

#line 110 "string.cog"
                         StringSpan asStringSpan();
};


#line 5 "name.cog"
 struct Name
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 7 "name.cog"
  

#line 7 "name.cog"
            TerminatedStringSpan text;


#line 8 "name.cog"
  

#line 8 "name.cog"
               

#line 8 "name.cog"
            Ptr<

#line 8 "name.cog"
                Name>  next;
};


#line 872 "check.cog"
 

#line 878 "check.cog"
     Exp lookUpMemberInType(

#line 873 "check.cog"
                       

#line 873 "check.cog"
           CheckContext

#line 873 "check.cog"
                       * context, 

#line 874 "check.cog"
        MemberExp exp, 

#line 875 "check.cog"
         Exp base, 

#line 876 "check.cog"
            Type baseType, 

#line 877 "check.cog"
                  

#line 877 "check.cog"
              Name

#line 877 "check.cog"
                  * memberName);


#line 929 "check.cog"
 

#line 932 "check.cog"
        Exp checkMemberExp(

#line 930 "check.cog"
                       

#line 930 "check.cog"
           CheckContext

#line 930 "check.cog"
                       * context, 

#line 931 "check.cog"
       MemberExp exp);


#line 1518 "check.cog"
 enum OverloadResolveMode : int
{
kOverloadResolveMode_justTrying,
kOverloadResolveMode_forReal,
};


#line 1501 "check.cog"
 enum OverloadCandidateState : int
{
kOverloadCandidateState_Unchecked,
kOverloadCandidateState_GenericArgumentInferenceFailed,
kOverloadCandidateState_CheckedArity,
kOverloadCandidateState_CheckedTypes,
kOverloadCandidateState_Applicable,
};


#line 1511 "check.cog"
 struct OverloadCandidate
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 1513 "check.cog"
  

#line 1513 "check.cog"
                OverloadCandidateState state;


#line 1514 "check.cog"
  

#line 1514 "check.cog"
                 DeclRefVal declRef;


#line 1515 "check.cog"
  

#line 1515 "check.cog"
                    Type resultType;
};


#line 1524 "check.cog"
 struct OverloadResolveContext
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 1526 "check.cog"
  

#line 1526 "check.cog"
                                  

#line 1526 "check.cog"
                      CheckContext

#line 1526 "check.cog"
                                  * checkContext;


#line 1527 "check.cog"
     

#line 1527 "check.cog"
                     AppExpBase appExp;


#line 1528 "check.cog"
     

#line 1528 "check.cog"
                     Exp baseExp = 

#line 1528 "check.cog"
                           nullptr;


#line 1530 "check.cog"
     

#line 1530 "check.cog"
                OverloadResolveMode mode = 

#line 1530 "check.cog"
                                      kOverloadResolveMode_justTrying;


#line 1533 "check.cog"
     

#line 1533 "check.cog"
                           

#line 1533 "check.cog"
                      Array<

#line 1533 "check.cog"
                            OverloadCandidate>  candidates;
};


#line 959 "check.cog"
 void addAppOverloadCandidates(

#line 960 "check.cog"
                                 

#line 960 "check.cog"
           OverloadResolveContext

#line 960 "check.cog"
                                 * context, 

#line 961 "check.cog"
           Exp baseExp);


#line 1000 "check.cog"
 void addGenericGenericOverloadCandidate(

#line 1001 "check.cog"
                                    

#line 1001 "check.cog"
              OverloadResolveContext

#line 1001 "check.cog"
                                    * context, 

#line 1002 "check.cog"
                                

#line 1002 "check.cog"
                  DeclRefValImpl<

#line 1002 "check.cog"
                                 GenericDecl>  genericDeclRef);


#line 1013 "check.cog"
 void addDeclRefGenericOverloadCandidates(

#line 1014 "check.cog"
                                    

#line 1014 "check.cog"
              OverloadResolveContext

#line 1014 "check.cog"
                                    * context, 

#line 1015 "check.cog"
          DeclRefVal val);


#line 1028 "check.cog"
 void addGenericAppOverloadCandidates(

#line 1029 "check.cog"
                                 

#line 1029 "check.cog"
           OverloadResolveContext

#line 1029 "check.cog"
                                 * context, 

#line 1030 "check.cog"
           Exp baseExp);


#line 1057 "check.cog"
 

#line 1060 "check.cog"
        Type createFuncType(

#line 1058 "check.cog"
                       

#line 1058 "check.cog"
           CheckContext

#line 1058 "check.cog"
                       * context, 

#line 1059 "check.cog"
                             

#line 1059 "check.cog"
               DeclRefValImpl<

#line 1059 "check.cog"
                              FuncDeclBase>  funcDeclRef);


#line 1068 "check.cog"
 

#line 1070 "check.cog"
          

#line 1070 "check.cog"
     Class

#line 1070 "check.cog"
          * getSyntaxClassForDeclRef(

#line 1069 "check.cog"
           DeclRefVal declRef);


#line 1090 "check.cog"
 

#line 1092 "check.cog"
     Type createDeclRefType(

#line 1091 "check.cog"
           DeclRefVal declRef);


#line 1100 "check.cog"
 

#line 1103 "check.cog"
     Type createDeclRefTypeType(

#line 1101 "check.cog"
                       

#line 1101 "check.cog"
           CheckContext

#line 1101 "check.cog"
                       * context, 

#line 1102 "check.cog"
           DeclRefVal declRef);


#line 1110 "check.cog"
 

#line 1113 "check.cog"
     TypeType createTypeType(

#line 1111 "check.cog"
                       

#line 1111 "check.cog"
           CheckContext

#line 1111 "check.cog"
                       * context, 

#line 1112 "check.cog"
        Type type);


#line 1120 "check.cog"
 

#line 1124 "check.cog"
     Type specializeTypeForDeclRef(

#line 1121 "check.cog"
                        

#line 1121 "check.cog"
            CheckContext

#line 1121 "check.cog"
                        * context, 

#line 1122 "check.cog"
         Type type, 

#line 1123 "check.cog"
           DeclRefVal declRef);


#line 1133 "check.cog"
 

#line 1136 "check.cog"
     Type getTypeForDeclRefImpl(

#line 1134 "check.cog"
                       

#line 1134 "check.cog"
           CheckContext

#line 1134 "check.cog"
                       * context, 

#line 1135 "check.cog"
           DeclRefVal declRef);


#line 1170 "check.cog"
 

#line 1173 "check.cog"
     Type getTypeForDeclRef(

#line 1171 "check.cog"
                       

#line 1171 "check.cog"
           CheckContext

#line 1171 "check.cog"
                       * context, 

#line 1172 "check.cog"
           DeclRefVal declRef);


#line 1183 "check.cog"
 

#line 1186 "check.cog"
     Type getTypeForDeclRef(

#line 1184 "check.cog"
                       

#line 1184 "check.cog"
           CheckContext

#line 1184 "check.cog"
                       * context, 

#line 1185 "check.cog"
           CompactDeclRef declRef);


#line 1193 "check.cog"
 

#line 1195 "check.cog"
     Type createErrorType(

#line 1194 "check.cog"
                       

#line 1194 "check.cog"
           CheckContext

#line 1194 "check.cog"
                       * context);


#line 5 "source.cog"
 struct SourceLoc
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 7 "source.cog"
  

#line 7 "source.cog"
            UInt raw;


#line 9 "source.cog"
  SourceLoc();


#line 11 "source.cog"
  SourceLoc(

#line 11 "source.cog"
            UInt raw);
};


#line 1200 "check.cog"
 

#line 1204 "check.cog"
        Type getBuiltinType(

#line 1201 "check.cog"
                       

#line 1201 "check.cog"
           CheckContext

#line 1201 "check.cog"
                       * context, 

#line 1202 "check.cog"
       SourceLoc loc, 

#line 1203 "check.cog"
                

#line 1203 "check.cog"
        ConstPtr<

#line 1203 "check.cog"
                 Char>  name);


#line 1230 "check.cog"
 

#line 1233 "check.cog"
     Type getResultType(

#line 1231 "check.cog"
                       

#line 1231 "check.cog"
           CheckContext

#line 1231 "check.cog"
                       * context, 

#line 1232 "check.cog"
                      

#line 1232 "check.cog"
        DeclRefValImpl<

#line 1232 "check.cog"
                       PatternDecl>  decl);


#line 1258 "check.cog"
 

#line 1261 "check.cog"
        Exp createErrorExp(

#line 1259 "check.cog"
                       

#line 1259 "check.cog"
           CheckContext

#line 1259 "check.cog"
                       * context, 

#line 1260 "check.cog"
       Exp exp);


#line 1267 "check.cog"
 

#line 1270 "check.cog"
        Exp createErrorExp(

#line 1268 "check.cog"
                       

#line 1268 "check.cog"
           CheckContext

#line 1268 "check.cog"
                       * context, 

#line 1269 "check.cog"
       SourceLoc loc);


#line 1277 "check.cog"
 

#line 1280 "check.cog"
        Bool isSameVal(

#line 1278 "check.cog"
        Val left, 

#line 1279 "check.cog"
         Val right);


#line 1297 "check.cog"
 

#line 1300 "check.cog"
        Bool isSameSpecializations(

#line 1298 "check.cog"
        Specializations left, 

#line 1299 "check.cog"
            Specializations right);


#line 1337 "check.cog"
 

#line 1340 "check.cog"
        Bool isSameDeclRef(

#line 1338 "check.cog"
                

#line 1338 "check.cog"
        ConstRef<

#line 1338 "check.cog"
                 DeclRefVal>  left, 

#line 1339 "check.cog"
                 

#line 1339 "check.cog"
         ConstRef<

#line 1339 "check.cog"
                  DeclRefVal>  right);


#line 1350 "check.cog"
 

#line 1353 "check.cog"
        Bool isSameType(

#line 1351 "check.cog"
        Type left, 

#line 1352 "check.cog"
         Type right);


#line 1375 "check.cog"
 

#line 1378 "check.cog"
     Exp createCastExpr(

#line 1376 "check.cog"
           Type toType, 

#line 1377 "check.cog"
           Exp fromExp);


#line 1388 "check.cog"
 

#line 1394 "check.cog"
        Bool tryCoerceImpl(

#line 1389 "check.cog"
                        

#line 1389 "check.cog"
            CheckContext

#line 1389 "check.cog"
                        * context, 

#line 1390 "check.cog"
               Exp fromExp, 

#line 1391 "check.cog"
                Type fromType, 

#line 1392 "check.cog"
                 

#line 1392 "check.cog"
              Exp

#line 1392 "check.cog"
                 * toExp, 

#line 1393 "check.cog"
              Type toType);


#line 1444 "check.cog"
 

#line 1449 "check.cog"
        Bool tryCoerceImpl(

#line 1445 "check.cog"
                        

#line 1445 "check.cog"
            CheckContext

#line 1445 "check.cog"
                        * context, 

#line 1446 "check.cog"
               Exp fromExp, 

#line 1447 "check.cog"
                 

#line 1447 "check.cog"
              Exp

#line 1447 "check.cog"
                 * toExp, 

#line 1448 "check.cog"
              Type toType);


#line 1468 "check.cog"
 

#line 1472 "check.cog"
        Exp coerce(

#line 1469 "check.cog"
                        

#line 1469 "check.cog"
            CheckContext

#line 1469 "check.cog"
                        * context, 

#line 1470 "check.cog"
            Exp exp, 

#line 1471 "check.cog"
             Type type);


#line 1488 "check.cog"
 

#line 1492 "check.cog"
        Bool canCoerce(

#line 1489 "check.cog"
                        

#line 1489 "check.cog"
            CheckContext

#line 1489 "check.cog"
                        * context, 

#line 1490 "check.cog"
            Exp exp, 

#line 1491 "check.cog"
             Type type);


#line 1536 "check.cog"
 void issueTooFewArgsError(

#line 1537 "check.cog"
                                 

#line 1537 "check.cog"
           OverloadResolveContext

#line 1537 "check.cog"
                                 * context);


#line 1547 "check.cog"
 void issueTooManyArgsError(

#line 1548 "check.cog"
                                 

#line 1548 "check.cog"
           OverloadResolveContext

#line 1548 "check.cog"
                                 * context);


#line 1558 "check.cog"
 

#line 1561 "check.cog"
        Bool checkOverloadCandidateArity(

#line 1559 "check.cog"
                                 

#line 1559 "check.cog"
           OverloadResolveContext

#line 1559 "check.cog"
                                 * context, 

#line 1560 "check.cog"
                   

#line 1560 "check.cog"
                Ref<

#line 1560 "check.cog"
                    OverloadCandidate>  candidate);


#line 1630 "check.cog"
 

#line 1633 "check.cog"
        Bool checkOverloadCandidateTypes(

#line 1631 "check.cog"
                                 

#line 1631 "check.cog"
           OverloadResolveContext

#line 1631 "check.cog"
                                 * context, 

#line 1632 "check.cog"
                   

#line 1632 "check.cog"
                Ref<

#line 1632 "check.cog"
                    OverloadCandidate>  candidate);


#line 1743 "check.cog"
 

#line 1746 "check.cog"
        Bool checkOverloadCandidateDirections(

#line 1744 "check.cog"
                                    

#line 1744 "check.cog"
              OverloadResolveContext

#line 1744 "check.cog"
                                    * context, 

#line 1745 "check.cog"
                   

#line 1745 "check.cog"
                Ref<

#line 1745 "check.cog"
                    OverloadCandidate>  candidate);


#line 1751 "check.cog"
 void checkOverloadCandidateImpl(

#line 1752 "check.cog"
                                    

#line 1752 "check.cog"
              OverloadResolveContext

#line 1752 "check.cog"
                                    * context, 

#line 1753 "check.cog"
                   

#line 1753 "check.cog"
                Ref<

#line 1753 "check.cog"
                    OverloadCandidate>  candidate);


#line 1770 "check.cog"
 void checkOverloadCandidate(

#line 1771 "check.cog"
                                    

#line 1771 "check.cog"
              OverloadResolveContext

#line 1771 "check.cog"
                                    * context, 

#line 1772 "check.cog"
                   

#line 1772 "check.cog"
                Ref<

#line 1772 "check.cog"
                    OverloadCandidate>  candidate);


#line 1778 "check.cog"
 

#line 1781 "check.cog"
        Int compareCandidates(

#line 1779 "check.cog"
           

#line 1779 "check.cog"
        Ref<

#line 1779 "check.cog"
            OverloadCandidate>  left, 

#line 1780 "check.cog"
            

#line 1780 "check.cog"
         Ref<

#line 1780 "check.cog"
             OverloadCandidate>  right);


#line 1793 "check.cog"
 void addCheckedOverloadCandidate(

#line 1794 "check.cog"
                                    

#line 1794 "check.cog"
              OverloadResolveContext

#line 1794 "check.cog"
                                    * context, 

#line 1795 "check.cog"
                   

#line 1795 "check.cog"
                Ref<

#line 1795 "check.cog"
                    OverloadCandidate>  candidate);


#line 1848 "check.cog"
 void addOverloadCandidate(

#line 1849 "check.cog"
                                    

#line 1849 "check.cog"
              OverloadResolveContext

#line 1849 "check.cog"
                                    * context, 

#line 1850 "check.cog"
                   

#line 1850 "check.cog"
                Ref<

#line 1850 "check.cog"
                    OverloadCandidate>  candidate);


#line 1856 "check.cog"
 void addSubscriptOverloadCandidate(

#line 1857 "check.cog"
                                    

#line 1857 "check.cog"
              OverloadResolveContext

#line 1857 "check.cog"
                                    * context, 

#line 1858 "check.cog"
                            

#line 1858 "check.cog"
              DeclRefValImpl<

#line 1858 "check.cog"
                             SubscriptDecl>  declRef);


#line 1871 "check.cog"
 void addFuncOverloadCandidate(

#line 1872 "check.cog"
                                    

#line 1872 "check.cog"
              OverloadResolveContext

#line 1872 "check.cog"
                                    * context, 

#line 1873 "check.cog"
                            

#line 1873 "check.cog"
              DeclRefValImpl<

#line 1873 "check.cog"
                             FuncDeclBase>  declRef);


#line 1884 "check.cog"
 void addInitializerOverloadCandidate(

#line 1885 "check.cog"
                                     

#line 1885 "check.cog"
               OverloadResolveContext

#line 1885 "check.cog"
                                     * context, 

#line 1886 "check.cog"
             Type type, 

#line 1887 "check.cog"
                             

#line 1887 "check.cog"
               DeclRefValImpl<

#line 1887 "check.cog"
                              InitializerDecl>  declRef);


#line 1895 "check.cog"
 

#line 1900 "check.cog"
        Exp createDeclRefExp(

#line 1896 "check.cog"
                       

#line 1896 "check.cog"
           CheckContext

#line 1896 "check.cog"
                       * context, 

#line 1897 "check.cog"
           CompactDeclRef declRef, 

#line 1898 "check.cog"
       SourceLoc loc, 

#line 1899 "check.cog"
           Exp baseExp);


#line 1920 "check.cog"
 

#line 1925 "check.cog"
        Exp createDeclRefExp(

#line 1921 "check.cog"
                       

#line 1921 "check.cog"
           CheckContext

#line 1921 "check.cog"
                       * context, 

#line 1922 "check.cog"
           DeclRefVal declRef, 

#line 1923 "check.cog"
       SourceLoc loc, 

#line 1924 "check.cog"
           Exp baseExp);


#line 1944 "check.cog"
 

#line 1948 "check.cog"
        Exp createDeclRefExp(

#line 1945 "check.cog"
                       

#line 1945 "check.cog"
           CheckContext

#line 1945 "check.cog"
                       * context, 

#line 1946 "check.cog"
           DeclRefVal declRef, 

#line 1947 "check.cog"
       SourceLoc loc);


#line 1953 "check.cog"
 

#line 1956 "check.cog"
     Val getGenericArgVal(

#line 1954 "check.cog"
                       

#line 1954 "check.cog"
           CheckContext

#line 1954 "check.cog"
                       * context, 

#line 1955 "check.cog"
        Exp expr);


#line 1973 "check.cog"
 

#line 1976 "check.cog"
     Exp completeOverloadCandidate(

#line 1974 "check.cog"
                                         

#line 1974 "check.cog"
                   OverloadResolveContext

#line 1974 "check.cog"
                                         * overloadContext, 

#line 1975 "check.cog"
                              

#line 1975 "check.cog"
             OverloadCandidate

#line 1975 "check.cog"
                              * candidate);


#line 2030 "check.cog"
 

#line 2032 "check.cog"
        Exp completeOverload(

#line 2031 "check.cog"
                                            

#line 2031 "check.cog"
                      OverloadResolveContext

#line 2031 "check.cog"
                                            * overloadContext);


#line 2118 "check.cog"
 

#line 2120 "check.cog"
        Bool isError(

#line 2119 "check.cog"
        Type type);


#line 2125 "check.cog"
 

#line 2128 "check.cog"
        Bool isError(

#line 2126 "check.cog"
                       

#line 2126 "check.cog"
           CheckContext

#line 2126 "check.cog"
                       * context, 

#line 2127 "check.cog"
       Exp exp);


#line 2133 "check.cog"
 void addTypeOverloadCandidates(

#line 2134 "check.cog"
                                 

#line 2134 "check.cog"
           OverloadResolveContext

#line 2134 "check.cog"
                                 * context, 

#line 2135 "check.cog"
           Exp typeExp, 

#line 2136 "check.cog"
        Type type);


#line 2156 "check.cog"
 struct GenericInferenceArg
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 2158 "check.cog"
  

#line 2158 "check.cog"
                                  

#line 2158 "check.cog"
                    DeclRefValImpl<

#line 2158 "check.cog"
                                   GenericParamDecl>  paramDeclRef;


#line 2159 "check.cog"
  

#line 2159 "check.cog"
           Val val = 

#line 2159 "check.cog"
                 nullptr;
};


#line 2162 "check.cog"
 struct GenericInferenceContext
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 2164 "check.cog"
  

#line 2164 "check.cog"
                                

#line 2164 "check.cog"
                    CheckContext

#line 2164 "check.cog"
                                * checkContext;


#line 2165 "check.cog"
  

#line 2165 "check.cog"
                               

#line 2165 "check.cog"
            GenericInferenceArg

#line 2165 "check.cog"
                               * args;


#line 2166 "check.cog"
  

#line 2166 "check.cog"
                Int argCount;
};


#line 2169 "check.cog"
 

#line 2173 "check.cog"
        Bool doInferenceForVals(

#line 2170 "check.cog"
                                  

#line 2170 "check.cog"
           GenericInferenceContext

#line 2170 "check.cog"
                                  * context, 

#line 2171 "check.cog"
          Val argVal, 

#line 2172 "check.cog"
            Val paramVal);


#line 2187 "check.cog"
 

#line 2191 "check.cog"
        Bool doInferenceForSpecializations(

#line 2188 "check.cog"
                                  

#line 2188 "check.cog"
           GenericInferenceContext

#line 2188 "check.cog"
                                  * context, 

#line 2189 "check.cog"
              Specializations argSpec, 

#line 2190 "check.cog"
                Specializations paramSpec);


#line 2225 "check.cog"
 

#line 2229 "check.cog"
        Bool doInferenceForDeclRefs(

#line 2226 "check.cog"
                                    

#line 2226 "check.cog"
             GenericInferenceContext

#line 2226 "check.cog"
                                    * context, 

#line 2227 "check.cog"
                  DeclRefVal argDeclRef, 

#line 2228 "check.cog"
                    DeclRefVal paramDeclRef);


#line 2246 "check.cog"
 

#line 2249 "check.cog"
                        

#line 2249 "check.cog"
     GenericInferenceArg

#line 2249 "check.cog"
                        * findGenericInferenceArg(

#line 2247 "check.cog"
                                  

#line 2247 "check.cog"
           GenericInferenceContext

#line 2247 "check.cog"
                                  * context, 

#line 2248 "check.cog"
                              

#line 2248 "check.cog"
                DeclRefValImpl<

#line 2248 "check.cog"
                               GenericParamDecl>  paramDeclRef);


#line 2259 "check.cog"
 

#line 2263 "check.cog"
        Bool doInferenceForTypes(

#line 2260 "check.cog"
                                     

#line 2260 "check.cog"
              GenericInferenceContext

#line 2260 "check.cog"
                                     * context, 

#line 2261 "check.cog"
              Type argType, 

#line 2262 "check.cog"
                Type paramType);


#line 2304 "check.cog"
 

#line 2308 "check.cog"
        Bool doInferenceForArgAndParam(

#line 2305 "check.cog"
                                     

#line 2305 "check.cog"
              GenericInferenceContext

#line 2305 "check.cog"
                                     * context, 

#line 2306 "check.cog"
              Exp argExpr, 

#line 2307 "check.cog"
                                 

#line 2307 "check.cog"
                   DeclRefValImpl<

#line 2307 "check.cog"
                                  ParamDecl>  paramDeclRef);


#line 2316 "check.cog"
 

#line 2320 "check.cog"
        Specializations inferGenericArgsForApp(

#line 2317 "check.cog"
                          

#line 2317 "check.cog"
              CheckContext

#line 2317 "check.cog"
                          * context, 

#line 2318 "check.cog"
                                   

#line 2318 "check.cog"
                     DeclRefValImpl<

#line 2318 "check.cog"
                                    GenericDecl>  genericDeclRef, 

#line 2319 "check.cog"
              AppExpBase appExpr);


#line 2416 "check.cog"
 void addGenericOverloadCandidate(

#line 2417 "check.cog"
                                    

#line 2417 "check.cog"
              OverloadResolveContext

#line 2417 "check.cog"
                                    * context, 

#line 2418 "check.cog"
                                   

#line 2418 "check.cog"
                     DeclRefValImpl<

#line 2418 "check.cog"
                                    GenericDecl>  genericDeclRef);


#line 2447 "check.cog"
 void addDeclRefOverloadCandidates(

#line 2448 "check.cog"
                                    

#line 2448 "check.cog"
              OverloadResolveContext

#line 2448 "check.cog"
                                    * context, 

#line 2449 "check.cog"
          DeclRefVal val);


#line 2467 "check.cog"
 

#line 2470 "check.cog"
     Val specializeVal(

#line 2468 "check.cog"
       Val val, 

#line 2469 "check.cog"
                   Specializations specializations);


#line 2481 "check.cog"
 

#line 2484 "check.cog"
     Val findSpecialization(

#line 2482 "check.cog"
                   Specializations specializations, 

#line 2483 "check.cog"
           Decl decl);


#line 2497 "check.cog"
 

#line 2500 "check.cog"
     DeclRefVal specializeDeclRef(

#line 2498 "check.cog"
           DeclRefVal declRef, 

#line 2499 "check.cog"
                   Specializations specializations);


#line 2542 "check.cog"
 

#line 2545 "check.cog"
     Type specializeType(

#line 2543 "check.cog"
        Type type, 

#line 2544 "check.cog"
                   Specializations specializations);


#line 166 "syntax.cog"
 enum DeclCheckState : int
{
kDeclCheckState_Unchecked = 

#line 168 "syntax.cog"
                              0,
kDeclCheckState_CheckingHead,
kDeclCheckState_CheckedHead,
kDeclCheckState_Checked,
};


#line 2567 "check.cog"
 void ensureDecl(

#line 2568 "check.cog"
                       

#line 2568 "check.cog"
           CheckContext

#line 2568 "check.cog"
                       * context, 

#line 2569 "check.cog"
        Decl decl, 

#line 2570 "check.cog"
         DeclCheckState state);


#line 2578 "check.cog"
 void ensureDecl(

#line 2579 "check.cog"
                       

#line 2579 "check.cog"
           CheckContext

#line 2579 "check.cog"
                       * context, 

#line 2580 "check.cog"
        Decl decl);


#line 3 "diagnostic.cog"
 

#line 5 "diagnostic.cog"
 enum Severity : int
{
kSeverity_Note,
kSeverity_Warning,
kSeverity_Error,
kSeverity_Fatal,
};


#line 13 "diagnostic.cog"
 enum DiagnosticID : int
{
kDiagnostic_unimplemented,
kDiagnostic_unexpectedCharacter,
kDiagnostic_unexpectedToken,
kDiagnostic_unexpectedTokenExpectedToken,
kDiagnostic_youMeanDot,
kDiagnostic_unexpectedDeclName,
kDiagnostic_undefinedIdentifier,
kDiagnostic_noMemberOfNameInType,
kDiagnostic_failedToFindBuiltinType,
kDiagnostic_cannotConvertType,
kDiagnostic_noOverloadCandidatesFound,
kDiagnostic_candidate,
kDiagnostic_ambiguousCallToOverload,
kDiagnostic_noApplicableOverloadForCall,
kDiagnostic_tooFewArgs,
kDiagnostic_tooManyArgs,
};


#line 44 "diagnostic.cog"
 struct ArgTypeList
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 46 "diagnostic.cog"
  

#line 46 "diagnostic.cog"
                  

#line 46 "diagnostic.cog"
             Array<

#line 46 "diagnostic.cog"
                   Arg>  args;


#line 48 "diagnostic.cog"
  ArgTypeList();


#line 53 "diagnostic.cog"
  ArgTypeList(

#line 53 "diagnostic.cog"
                  

#line 53 "diagnostic.cog"
             Array<

#line 53 "diagnostic.cog"
                   Arg>  args);
};


#line 59 "diagnostic.cog"
 enum DiagnosticArgFlavor : int
{
kFlavor_Int,
kFlavor_TokenCode,
kFlavor_Name,
kFlavor_StringSpan,
kFlavor_Type,
kFlavor_DeclRef,
kFlavor_ArgTypeList,
};


#line 14 "token.cog"
 enum TokenCode : int
{
kTokenCode_Invalid,
kTokenCode_EndOfFile,
kTokenCode_Identifier,
kTokenCode_InfixOperator,
kTokenCode_PrefixOperator,
kTokenCode_PostfixOperator,
kTokenCode_LineComment,
kTokenCode_BlockComment,
kTokenCode_WhiteSpace,
kTokenCode_EndOfLine,
kTokenCode_IntegerLiteral,
kTokenCode_FloatingPointLiteral,
kTokenCode_StringLiteral,
kTokenCode_CharacterLiteral,
kTokenCode_LSquare,
kTokenCode_RSquare,
kTokenCode_Assign,
kTokenCode_Arrow,
kTokenCode_LParen,
kTokenCode_RParen,
kTokenCode_LCurly,
kTokenCode_RCurly,
kTokenCode_Semi,
kTokenCode_Colon,
kTokenCode_Comma,
kTokenCode_Dot,
};


#line 70 "diagnostic.cog"
 struct DiagnosticArg
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 72 "diagnostic.cog"
  DiagnosticArg(

#line 72 "diagnostic.cog"
            Int val);


#line 78 "diagnostic.cog"
  DiagnosticArg(

#line 78 "diagnostic.cog"
            TokenCode val);


#line 84 "diagnostic.cog"
  DiagnosticArg(

#line 84 "diagnostic.cog"
               

#line 84 "diagnostic.cog"
            Ptr<

#line 84 "diagnostic.cog"
                Name>  val);


#line 90 "diagnostic.cog"
  DiagnosticArg(

#line 90 "diagnostic.cog"
            StringSpan val);


#line 98 "diagnostic.cog"
  DiagnosticArg(

#line 98 "diagnostic.cog"
                    

#line 98 "diagnostic.cog"
            ConstPtr<

#line 98 "diagnostic.cog"
                     Char>  val);


#line 104 "diagnostic.cog"
  DiagnosticArg(

#line 104 "diagnostic.cog"
            Type val);


#line 110 "diagnostic.cog"
  DiagnosticArg(

#line 110 "diagnostic.cog"
            DeclRefVal val);


#line 116 "diagnostic.cog"
  DiagnosticArg(

#line 116 "diagnostic.cog"
                    

#line 116 "diagnostic.cog"
            ConstRef<

#line 116 "diagnostic.cog"
                     ArgTypeList>  val);


#line 122 "diagnostic.cog"
  

#line 122 "diagnostic.cog"
              DiagnosticArgFlavor flavor;


#line 124 "diagnostic.cog"
   

#line 124 "diagnostic.cog"
               Int intVal;


#line 125 "diagnostic.cog"
   

#line 125 "diagnostic.cog"
                     TokenCode tokenCodeVal;


#line 126 "diagnostic.cog"
   

#line 126 "diagnostic.cog"
                    

#line 126 "diagnostic.cog"
                 Ptr<

#line 126 "diagnostic.cog"
                     Name>  nameVal;


#line 127 "diagnostic.cog"
   

#line 127 "diagnostic.cog"
                       StringSpan stringSpanVal;


#line 128 "diagnostic.cog"
   

#line 128 "diagnostic.cog"
                 Type typeVal;


#line 130 "diagnostic.cog"
   

#line 130 "diagnostic.cog"
                    DeclRefVal declRefVal;


#line 131 "diagnostic.cog"
   

#line 131 "diagnostic.cog"
                        ArgTypeList argTypeListVal;
};


#line 135 "diagnostic.cog"
 void diagnose(

#line 136 "diagnostic.cog"
           

#line 136 "diagnostic.cog"
        Ptr<

#line 136 "diagnostic.cog"
            DiagnosticSink>  sink, 

#line 137 "diagnostic.cog"
       SourceLoc loc, 

#line 138 "diagnostic.cog"
      DiagnosticID id);


#line 143 "diagnostic.cog"
 void diagnose(

#line 144 "diagnostic.cog"
           

#line 144 "diagnostic.cog"
        Ptr<

#line 144 "diagnostic.cog"
            DiagnosticSink>  sink, 

#line 145 "diagnostic.cog"
       SourceLoc loc, 

#line 146 "diagnostic.cog"
      DiagnosticID id, 

#line 147 "diagnostic.cog"
        DiagnosticArg arg0);


#line 154 "diagnostic.cog"
 void diagnose(

#line 155 "diagnostic.cog"
           

#line 155 "diagnostic.cog"
        Ptr<

#line 155 "diagnostic.cog"
            DiagnosticSink>  sink, 

#line 156 "diagnostic.cog"
       SourceLoc loc, 

#line 157 "diagnostic.cog"
      DiagnosticID id, 

#line 158 "diagnostic.cog"
        DiagnosticArg arg0, 

#line 159 "diagnostic.cog"
        DiagnosticArg arg1);


#line 232 "diagnostic.cog"
 void printVal(

#line 233 "diagnostic.cog"
              

#line 233 "diagnostic.cog"
          FILE

#line 233 "diagnostic.cog"
              * stream, 

#line 234 "diagnostic.cog"
       Val val);


#line 246 "diagnostic.cog"
 void printDeclRef(

#line 247 "diagnostic.cog"
              

#line 247 "diagnostic.cog"
          FILE

#line 247 "diagnostic.cog"
              * stream, 

#line 248 "diagnostic.cog"
           DeclRefVal declRef);


#line 271 "diagnostic.cog"
 void printType(

#line 272 "diagnostic.cog"
              

#line 272 "diagnostic.cog"
          FILE

#line 272 "diagnostic.cog"
              * stream, 

#line 273 "diagnostic.cog"
        Type type);


#line 307 "diagnostic.cog"
 void printDiagnosticArg(

#line 308 "diagnostic.cog"
               

#line 308 "diagnostic.cog"
       ConstPtr<

#line 308 "diagnostic.cog"
                DiagnosticArg>  arg);


#line 366 "diagnostic.cog"
 void diagnoseImpl(

#line 367 "diagnostic.cog"
           

#line 367 "diagnostic.cog"
        Ptr<

#line 367 "diagnostic.cog"
            DiagnosticSink>  sink, 

#line 368 "diagnostic.cog"
       SourceLoc loc, 

#line 369 "diagnostic.cog"
      DiagnosticID id, 

#line 370 "diagnostic.cog"
            int argCount, 

#line 371 "diagnostic.cog"
           

#line 371 "diagnostic.cog"
        Ptr<

#line 371 "diagnostic.cog"
               

#line 371 "diagnostic.cog"
            Ptr<

#line 371 "diagnostic.cog"
                DiagnosticArg> >  args);


#line 3 "emit.cog"
 

#line 5 "emit.cog"
 struct EmitContext
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 7 "emit.cog"
  

#line 7 "emit.cog"
               Session session;


#line 8 "emit.cog"
  

#line 8 "emit.cog"
                  

#line 8 "emit.cog"
              FILE

#line 8 "emit.cog"
                  * stream;


#line 9 "emit.cog"
  

#line 9 "emit.cog"
                              Int suppressLineDirective;
};


#line 12 "emit.cog"
 

#line 12 "emit.cog"
                                                      

#line 12 "emit.cog"
                                        DiagnosticSink

#line 12 "emit.cog"
                                                      * getSink(

#line 12 "emit.cog"
                                  

#line 12 "emit.cog"
                       EmitContext

#line 12 "emit.cog"
                                  * context);


#line 17 "emit.cog"
 enum DeclEmitMode : int
{
kDeclEmitMode_MinimalForward,
kDeclEmitMode_Forward,
kDeclEmitMode_Full,
};


#line 24 "emit.cog"
 void emit(

#line 25 "emit.cog"
                      

#line 25 "emit.cog"
           EmitContext

#line 25 "emit.cog"
                      * context, 

#line 26 "emit.cog"
        StringSpan text);


#line 31 "emit.cog"
 void emit(

#line 32 "emit.cog"
                      

#line 32 "emit.cog"
           EmitContext

#line 32 "emit.cog"
                      * context, 

#line 33 "emit.cog"
            

#line 33 "emit.cog"
        Char

#line 33 "emit.cog"
            * text);


#line 38 "emit.cog"
 void emit(

#line 39 "emit.cog"
                      

#line 39 "emit.cog"
           EmitContext

#line 39 "emit.cog"
                      * context, 

#line 40 "emit.cog"
            

#line 40 "emit.cog"
        Name

#line 40 "emit.cog"
            * name);


#line 45 "emit.cog"
 void emitType(

#line 46 "emit.cog"
                      

#line 46 "emit.cog"
           EmitContext

#line 46 "emit.cog"
                      * context, 

#line 47 "emit.cog"
        Exp type);


#line 58 "emit.cog"
 void emitVal(

#line 59 "emit.cog"
                         

#line 59 "emit.cog"
              EmitContext

#line 59 "emit.cog"
                         * context, 

#line 60 "emit.cog"
          Val val);


#line 68 "emit.cog"
 void emitGenericQuals(

#line 69 "emit.cog"
                      

#line 69 "emit.cog"
           EmitContext

#line 69 "emit.cog"
                      * context, 

#line 70 "emit.cog"
        Decl decl);


#line 99 "emit.cog"
 void emitDeclName(

#line 100 "emit.cog"
                      

#line 100 "emit.cog"
           EmitContext

#line 100 "emit.cog"
                      * context, 

#line 101 "emit.cog"
        Decl decl, 

#line 102 "emit.cog"
        DeclEmitMode mode, 

#line 103 "emit.cog"
                 Bool includeModule);


#line 144 "emit.cog"
 void emitDeclName(

#line 145 "emit.cog"
                      

#line 145 "emit.cog"
           EmitContext

#line 145 "emit.cog"
                      * context, 

#line 146 "emit.cog"
        Decl decl, 

#line 147 "emit.cog"
        DeclEmitMode mode);


#line 152 "emit.cog"
 void emitDeclNameAndGenericArgs(

#line 153 "emit.cog"
                      

#line 153 "emit.cog"
           EmitContext

#line 153 "emit.cog"
                      * context, 

#line 154 "emit.cog"
        Decl decl, 

#line 155 "emit.cog"
        DeclEmitMode mode);


#line 187 "emit.cog"
 void emitDeclarator(

#line 188 "emit.cog"
                      

#line 188 "emit.cog"
           EmitContext

#line 188 "emit.cog"
                      * context, 

#line 189 "emit.cog"
        Exp type, 

#line 190 "emit.cog"
        Decl decl, 

#line 191 "emit.cog"
        DeclEmitMode mode);


#line 199 "emit.cog"
 void emitDeclarator(

#line 200 "emit.cog"
                      

#line 200 "emit.cog"
           EmitContext

#line 200 "emit.cog"
                      * context, 

#line 201 "emit.cog"
        TypeExp type, 

#line 202 "emit.cog"
        Decl decl, 

#line 203 "emit.cog"
        DeclEmitMode mode);


#line 210 "emit.cog"
 void emitBinaryExp(

#line 211 "emit.cog"
                         

#line 211 "emit.cog"
              EmitContext

#line 211 "emit.cog"
                         * context, 

#line 212 "emit.cog"
          AppExpBase exp, 

#line 213 "emit.cog"
             

#line 213 "emit.cog"
         Char

#line 213 "emit.cog"
             * op);


#line 222 "emit.cog"
 void emitStringVal(

#line 223 "emit.cog"
                         

#line 223 "emit.cog"
              EmitContext

#line 223 "emit.cog"
                         * context, 

#line 224 "emit.cog"
          StringSpan str);


#line 252 "emit.cog"
 void emitStringVal(

#line 253 "emit.cog"
                         

#line 253 "emit.cog"
              EmitContext

#line 253 "emit.cog"
                         * context, 

#line 254 "emit.cog"
          String str);


#line 260 "emit.cog"
 void emitExp(

#line 261 "emit.cog"
                         

#line 261 "emit.cog"
              EmitContext

#line 261 "emit.cog"
                         * context, 

#line 262 "emit.cog"
       Exp exp);


#line 392 "emit.cog"
 void emitBlockStmt(

#line 393 "emit.cog"
                      

#line 393 "emit.cog"
           EmitContext

#line 393 "emit.cog"
                      * context, 

#line 394 "emit.cog"
        BlockStmt stmt);


#line 404 "emit.cog"
 void emitBlockStmt(

#line 405 "emit.cog"
                         

#line 405 "emit.cog"
              EmitContext

#line 405 "emit.cog"
                         * context, 

#line 406 "emit.cog"
        Stmt stmt);


#line 420 "emit.cog"
 void emit(

#line 421 "emit.cog"
                      

#line 421 "emit.cog"
           EmitContext

#line 421 "emit.cog"
                      * context, 

#line 422 "emit.cog"
         Int value);


#line 429 "emit.cog"
 void emitLineDirective(

#line 430 "emit.cog"
                      

#line 430 "emit.cog"
           EmitContext

#line 430 "emit.cog"
                      * context, 

#line 431 "emit.cog"
       Syntax syn);


#line 457 "emit.cog"
 void emitStmt(

#line 458 "emit.cog"
                      

#line 458 "emit.cog"
           EmitContext

#line 458 "emit.cog"
                      * context, 

#line 459 "emit.cog"
        Stmt stmt);


#line 594 "emit.cog"
 void emitClassDecl(

#line 595 "emit.cog"
                      

#line 595 "emit.cog"
           EmitContext

#line 595 "emit.cog"
                      * context, 

#line 596 "emit.cog"
              ClassDecl aggDecl, 

#line 597 "emit.cog"
        DeclEmitMode mode);


#line 664 "emit.cog"
 void emitStructDecl(

#line 665 "emit.cog"
                      

#line 665 "emit.cog"
           EmitContext

#line 665 "emit.cog"
                      * context, 

#line 666 "emit.cog"
              StructDecl aggDecl, 

#line 667 "emit.cog"
        DeclEmitMode mode);


#line 708 "emit.cog"
 void emitVarDecl(

#line 709 "emit.cog"
                      

#line 709 "emit.cog"
           EmitContext

#line 709 "emit.cog"
                      * context, 

#line 710 "emit.cog"
           VarDeclBase varDecl, 

#line 711 "emit.cog"
        DeclEmitMode mode);


#line 733 "emit.cog"
 void emitParamDecl(

#line 734 "emit.cog"
                      

#line 734 "emit.cog"
           EmitContext

#line 734 "emit.cog"
                      * context, 

#line 735 "emit.cog"
             ParamDecl paramDecl);


#line 740 "emit.cog"
 void emitFuncDecl(

#line 741 "emit.cog"
                      

#line 741 "emit.cog"
           EmitContext

#line 741 "emit.cog"
                      * context, 

#line 742 "emit.cog"
            FuncDecl funcDecl, 

#line 743 "emit.cog"
        DeclEmitMode mode);


#line 793 "emit.cog"
 void emitInitializerDecl(

#line 794 "emit.cog"
                         

#line 794 "emit.cog"
              EmitContext

#line 794 "emit.cog"
                         * context, 

#line 795 "emit.cog"
               InitializerDecl initDecl, 

#line 796 "emit.cog"
        DeclEmitMode mode);


#line 850 "emit.cog"
 void emitSubscriptDecl(

#line 851 "emit.cog"
                      

#line 851 "emit.cog"
           EmitContext

#line 851 "emit.cog"
                      * context, 

#line 852 "emit.cog"
        SubscriptDecl decl, 

#line 853 "emit.cog"
        DeclEmitMode mode);


#line 911 "emit.cog"
 void emitDecl(

#line 912 "emit.cog"
                      

#line 912 "emit.cog"
           EmitContext

#line 912 "emit.cog"
                      * context, 

#line 913 "emit.cog"
        Decl decl, 

#line 914 "emit.cog"
        DeclEmitMode mode);


#line 1032 "emit.cog"
 void emitDecls(

#line 1033 "emit.cog"
                      

#line 1033 "emit.cog"
           EmitContext

#line 1033 "emit.cog"
                      * context, 

#line 1034 "emit.cog"
                 ContainerDecl containerDecl, 

#line 1035 "emit.cog"
        DeclEmitMode mode);


#line 1043 "emit.cog"
 struct DeclSortContext
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 1045 "emit.cog"
  

#line 1045 "emit.cog"
                        

#line 1045 "emit.cog"
                   Array<

#line 1045 "emit.cog"
                         Decl>  sortedDecls;


#line 1046 "emit.cog"
  

#line 1046 "emit.cog"
                          

#line 1046 "emit.cog"
                     Array<

#line 1046 "emit.cog"
                           Decl>  unsortedDecls;
};


#line 1049 "emit.cog"
 void addDecl(

#line 1050 "emit.cog"
                          

#line 1050 "emit.cog"
           DeclSortContext

#line 1050 "emit.cog"
                          * context, 

#line 1051 "emit.cog"
        Decl decl);


#line 1056 "emit.cog"
 void addDependencies(

#line 1057 "emit.cog"
                          

#line 1057 "emit.cog"
           DeclSortContext

#line 1057 "emit.cog"
                          * context, 

#line 1058 "emit.cog"
        Decl decl);


#line 1060 "emit.cog"
 void addDependencies(

#line 1061 "emit.cog"
                          

#line 1061 "emit.cog"
           DeclSortContext

#line 1061 "emit.cog"
                          * context, 

#line 1062 "emit.cog"
            

#line 1062 "emit.cog"
        Name

#line 1062 "emit.cog"
            * name);


#line 1106 "emit.cog"
 void addDependencies(

#line 1107 "emit.cog"
                          

#line 1107 "emit.cog"
           DeclSortContext

#line 1107 "emit.cog"
                          * context, 

#line 1108 "emit.cog"
       Exp exp);


#line 1136 "emit.cog"
 void addDependencies(

#line 1137 "emit.cog"
                          

#line 1137 "emit.cog"
           DeclSortContext

#line 1137 "emit.cog"
                          * context, 

#line 1138 "emit.cog"
           TypeExp typeExp);


#line 1143 "emit.cog"
 void addDependencies(

#line 1144 "emit.cog"
                          

#line 1144 "emit.cog"
           DeclSortContext

#line 1144 "emit.cog"
                          * context, 

#line 1145 "emit.cog"
        Decl decl);


#line 1171 "emit.cog"
 void sortDecls(

#line 1172 "emit.cog"
                      

#line 1172 "emit.cog"
           EmitContext

#line 1172 "emit.cog"
                      * context, 

#line 1173 "emit.cog"
             ContainerDecl container);


#line 1193 "emit.cog"
 void emitModuleInner(

#line 1194 "emit.cog"
             Session session, 

#line 1195 "emit.cog"
                  TerminatedStringSpan moduleNameText, 

#line 1196 "emit.cog"
                  

#line 1196 "emit.cog"
               Ptr<

#line 1196 "emit.cog"
                   Char>  outputPath, 

#line 1197 "emit.cog"
              

#line 1197 "emit.cog"
           Ptr<

#line 1197 "emit.cog"
               Char>  extra);


#line 1285 "emit.cog"
 void emitModule(

#line 1286 "emit.cog"
           Session session);


#line 3 "eval.cog"
 

#line 6 "eval.cog"
 void evalModule(

#line 7 "eval.cog"
           Session session);


#line 3 "lexer.cog"
 

#line 26 "source.cog"
 struct SourceFile
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 29 "source.cog"
  

#line 29 "source.cog"
                

#line 29 "source.cog"
             Ptr<

#line 29 "source.cog"
                 SourceFile>  next;


#line 32 "source.cog"
  

#line 32 "source.cog"
             TerminatedStringSpan path;


#line 35 "source.cog"
  

#line 35 "source.cog"
             TerminatedStringSpan text;


#line 38 "source.cog"
  

#line 38 "source.cog"
                 SourceLoc firstLoc;


#line 39 "source.cog"
  

#line 39 "source.cog"
                SourceLoc lastLoc;
};


#line 5 "token.cog"
 typedef 

#line 5 "token.cog"
                        UInt16 TokenFlags;


#line 5 "lexer.cog"
 struct Lexer
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 7 "lexer.cog"
  

#line 7 "lexer.cog"
               Session session;


#line 8 "lexer.cog"
  

#line 8 "lexer.cog"
                      

#line 8 "lexer.cog"
            SourceFile

#line 8 "lexer.cog"
                      * file;


#line 10 "lexer.cog"
  

#line 10 "lexer.cog"
                      

#line 10 "lexer.cog"
              ConstPtr<

#line 10 "lexer.cog"
                       Char>  cursor;


#line 11 "lexer.cog"
  

#line 11 "lexer.cog"
                   UIntPtr rawStartPtr;


#line 12 "lexer.cog"
  

#line 12 "lexer.cog"
                  TokenFlags tokenFlags;
};


#line 15 "lexer.cog"
 void initializeLexer(

#line 16 "lexer.cog"
              

#line 16 "lexer.cog"
         Lexer

#line 16 "lexer.cog"
              * lexer, 

#line 17 "lexer.cog"
           Session session, 

#line 18 "lexer.cog"
                  

#line 18 "lexer.cog"
        SourceFile

#line 18 "lexer.cog"
                  * file);


#line 31 "lexer.cog"
 void finalizeLexer(

#line 32 "lexer.cog"
              

#line 32 "lexer.cog"
         Lexer

#line 32 "lexer.cog"
              * lexer);


#line 36 "lexer.cog"
 

#line 38 "lexer.cog"
                   

#line 38 "lexer.cog"
     DiagnosticSink

#line 38 "lexer.cog"
                   * getSink(

#line 37 "lexer.cog"
              

#line 37 "lexer.cog"
         Lexer

#line 37 "lexer.cog"
              * lexer);


#line 43 "lexer.cog"
 

#line 43 "lexer.cog"
                                 Int peekByte(

#line 43 "lexer.cog"
                           

#line 43 "lexer.cog"
                      Lexer

#line 43 "lexer.cog"
                           * lexer);


#line 48 "lexer.cog"
 

#line 48 "lexer.cog"
                                      Int peekCodePoint(

#line 48 "lexer.cog"
                                

#line 48 "lexer.cog"
                           Lexer

#line 48 "lexer.cog"
                                * lexer);


#line 54 "lexer.cog"
 

#line 54 "lexer.cog"
                                SourceLoc peekLoc(

#line 54 "lexer.cog"
                          

#line 54 "lexer.cog"
                     Lexer

#line 54 "lexer.cog"
                          * lexer);


#line 61 "lexer.cog"
 void advanceByte(

#line 61 "lexer.cog"
                              

#line 61 "lexer.cog"
                         Lexer

#line 61 "lexer.cog"
                              * lexer);


#line 67 "lexer.cog"
 

#line 67 "lexer.cog"
                         Bool isAlpha(

#line 67 "lexer.cog"
                 Int c);


#line 74 "lexer.cog"
 

#line 74 "lexer.cog"
                         Bool isDigit(

#line 74 "lexer.cog"
                 Int c);


#line 79 "lexer.cog"
 

#line 79 "lexer.cog"
                            Bool isAlphaNum(

#line 79 "lexer.cog"
                    Int c);


#line 84 "lexer.cog"
 

#line 84 "lexer.cog"
                                Bool isOperatorChar(

#line 84 "lexer.cog"
                        Int c);


#line 89 "lexer.cog"
 

#line 89 "lexer.cog"
                              Bool isWhiteSpace(

#line 89 "lexer.cog"
                      Int c);


#line 94 "lexer.cog"
 void lexDigits(

#line 95 "lexer.cog"
                 

#line 95 "lexer.cog"
            Lexer

#line 95 "lexer.cog"
                 * lexer, 

#line 96 "lexer.cog"
           Int base);


#line 123 "lexer.cog"
 

#line 126 "lexer.cog"
     Bool peekNumberExponentMarker(

#line 124 "lexer.cog"
                 

#line 124 "lexer.cog"
            Lexer

#line 124 "lexer.cog"
                 * lexer, 

#line 125 "lexer.cog"
        Int base);


#line 141 "lexer.cog"
 

#line 144 "lexer.cog"
     TokenCode lexNumber(

#line 142 "lexer.cog"
                 

#line 142 "lexer.cog"
            Lexer

#line 142 "lexer.cog"
                 * lexer, 

#line 143 "lexer.cog"
           Int base);


#line 185 "lexer.cog"
 

#line 187 "lexer.cog"
     TokenCode lexIdentifier(

#line 186 "lexer.cog"
              

#line 186 "lexer.cog"
         Lexer

#line 186 "lexer.cog"
              * lexer);


#line 200 "lexer.cog"
 

#line 202 "lexer.cog"
     TokenCode lexOperator(

#line 201 "lexer.cog"
              

#line 201 "lexer.cog"
         Lexer

#line 201 "lexer.cog"
              * lexer);


#line 215 "lexer.cog"
 

#line 217 "lexer.cog"
     TokenCode lexLineComment(

#line 216 "lexer.cog"
              

#line 216 "lexer.cog"
         Lexer

#line 216 "lexer.cog"
              * lexer);


#line 234 "lexer.cog"
 

#line 236 "lexer.cog"
     TokenCode lexBlockComment(

#line 235 "lexer.cog"
              

#line 235 "lexer.cog"
         Lexer

#line 235 "lexer.cog"
              * lexer);


#line 266 "lexer.cog"
 

#line 268 "lexer.cog"
     TokenCode lexWhiteSpace(

#line 267 "lexer.cog"
              

#line 267 "lexer.cog"
         Lexer

#line 267 "lexer.cog"
              * lexer);


#line 282 "lexer.cog"
 void lexStringLiteral(

#line 283 "lexer.cog"
              

#line 283 "lexer.cog"
         Lexer

#line 283 "lexer.cog"
              * lexer, 

#line 284 "lexer.cog"
             Int delimeter);


#line 327 "lexer.cog"
 

#line 329 "lexer.cog"
     TokenCode lexTokenImpl(

#line 328 "lexer.cog"
              

#line 328 "lexer.cog"
         Lexer

#line 328 "lexer.cog"
              * lexer);


#line 57 "token.cog"
 struct Token
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 59 "token.cog"
  

#line 59 "token.cog"
               UIntPtr rawLoc;


#line 60 "token.cog"
  

#line 60 "token.cog"
                UIntPtr rawSize;


#line 61 "token.cog"
  

#line 61 "token.cog"
                   

#line 61 "token.cog"
                Ptr<

#line 61 "token.cog"
                    Void>  rawData;


#line 62 "token.cog"
  

#line 62 "token.cog"
             TokenCode code;


#line 63 "token.cog"
  

#line 63 "token.cog"
              TokenFlags flags;


#line 64 "token.cog"
  

#line 64 "token.cog"
                UInt32 advance;


#line 66 "token.cog"
  

#line 66 "token.cog"
                   SourceLoc getLoc();
};


#line 508 "lexer.cog"
 

#line 510 "lexer.cog"
     Token lexToken(

#line 509 "lexer.cog"
              

#line 509 "lexer.cog"
         Lexer

#line 509 "lexer.cog"
              * lexer);


#line 555 "lexer.cog"
 

#line 561 "lexer.cog"
          

#line 561 "lexer.cog"
     Token

#line 561 "lexer.cog"
          * matchDelimeter(

#line 556 "lexer.cog"
              

#line 556 "lexer.cog"
         Lexer

#line 556 "lexer.cog"
              * lexer, 

#line 557 "lexer.cog"
             

#line 557 "lexer.cog"
        Token

#line 557 "lexer.cog"
             * open, 

#line 558 "lexer.cog"
              

#line 558 "lexer.cog"
         Token

#line 558 "lexer.cog"
              * begin, 

#line 559 "lexer.cog"
               

#line 559 "lexer.cog"
       ConstPtr<

#line 559 "lexer.cog"
                Token>  end, 

#line 560 "lexer.cog"
                    TokenCode closingTokenCode);


#line 605 "lexer.cog"
 void matchDelimeters(

#line 606 "lexer.cog"
              

#line 606 "lexer.cog"
         Lexer

#line 606 "lexer.cog"
              * lexer, 

#line 607 "lexer.cog"
              

#line 607 "lexer.cog"
         Token

#line 607 "lexer.cog"
              * begin, 

#line 608 "lexer.cog"
               

#line 608 "lexer.cog"
       ConstPtr<

#line 608 "lexer.cog"
                Token>  end);


#line 613 "lexer.cog"
 void markUpOperators(

#line 614 "lexer.cog"
              

#line 614 "lexer.cog"
         Lexer

#line 614 "lexer.cog"
              * lexer, 

#line 615 "lexer.cog"
              

#line 615 "lexer.cog"
         Token

#line 615 "lexer.cog"
              * begin, 

#line 616 "lexer.cog"
               

#line 616 "lexer.cog"
       ConstPtr<

#line 616 "lexer.cog"
                Token>  end);


#line 72 "token.cog"
 struct TokenSpan
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 74 "token.cog"
  

#line 74 "token.cog"
                       

#line 74 "token.cog"
               ConstPtr<

#line 74 "token.cog"
                        Token>  begin_;


#line 75 "token.cog"
  

#line 75 "token.cog"
                     

#line 75 "token.cog"
             ConstPtr<

#line 75 "token.cog"
                      Token>  end_;


#line 77 "token.cog"
  TokenSpan();


#line 83 "token.cog"
  TokenSpan(

#line 83 "token.cog"
                      

#line 83 "token.cog"
              ConstPtr<

#line 83 "token.cog"
                       Token>  begin, 

#line 83 "token.cog"
                                            

#line 83 "token.cog"
                                    ConstPtr<

#line 83 "token.cog"
                                             Token>  end);
};


#line 682 "lexer.cog"
 

#line 685 "lexer.cog"
     TokenSpan lexTokens(

#line 683 "lexer.cog"
           Session session, 

#line 684 "lexer.cog"
                  

#line 684 "lexer.cog"
        SourceFile

#line 684 "lexer.cog"
                  * file);


#line 3 "main.cog"
 

#line 5 "main.cog"
 void parseCommandLine(

#line 6 "main.cog"
           Session session, 

#line 7 "main.cog"
             

#line 7 "main.cog"
          Ptr<

#line 7 "main.cog"
              Int>  ioArgc, 

#line 8 "main.cog"
           

#line 8 "main.cog"
        Ptr<

#line 8 "main.cog"
               

#line 8 "main.cog"
            Ptr<

#line 8 "main.cog"
                Char> >  argv);


#line 103 "main.cog"
 

#line 103 "main.cog"
                                                   Int main(

#line 103 "main.cog"
                   Int argc, 

#line 103 "main.cog"
                                  

#line 103 "main.cog"
                               Ptr<

#line 103 "main.cog"
                                      

#line 103 "main.cog"
                                   Ptr<

#line 103 "main.cog"
                                       Char> >  argv);


#line 3 "name.cog"
 

#line 11 "name.cog"
 

#line 14 "name.cog"
        

#line 14 "name.cog"
     Ptr<

#line 14 "name.cog"
         Name>  getName(

#line 12 "name.cog"
           Session session, 

#line 13 "name.cog"
        StringSpan text);


#line 38 "name.cog"
 

#line 40 "name.cog"
     TerminatedStringSpan getText(

#line 39 "name.cog"
           

#line 39 "name.cog"
        Ptr<

#line 39 "name.cog"
            Name>  name);


#line 47 "name.cog"
 

#line 50 "name.cog"
        

#line 50 "name.cog"
     Ptr<

#line 50 "name.cog"
         Name>  getName(

#line 48 "name.cog"
           Session session, 

#line 49 "name.cog"
           

#line 49 "name.cog"
        Ptr<

#line 49 "name.cog"
            Char>  text);


#line 3 "parser.cog"
 

#line 5 "parser.cog"
 typedef 

#line 5 "parser.cog"
                         UInt32 ParserFlags;


#line 7 "parser.cog"
 enum ParserFlag : int
{
kParserFlag_Recovering = 

#line 9 "parser.cog"
                                         

#line 9 "parser.cog"
                                       1 

#line 9 "parser.cog"
                                         << 

#line 9 "parser.cog"
                                            0,
kParserFlag_InsideGenericClause = 

#line 10 "parser.cog"
                                         

#line 10 "parser.cog"
                                       1 

#line 10 "parser.cog"
                                         << 

#line 10 "parser.cog"
                                            1,
};


#line 13 "parser.cog"
 struct Parser
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 15 "parser.cog"
     

#line 15 "parser.cog"
                  Session session;


#line 16 "parser.cog"
     

#line 16 "parser.cog"
                     

#line 16 "parser.cog"
                Scope

#line 16 "parser.cog"
                     * scope;


#line 18 "parser.cog"
     

#line 18 "parser.cog"
                        

#line 18 "parser.cog"
                ConstPtr<

#line 18 "parser.cog"
                         Token>  begin;


#line 19 "parser.cog"
     

#line 19 "parser.cog"
                         

#line 19 "parser.cog"
                 ConstPtr<

#line 19 "parser.cog"
                          Token>  cursor;


#line 20 "parser.cog"
     

#line 20 "parser.cog"
                      

#line 20 "parser.cog"
              ConstPtr<

#line 20 "parser.cog"
                       Token>  end;


#line 22 "parser.cog"
     

#line 22 "parser.cog"
                        

#line 22 "parser.cog"
                ConstPtr<

#line 22 "parser.cog"
                         Token>  token;


#line 24 "parser.cog"
     

#line 24 "parser.cog"
                ParserFlags flags;


#line 26 "parser.cog"
  

#line 26 "parser.cog"
                    Int genericDepth;
};


#line 29 "parser.cog"
 void debugState(

#line 29 "parser.cog"
                               

#line 29 "parser.cog"
                         Parser

#line 29 "parser.cog"
                               * parser);


#line 43 "parser.cog"
 

#line 45 "parser.cog"
                

#line 45 "parser.cog"
        ConstPtr<

#line 45 "parser.cog"
                 Token>  advanceToken(

#line 44 "parser.cog"
                   

#line 44 "parser.cog"
             Parser

#line 44 "parser.cog"
                   * parser);


#line 57 "parser.cog"
 

#line 59 "parser.cog"
                

#line 59 "parser.cog"
        ConstPtr<

#line 59 "parser.cog"
                 Token>  advanceFragment(

#line 58 "parser.cog"
                   

#line 58 "parser.cog"
             Parser

#line 58 "parser.cog"
                   * parser);


#line 72 "parser.cog"
 void initializeParser(

#line 73 "parser.cog"
                   

#line 73 "parser.cog"
             Parser

#line 73 "parser.cog"
                   * parser, 

#line 74 "parser.cog"
              Session session, 

#line 75 "parser.cog"
                     

#line 75 "parser.cog"
           SourceFile

#line 75 "parser.cog"
                     * file);


#line 90 "parser.cog"
 void finalizeParser(

#line 91 "parser.cog"
                   

#line 91 "parser.cog"
             Parser

#line 91 "parser.cog"
                   * parser);


#line 94 "parser.cog"
 void pushScope(

#line 95 "parser.cog"
                   

#line 95 "parser.cog"
             Parser

#line 95 "parser.cog"
                   * parser, 

#line 96 "parser.cog"
                ContainerDecl container);


#line 107 "parser.cog"
 void restoreScope(

#line 108 "parser.cog"
                   

#line 108 "parser.cog"
             Parser

#line 108 "parser.cog"
                   * parser, 

#line 109 "parser.cog"
                 

#line 109 "parser.cog"
            Scope

#line 109 "parser.cog"
                 * scope);


#line 115 "parser.cog"
 void popScope(

#line 116 "parser.cog"
                   

#line 116 "parser.cog"
             Parser

#line 116 "parser.cog"
                   * parser);


#line 123 "parser.cog"
 

#line 124 "parser.cog"
                      

#line 124 "parser.cog"
        DiagnosticSink

#line 124 "parser.cog"
                      * getSink(

#line 123 "parser.cog"
                            

#line 123 "parser.cog"
                      Parser

#line 123 "parser.cog"
                            * parser);


#line 129 "parser.cog"
 

#line 130 "parser.cog"
        SourceLoc peekLoc(

#line 129 "parser.cog"
                            

#line 129 "parser.cog"
                      Parser

#line 129 "parser.cog"
                            * parser);


#line 135 "parser.cog"
 

#line 136 "parser.cog"
        TokenCode peekTokenCode(

#line 135 "parser.cog"
                                  

#line 135 "parser.cog"
                            Parser

#line 135 "parser.cog"
                                  * parser);


#line 141 "parser.cog"
 

#line 142 "parser.cog"
        Bool peekTokenCode(

#line 141 "parser.cog"
                                  

#line 141 "parser.cog"
                            Parser

#line 141 "parser.cog"
                                  * parser, 

#line 141 "parser.cog"
                                           TokenCode code);


#line 147 "parser.cog"
 

#line 148 "parser.cog"
        Bool isAtEnd(

#line 147 "parser.cog"
                            

#line 147 "parser.cog"
                      Parser

#line 147 "parser.cog"
                            * parser);


#line 153 "parser.cog"
 

#line 154 "parser.cog"
        Bool isRecovering(

#line 153 "parser.cog"
                                 

#line 153 "parser.cog"
                           Parser

#line 153 "parser.cog"
                                 * parser);


#line 159 "parser.cog"
 void unexpected(

#line 159 "parser.cog"
                               

#line 159 "parser.cog"
                         Parser

#line 159 "parser.cog"
                               * parser);


#line 168 "parser.cog"
 void unexpected(

#line 168 "parser.cog"
                               

#line 168 "parser.cog"
                         Parser

#line 168 "parser.cog"
                               * parser, 

#line 168 "parser.cog"
                                            TokenCode expected);


#line 177 "parser.cog"
 

#line 181 "parser.cog"
        Bool tokenIsInSet(

#line 178 "parser.cog"
             TokenCode needle, 

#line 179 "parser.cog"
            Int count, 

#line 180 "parser.cog"
                       

#line 180 "parser.cog"
               ConstPtr<

#line 180 "parser.cog"
                        TokenCode>  haystack);


#line 193 "parser.cog"
 

#line 198 "parser.cog"
        Bool recoverIfTokenIsInSet(

#line 194 "parser.cog"
                   

#line 194 "parser.cog"
             Parser

#line 194 "parser.cog"
                   * parser, 

#line 195 "parser.cog"
             TokenCode needle, 

#line 196 "parser.cog"
            Int count, 

#line 197 "parser.cog"
                       

#line 197 "parser.cog"
               ConstPtr<

#line 197 "parser.cog"
                        TokenCode>  haystack);


#line 208 "parser.cog"
 void tryRecover(

#line 209 "parser.cog"
                   

#line 209 "parser.cog"
             Parser

#line 209 "parser.cog"
                   * parser, 

#line 210 "parser.cog"
                         Int recoverBeforeCount, 

#line 211 "parser.cog"
                            

#line 211 "parser.cog"
                    ConstPtr<

#line 211 "parser.cog"
                             TokenCode>  recoverBefore, 

#line 212 "parser.cog"
                        Int recoverAfterCount, 

#line 213 "parser.cog"
                           

#line 213 "parser.cog"
                   ConstPtr<

#line 213 "parser.cog"
                            TokenCode>  recoverAfter);


#line 264 "parser.cog"
 void tryRecover(

#line 264 "parser.cog"
                               

#line 264 "parser.cog"
                         Parser

#line 264 "parser.cog"
                               * parser);


#line 284 "parser.cog"
 void tryRecoverBefore(

#line 284 "parser.cog"
                                     

#line 284 "parser.cog"
                               Parser

#line 284 "parser.cog"
                                     * parser, 

#line 284 "parser.cog"
                                              TokenCode code);


#line 297 "parser.cog"
 

#line 300 "parser.cog"
                

#line 300 "parser.cog"
        ConstPtr<

#line 300 "parser.cog"
                 Token>  advanceIf(

#line 298 "parser.cog"
                   

#line 298 "parser.cog"
             Parser

#line 298 "parser.cog"
                   * parser, 

#line 299 "parser.cog"
               TokenCode expected);


#line 309 "parser.cog"
 

#line 312 "parser.cog"
                

#line 312 "parser.cog"
        ConstPtr<

#line 312 "parser.cog"
                 Token>  advanceIf(

#line 310 "parser.cog"
                   

#line 310 "parser.cog"
             Parser

#line 310 "parser.cog"
                   * parser, 

#line 311 "parser.cog"
               StringSpan expected);


#line 328 "parser.cog"
 

#line 331 "parser.cog"
                

#line 331 "parser.cog"
        ConstPtr<

#line 331 "parser.cog"
                 Token>  advanceIfFragment(

#line 329 "parser.cog"
                   

#line 329 "parser.cog"
             Parser

#line 329 "parser.cog"
                   * parser, 

#line 330 "parser.cog"
               TokenCode expected);


#line 340 "parser.cog"
 

#line 343 "parser.cog"
                

#line 343 "parser.cog"
        ConstPtr<

#line 343 "parser.cog"
                 Token>  expect(

#line 341 "parser.cog"
                   

#line 341 "parser.cog"
             Parser

#line 341 "parser.cog"
                   * parser, 

#line 342 "parser.cog"
               TokenCode expected);


#line 352 "parser.cog"
 

#line 355 "parser.cog"
                

#line 355 "parser.cog"
        ConstPtr<

#line 355 "parser.cog"
                 Token>  expectFragment(

#line 353 "parser.cog"
                   

#line 353 "parser.cog"
             Parser

#line 353 "parser.cog"
                   * parser, 

#line 354 "parser.cog"
               TokenCode expected);


#line 364 "parser.cog"
 

#line 366 "parser.cog"
            

#line 366 "parser.cog"
        Name

#line 366 "parser.cog"
            * expectIdentifier(

#line 365 "parser.cog"
                   

#line 365 "parser.cog"
             Parser

#line 365 "parser.cog"
                   * parser);


#line 381 "parser.cog"
 

#line 384 "parser.cog"
                

#line 384 "parser.cog"
        ConstPtr<

#line 384 "parser.cog"
                 Token>  advanceIfEnd(

#line 382 "parser.cog"
                   

#line 382 "parser.cog"
             Parser

#line 382 "parser.cog"
                   * parser, 

#line 383 "parser.cog"
               TokenCode expected);


#line 611 "syntax.cog"
 struct LookupResultItem
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 614 "syntax.cog"
  

#line 614 "syntax.cog"
             Decl decl;


#line 616 "syntax.cog"
  LookupResultItem();


#line 624 "syntax.cog"
  LookupResultItem(

#line 624 "syntax.cog"
             Decl decl);
};


#line 630 "syntax.cog"
 struct LookupResult
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 632 "syntax.cog"
  

#line 632 "syntax.cog"
                   

#line 632 "syntax.cog"
              Array<

#line 632 "syntax.cog"
                    LookupResultItem>  items;


#line 634 "syntax.cog"
  

#line 634 "syntax.cog"
                     

#line 634 "syntax.cog"
                  Ptr<

#line 634 "syntax.cog"
                      LookupResultItem>  begin();


#line 635 "syntax.cog"
  

#line 635 "syntax.cog"
                   

#line 635 "syntax.cog"
                Ptr<

#line 635 "syntax.cog"
                    LookupResultItem>  end();


#line 638 "syntax.cog"
  

#line 638 "syntax.cog"
                    Bool isEmpty();


#line 639 "syntax.cog"
     

#line 639 "syntax.cog"
                        Bool isUnique();


#line 640 "syntax.cog"
     

#line 640 "syntax.cog"
                            Bool isOverloaded();


#line 642 "syntax.cog"
     

#line 642 "syntax.cog"
                       Decl getDecl();
};


#line 395 "parser.cog"
 

#line 398 "parser.cog"
        LookupResult lookup(

#line 396 "parser.cog"
                   

#line 396 "parser.cog"
             Parser

#line 396 "parser.cog"
                   * parser, 

#line 397 "parser.cog"
               

#line 397 "parser.cog"
           Name

#line 397 "parser.cog"
               * name);


#line 405 "parser.cog"
 

#line 407 "parser.cog"
        SyntaxDecl getSyntaxDecl(

#line 406 "parser.cog"
                     

#line 406 "parser.cog"
             ConstRef<

#line 406 "parser.cog"
                      LookupResult>  result);


#line 422 "parser.cog"
 

#line 425 "parser.cog"
        NameExp createNameExp(

#line 423 "parser.cog"
                   

#line 423 "parser.cog"
             Parser

#line 423 "parser.cog"
                   * parser, 

#line 424 "parser.cog"
                    

#line 424 "parser.cog"
            ConstPtr<

#line 424 "parser.cog"
                     Token>  token);


#line 435 "parser.cog"
 

#line 437 "parser.cog"
        Exp createErrorExp(

#line 436 "parser.cog"
                   

#line 436 "parser.cog"
             Parser

#line 436 "parser.cog"
                   * parser);


#line 444 "parser.cog"
 

#line 445 "parser.cog"
    Arg parseArg(

#line 444 "parser.cog"
                             

#line 444 "parser.cog"
                       Parser

#line 444 "parser.cog"
                             * parser);


#line 451 "parser.cog"
 

#line 453 "parser.cog"
             

#line 453 "parser.cog"
        Array<

#line 453 "parser.cog"
              Arg>  parseArgs(

#line 452 "parser.cog"
                   

#line 452 "parser.cog"
             Parser

#line 452 "parser.cog"
                   * parser);


#line 494 "parser.cog"
 

#line 495 "parser.cog"
        Arg parseGenericArg(

#line 494 "parser.cog"
                                    

#line 494 "parser.cog"
                              Parser

#line 494 "parser.cog"
                                    * parser);


#line 504 "parser.cog"
 

#line 506 "parser.cog"
             

#line 506 "parser.cog"
        Array<

#line 506 "parser.cog"
              Arg>  parseGenericArgs(

#line 505 "parser.cog"
                   

#line 505 "parser.cog"
             Parser

#line 505 "parser.cog"
                   * parser);


#line 527 "parser.cog"
 

#line 529 "parser.cog"
        Bool peekGenericApp(

#line 528 "parser.cog"
                     

#line 528 "parser.cog"
               Parser

#line 528 "parser.cog"
                     * inParser);


#line 572 "parser.cog"
 

#line 575 "parser.cog"
        Exp maybeParseGenericApp(

#line 573 "parser.cog"
                   

#line 573 "parser.cog"
             Parser

#line 573 "parser.cog"
                   * parser, 

#line 574 "parser.cog"
           Exp base);


#line 531 "syntax.cog"
 typedef 

#line 531 "syntax.cog"
                       Int64 IntLitVal;


#line 595 "parser.cog"
 

#line 597 "parser.cog"
        IntLitVal getIntegerLiteralVal(

#line 596 "parser.cog"
                    

#line 596 "parser.cog"
            ConstRef<

#line 596 "parser.cog"
                     Token>  token);


#line 639 "parser.cog"
 

#line 641 "parser.cog"
        String getStringLiteralVal(

#line 640 "parser.cog"
                    

#line 640 "parser.cog"
            ConstRef<

#line 640 "parser.cog"
                     Token>  token);


#line 689 "parser.cog"
 

#line 691 "parser.cog"
        Exp parseAtomicExp(

#line 690 "parser.cog"
                   

#line 690 "parser.cog"
             Parser

#line 690 "parser.cog"
                   * parser);


#line 778 "parser.cog"
 

#line 781 "parser.cog"
        Arg createPositionalArg(

#line 779 "parser.cog"
                   

#line 779 "parser.cog"
             Parser

#line 779 "parser.cog"
                   * parser, 

#line 780 "parser.cog"
          Exp exp);


#line 789 "parser.cog"
 

#line 794 "parser.cog"
        AppExpBase createApp(

#line 790 "parser.cog"
                   

#line 790 "parser.cog"
             Parser

#line 790 "parser.cog"
                   * parser, 

#line 791 "parser.cog"
          AppExpBase exp, 

#line 792 "parser.cog"
                 

#line 792 "parser.cog"
         ConstPtr<

#line 792 "parser.cog"
                  Token>  op, 

#line 793 "parser.cog"
             Exp argExp);


#line 805 "parser.cog"
 

#line 811 "parser.cog"
        AppExpBase createApp(

#line 806 "parser.cog"
                   

#line 806 "parser.cog"
             Parser

#line 806 "parser.cog"
                   * parser, 

#line 807 "parser.cog"
          AppExpBase exp, 

#line 808 "parser.cog"
                 

#line 808 "parser.cog"
         ConstPtr<

#line 808 "parser.cog"
                  Token>  op, 

#line 809 "parser.cog"
              Exp argExp0, 

#line 810 "parser.cog"
              Exp argExp1);


#line 823 "parser.cog"
 

#line 825 "parser.cog"
        Bool isInGenericClause(

#line 824 "parser.cog"
                   

#line 824 "parser.cog"
             Parser

#line 824 "parser.cog"
                   * parser);


#line 831 "parser.cog"
 

#line 833 "parser.cog"
        Exp parsePostfixExp(

#line 832 "parser.cog"
                   

#line 832 "parser.cog"
             Parser

#line 832 "parser.cog"
                   * parser);


#line 901 "parser.cog"
 

#line 903 "parser.cog"
        Exp parsePrefixExp(

#line 902 "parser.cog"
                   

#line 902 "parser.cog"
             Parser

#line 902 "parser.cog"
                   * parser);


#line 918 "parser.cog"
 

#line 920 "parser.cog"
        Exp parseInfixExp(

#line 919 "parser.cog"
                   

#line 919 "parser.cog"
             Parser

#line 919 "parser.cog"
                   * parser);


#line 961 "parser.cog"
 

#line 963 "parser.cog"
        Exp parseExp(

#line 962 "parser.cog"
                   

#line 962 "parser.cog"
             Parser

#line 962 "parser.cog"
                   * parser);


#line 968 "parser.cog"
 

#line 970 "parser.cog"
        TypeExp parseType(

#line 969 "parser.cog"
                   

#line 969 "parser.cog"
             Parser

#line 969 "parser.cog"
                   * parser);


#line 979 "parser.cog"
 

#line 981 "parser.cog"
        Decl parseDecl(

#line 980 "parser.cog"
                   

#line 980 "parser.cog"
             Parser

#line 980 "parser.cog"
                   * parser);


#line 1054 "parser.cog"
 

#line 1058 "parser.cog"
        ModuleDecl findOrImportModule(

#line 1055 "parser.cog"
              Session session, 

#line 1056 "parser.cog"
          SourceLoc loc, 

#line 1057 "parser.cog"
               

#line 1057 "parser.cog"
           Name

#line 1057 "parser.cog"
               * name);


#line 1124 "parser.cog"
 

#line 1126 "parser.cog"
             

#line 1126 "parser.cog"
        Array<

#line 1126 "parser.cog"
              Decl>  parseDeclsInBody(

#line 1125 "parser.cog"
                   

#line 1125 "parser.cog"
             Parser

#line 1125 "parser.cog"
                   * parser);


#line 1159 "parser.cog"
 

#line 1161 "parser.cog"
             

#line 1161 "parser.cog"
        Array<

#line 1161 "parser.cog"
              Decl>  parseDeclBody(

#line 1160 "parser.cog"
                   

#line 1160 "parser.cog"
             Parser

#line 1160 "parser.cog"
                   * parser);


#line 1169 "parser.cog"
 void parseDeclBody(

#line 1170 "parser.cog"
                   

#line 1170 "parser.cog"
             Parser

#line 1170 "parser.cog"
                   * parser, 

#line 1171 "parser.cog"
           ContainerDecl decl);


#line 1184 "parser.cog"
 

#line 1186 "parser.cog"
        Stmt parseExpStmt(

#line 1185 "parser.cog"
                   

#line 1185 "parser.cog"
             Parser

#line 1185 "parser.cog"
                   * parser);


#line 1193 "parser.cog"
 

#line 1195 "parser.cog"
        Stmt parseStmt(

#line 1194 "parser.cog"
                   

#line 1194 "parser.cog"
             Parser

#line 1194 "parser.cog"
                   * parser);


#line 1250 "parser.cog"
 

#line 1252 "parser.cog"
             

#line 1252 "parser.cog"
        Array<

#line 1252 "parser.cog"
              Stmt>  parseStmtsInBody(

#line 1251 "parser.cog"
                   

#line 1251 "parser.cog"
             Parser

#line 1251 "parser.cog"
                   * parser);


#line 1279 "parser.cog"
 

#line 1281 "parser.cog"
        Stmt parseStmtBody(

#line 1280 "parser.cog"
                   

#line 1280 "parser.cog"
             Parser

#line 1280 "parser.cog"
                   * parser);


#line 1296 "parser.cog"
 

#line 1296 "parser.cog"
                                           Bool peekGenericClose(

#line 1296 "parser.cog"
                                     

#line 1296 "parser.cog"
                               Parser

#line 1296 "parser.cog"
                                     * parser);


#line 1320 "parser.cog"
 

#line 1320 "parser.cog"
                                               Bool tryParseGenericClose(

#line 1320 "parser.cog"
                                         

#line 1320 "parser.cog"
                                   Parser

#line 1320 "parser.cog"
                                         * parser);


#line 1330 "parser.cog"
 void expectGenericClose(

#line 1330 "parser.cog"
                                       

#line 1330 "parser.cog"
                                 Parser

#line 1330 "parser.cog"
                                       * parser);


#line 1339 "parser.cog"
 

#line 1339 "parser.cog"
                                            Decl parseGenericParam(

#line 1339 "parser.cog"
                                      

#line 1339 "parser.cog"
                                Parser

#line 1339 "parser.cog"
                                      * parser);


#line 1360 "parser.cog"
 void parseGenericParams(

#line 1360 "parser.cog"
                                       

#line 1360 "parser.cog"
                                 Parser

#line 1360 "parser.cog"
                                       * parser, 

#line 1360 "parser.cog"
                                                      

#line 1360 "parser.cog"
                                                   Ptr<

#line 1360 "parser.cog"
                                                            

#line 1360 "parser.cog"
                                                       Array<

#line 1360 "parser.cog"
                                                             Decl> >  ioDecls);


#line 1387 "parser.cog"
 

#line 1387 "parser.cog"
                                              Bool tryParseGenericOpen(

#line 1387 "parser.cog"
                                        

#line 1387 "parser.cog"
                                  Parser

#line 1387 "parser.cog"
                                        * parser);


#line 1415 "parser.cog"
 

#line 1415 "parser.cog"
                                                             Decl maybeParseGenericParams(

#line 1415 "parser.cog"
                                            

#line 1415 "parser.cog"
                                      Parser

#line 1415 "parser.cog"
                                            * parser, 

#line 1415 "parser.cog"
                                                    Decl decl);


#line 1441 "parser.cog"
 

#line 1441 "parser.cog"
                                                                    Decl parseAggTypeDeclCommon(

#line 1441 "parser.cog"
                                           

#line 1441 "parser.cog"
                                     Parser

#line 1441 "parser.cog"
                                           * parser, 

#line 1441 "parser.cog"
                                                    AggTypeDecl decl);


#line 1471 "parser.cog"
 

#line 1471 "parser.cog"
                                         Syntax parseClassDecl(

#line 1471 "parser.cog"
                                   

#line 1471 "parser.cog"
                             Parser

#line 1471 "parser.cog"
                                   * parser);


#line 1477 "parser.cog"
 

#line 1477 "parser.cog"
                                          Syntax parseStructDecl(

#line 1477 "parser.cog"
                                    

#line 1477 "parser.cog"
                              Parser

#line 1477 "parser.cog"
                                    * parser);


#line 1483 "parser.cog"
 

#line 1483 "parser.cog"
                                             

#line 1483 "parser.cog"
                                        Array<

#line 1483 "parser.cog"
                                              Decl>  parseEnumTags(

#line 1483 "parser.cog"
                                  

#line 1483 "parser.cog"
                            Parser

#line 1483 "parser.cog"
                                  * parser);


#line 1524 "parser.cog"
 

#line 1524 "parser.cog"
                                        Syntax parseEnumDecl(

#line 1524 "parser.cog"
                                  

#line 1524 "parser.cog"
                            Parser

#line 1524 "parser.cog"
                                  * parser);


#line 1549 "parser.cog"
 

#line 1549 "parser.cog"
                                          Syntax parseImportDecl(

#line 1549 "parser.cog"
                                    

#line 1549 "parser.cog"
                              Parser

#line 1549 "parser.cog"
                                    * parser);


#line 1559 "parser.cog"
 void parseVarDeclCommon(

#line 1559 "parser.cog"
                                       

#line 1559 "parser.cog"
                                 Parser

#line 1559 "parser.cog"
                                       * parser, 

#line 1559 "parser.cog"
                                                VarDeclBase decl);


#line 1576 "parser.cog"
 

#line 1576 "parser.cog"
                                       Syntax parseVarDecl(

#line 1576 "parser.cog"
                                 

#line 1576 "parser.cog"
                           Parser

#line 1576 "parser.cog"
                                 * parser);


#line 1584 "parser.cog"
 

#line 1584 "parser.cog"
                                       Syntax parseLetDecl(

#line 1584 "parser.cog"
                                 

#line 1584 "parser.cog"
                           Parser

#line 1584 "parser.cog"
                                 * parser);


#line 1592 "parser.cog"
 void parseTypeVarDeclSuffixCommon(

#line 1592 "parser.cog"
                                                 

#line 1592 "parser.cog"
                                           Parser

#line 1592 "parser.cog"
                                                 * parser, 

#line 1592 "parser.cog"
                                                          TypeVarDecl decl);


#line 1607 "parser.cog"
 void parseTypeVarDeclCommon(

#line 1607 "parser.cog"
                                           

#line 1607 "parser.cog"
                                     Parser

#line 1607 "parser.cog"
                                           * parser, 

#line 1607 "parser.cog"
                                                    TypeVarDecl decl);


#line 1613 "parser.cog"
 

#line 1613 "parser.cog"
                                                         

#line 1613 "parser.cog"
                                                     Name

#line 1613 "parser.cog"
                                                         * expectOperatorOrIdentifier(

#line 1613 "parser.cog"
                                               

#line 1613 "parser.cog"
                                         Parser

#line 1613 "parser.cog"
                                               * parser);


#line 1628 "parser.cog"
 

#line 1628 "parser.cog"
                                             Syntax parseTypeAliasDecl(

#line 1628 "parser.cog"
                                       

#line 1628 "parser.cog"
                                 Parser

#line 1628 "parser.cog"
                                       * parser);


#line 1640 "parser.cog"
 

#line 1640 "parser.cog"
                                      Syntax parseIfStmt(

#line 1640 "parser.cog"
                                

#line 1640 "parser.cog"
                          Parser

#line 1640 "parser.cog"
                                * parser);


#line 1673 "parser.cog"
 

#line 1673 "parser.cog"
                                         Syntax parseWhileStmt(

#line 1673 "parser.cog"
                                   

#line 1673 "parser.cog"
                             Parser

#line 1673 "parser.cog"
                                   * parser);


#line 1683 "parser.cog"
 

#line 1683 "parser.cog"
                                       Syntax parseForStmt(

#line 1683 "parser.cog"
                                 

#line 1683 "parser.cog"
                           Parser

#line 1683 "parser.cog"
                                 * parser);


#line 1733 "parser.cog"
 

#line 1733 "parser.cog"
                                           Syntax parseForEachStmt(

#line 1733 "parser.cog"
                                     

#line 1733 "parser.cog"
                               Parser

#line 1733 "parser.cog"
                                     * parser);


#line 1752 "parser.cog"
 

#line 1752 "parser.cog"
                                          Syntax parseSwitchStmt(

#line 1752 "parser.cog"
                                    

#line 1752 "parser.cog"
                              Parser

#line 1752 "parser.cog"
                                    * parser);


#line 1819 "parser.cog"
 

#line 1819 "parser.cog"
                                          Syntax parseReturnStmt(

#line 1819 "parser.cog"
                                    

#line 1819 "parser.cog"
                              Parser

#line 1819 "parser.cog"
                                    * parser);


#line 1830 "parser.cog"
 

#line 1830 "parser.cog"
                                         Syntax parseBreakStmt(

#line 1830 "parser.cog"
                                   

#line 1830 "parser.cog"
                             Parser

#line 1830 "parser.cog"
                                   * parser);


#line 1837 "parser.cog"
 

#line 1837 "parser.cog"
                                            Syntax parseContinueStmt(

#line 1837 "parser.cog"
                                      

#line 1837 "parser.cog"
                                Parser

#line 1837 "parser.cog"
                                      * parser);


#line 1844 "parser.cog"
 

#line 1844 "parser.cog"
                                           Syntax parseBuiltinAttr(

#line 1844 "parser.cog"
                                     

#line 1844 "parser.cog"
                               Parser

#line 1844 "parser.cog"
                                     * parser);


#line 1853 "parser.cog"
 

#line 1853 "parser.cog"
                                                Syntax parseDeclRefClassAttr(

#line 1853 "parser.cog"
                                          

#line 1853 "parser.cog"
                                    Parser

#line 1853 "parser.cog"
                                          * parser);


#line 1866 "parser.cog"
 

#line 1866 "parser.cog"
                                     ParamDecl parseParam(

#line 1866 "parser.cog"
                               

#line 1866 "parser.cog"
                         Parser

#line 1866 "parser.cog"
                               * parser);


#line 1873 "parser.cog"
 void parseParams(

#line 1873 "parser.cog"
                                

#line 1873 "parser.cog"
                          Parser

#line 1873 "parser.cog"
                                * parser, 

#line 1873 "parser.cog"
                                         ContainerDecl decl);


#line 1922 "parser.cog"
 

#line 1922 "parser.cog"
                                        Syntax parseFuncDecl(

#line 1922 "parser.cog"
                                  

#line 1922 "parser.cog"
                            Parser

#line 1922 "parser.cog"
                                  * parser);


#line 1959 "parser.cog"
 

#line 1959 "parser.cog"
                                             Syntax parseSubscriptDecl(

#line 1959 "parser.cog"
                                       

#line 1959 "parser.cog"
                                 Parser

#line 1959 "parser.cog"
                                       * parser);


#line 1990 "parser.cog"
 

#line 1990 "parser.cog"
                                               Syntax parseInitializerDecl(

#line 1990 "parser.cog"
                                         

#line 1990 "parser.cog"
                                   Parser

#line 1990 "parser.cog"
                                         * parser);


#line 2022 "parser.cog"
 

#line 2022 "parser.cog"
                                        Syntax parseThisExpr(

#line 2022 "parser.cog"
                                  

#line 2022 "parser.cog"
                            Parser

#line 2022 "parser.cog"
                                  * parser);


#line 2029 "parser.cog"
 

#line 2029 "parser.cog"
                                        Syntax parseCastExpr(

#line 2029 "parser.cog"
                                  

#line 2029 "parser.cog"
                            Parser

#line 2029 "parser.cog"
                                  * parser);


#line 2044 "parser.cog"
 

#line 2044 "parser.cog"
                                        Syntax parseNullExpr(

#line 2044 "parser.cog"
                                  

#line 2044 "parser.cog"
                            Parser

#line 2044 "parser.cog"
                                  * parser);


#line 2050 "parser.cog"
 

#line 2055 "parser.cog"
        SyntaxDecl createSyntaxDecl(

#line 2051 "parser.cog"
              Session session, 

#line 2052 "parser.cog"
                   

#line 2052 "parser.cog"
           ConstPtr<

#line 2052 "parser.cog"
                    Char>  name, 

#line 2053 "parser.cog"
               SyntaxCallback callback, 

#line 2054 "parser.cog"
                       

#line 2054 "parser.cog"
                  Class

#line 2054 "parser.cog"
                       * syntaxClass);


#line 2064 "parser.cog"
 template<typename T >


#line 2064 "parser.cog"
      

#line 2068 "parser.cog"
        SyntaxDecl createSyntaxDecl(

#line 2065 "parser.cog"
              Session session, 

#line 2066 "parser.cog"
                   

#line 2066 "parser.cog"
           ConstPtr<

#line 2066 "parser.cog"
                    Char>  name, 

#line 2067 "parser.cog"
               SyntaxCallback callback);


#line 2073 "parser.cog"
 void parseFileIntoModule(

#line 2074 "parser.cog"
              Session session, 

#line 2075 "parser.cog"
                     

#line 2075 "parser.cog"
           SourceFile

#line 2075 "parser.cog"
                     * file, 

#line 2076 "parser.cog"
                 ModuleDecl moduleDecl);


#line 2139 "parser.cog"
 void parseFile(

#line 2140 "parser.cog"
              Session session, 

#line 2141 "parser.cog"
                     

#line 2141 "parser.cog"
           SourceFile

#line 2141 "parser.cog"
                     * file);


#line 3 "scope.cog"
 

#line 17 "scope.cog"
 void lookupDirectImpl(

#line 18 "scope.cog"
             ContainerStmt container, 

#line 19 "scope.cog"
           

#line 19 "scope.cog"
        Ptr<

#line 19 "scope.cog"
            Name>  name, 

#line 20 "scope.cog"
               

#line 20 "scope.cog"
            Ptr<

#line 20 "scope.cog"
                LookupResult>  ioResult);


#line 34 "scope.cog"
 

#line 37 "scope.cog"
     LookupResult lookupDirect(

#line 35 "scope.cog"
             ContainerStmt container, 

#line 36 "scope.cog"
           

#line 36 "scope.cog"
        Ptr<

#line 36 "scope.cog"
            Name>  name);


#line 44 "scope.cog"
 

#line 47 "scope.cog"
     LookupResult lookupDirect(

#line 45 "scope.cog"
            

#line 45 "scope.cog"
         Ptr<

#line 45 "scope.cog"
             Scope>  scope, 

#line 46 "scope.cog"
           

#line 46 "scope.cog"
        Ptr<

#line 46 "scope.cog"
            Name>  name);


#line 60 "scope.cog"
 

#line 63 "scope.cog"
     LookupResult lookup(

#line 61 "scope.cog"
            

#line 61 "scope.cog"
         Ptr<

#line 61 "scope.cog"
             Scope>  scope, 

#line 62 "scope.cog"
           

#line 62 "scope.cog"
        Ptr<

#line 62 "scope.cog"
            Name>  name);


#line 3 "session.cog"
 

#line 5 "session.cog"
 using Session = struct SessionImpl* ;
struct SessionImpl : cog::ObjectImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 7 "session.cog"
  

#line 7 "session.cog"
                       

#line 7 "session.cog"
                    Ptr<

#line 7 "session.cog"
                        SourceFile>  sourceFiles;


#line 8 "session.cog"
  

#line 8 "session.cog"
                 

#line 8 "session.cog"
              Ptr<

#line 8 "session.cog"
                  Name>  names;


#line 9 "session.cog"
  

#line 9 "session.cog"
                      UInt lastSourceLoc;


#line 10 "session.cog"
  

#line 10 "session.cog"
             DiagnosticSink sink;


#line 11 "session.cog"
  

#line 11 "session.cog"
                   ModuleDecl moduleDecl;


#line 13 "session.cog"
  

#line 13 "session.cog"
                       

#line 13 "session.cog"
                    Ptr<

#line 13 "session.cog"
                        Name>  moduleName2;


#line 14 "session.cog"
  

#line 14 "session.cog"
                       

#line 14 "session.cog"
                    Ptr<

#line 14 "session.cog"
                        Name>  modulePath2;


#line 16 "session.cog"
  

#line 16 "session.cog"
                           

#line 16 "session.cog"
                      Array<

#line 16 "session.cog"
                            ModuleDecl>  loadedModules;


#line 19 "session.cog"
  

#line 19 "session.cog"
             Bool eval;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::Session > { typedef cogc::SessionImpl Impl; };
} namespace cogc {


#line 22 "session.cog"
 

#line 22 "session.cog"
                         Session createSession();


#line 29 "session.cog"
 void destroySession(

#line 29 "session.cog"
                              Session session);


#line 34 "session.cog"
 void setModulePath(

#line 35 "session.cog"
           Session session, 

#line 36 "session.cog"
         StringSpan path);


#line 46 "session.cog"
 void setModulePath(

#line 47 "session.cog"
           Session session, 

#line 48 "session.cog"
        TerminatedStringSpan path);


#line 53 "session.cog"
 

#line 55 "session.cog"
        

#line 55 "session.cog"
     Ptr<

#line 55 "session.cog"
         Name>  getModulePath(

#line 54 "session.cog"
           Session session);


#line 60 "session.cog"
 

#line 62 "session.cog"
        

#line 62 "session.cog"
     Ptr<

#line 62 "session.cog"
         Name>  getModuleName(

#line 61 "session.cog"
           Session session);


#line 67 "session.cog"
 void setEvaluate(

#line 68 "session.cog"
           Session session);


#line 73 "session.cog"
 void loadSourceFile(

#line 74 "session.cog"
           Session session, 

#line 75 "session.cog"
        TerminatedStringSpan path);


#line 83 "session.cog"
 

#line 85 "session.cog"
     Int getErrorCount(

#line 84 "session.cog"
           Session session);


#line 3 "source.cog"
 

#line 17 "source.cog"
 struct Dummy
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};


#line 19 "source.cog"
 struct ExpandedSourceLoc
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 21 "source.cog"
  

#line 21 "source.cog"
             TerminatedStringSpan file;


#line 22 "source.cog"
  

#line 22 "source.cog"
             Int line;


#line 23 "source.cog"
  

#line 23 "source.cog"
               Int column;
};


#line 42 "source.cog"
 

#line 45 "source.cog"
        

#line 45 "source.cog"
     Ptr<

#line 45 "source.cog"
         SourceFile>  getSourceFile(

#line 43 "source.cog"
           Session session, 

#line 44 "source.cog"
        TerminatedStringSpan path);


#line 99 "source.cog"
 

#line 102 "source.cog"
     ExpandedSourceLoc expandLoc(

#line 100 "source.cog"
           Session session, 

#line 101 "source.cog"
       SourceLoc loc);


#line 3 "string.cog"
 

#line 70 "string.cog"
 

#line 70 "string.cog"
                                                 Bool operator==(

#line 70 "string.cog"
               StringSpan left, 

#line 70 "string.cog"
                                  StringSpan right);


#line 81 "string.cog"
 

#line 81 "string.cog"
                                                 Bool operator!=(

#line 81 "string.cog"
               StringSpan left, 

#line 81 "string.cog"
                                  StringSpan right);


#line 3 "syntax.cog"
 

#line 18 "syntax.cog"
 

#line 18 "syntax.cog"
                                  Bool asBool(

#line 18 "syntax.cog"
                      TypeExp typeExp);


#line 23 "syntax.cog"
 template<typename T >
struct SyntaxListIterator
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 25 "syntax.cog"
  

#line 25 "syntax.cog"
                T current;


#line 27 "syntax.cog"
  SyntaxListIterator(

#line 28 "syntax.cog"
            T current);


#line 33 "syntax.cog"
  

#line 33 "syntax.cog"
              T operator*();


#line 38 "syntax.cog"
  void operator++();
};


#line 44 "syntax.cog"
 template<typename T >


#line 44 "syntax.cog"
      

#line 47 "syntax.cog"
     Bool operator!=(

#line 45 "syntax.cog"
                          

#line 45 "syntax.cog"
        SyntaxListIterator<

#line 45 "syntax.cog"
                           T>  left, 

#line 46 "syntax.cog"
                           

#line 46 "syntax.cog"
         SyntaxListIterator<

#line 46 "syntax.cog"
                            T>  right);


#line 52 "syntax.cog"
 template<typename T, typename U >
struct FilteredArrayIter
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 54 "syntax.cog"
  

#line 54 "syntax.cog"
                 

#line 54 "syntax.cog"
                T

#line 54 "syntax.cog"
                 * current;


#line 55 "syntax.cog"
  

#line 55 "syntax.cog"
             

#line 55 "syntax.cog"
            U

#line 55 "syntax.cog"
             * end;


#line 57 "syntax.cog"
  FilteredArrayIter(

#line 57 "syntax.cog"
                 

#line 57 "syntax.cog"
                U

#line 57 "syntax.cog"
                 * current, 

#line 57 "syntax.cog"
                          

#line 57 "syntax.cog"
                         U

#line 57 "syntax.cog"
                          * end);


#line 63 "syntax.cog"
  

#line 63 "syntax.cog"
                                            Bool operator!=(

#line 63 "syntax.cog"
                                  

#line 63 "syntax.cog"
                 FilteredArrayIter<

#line 63 "syntax.cog"
                                   T, 

#line 63 "syntax.cog"
                                     U>  other);


#line 68 "syntax.cog"
     

#line 68 "syntax.cog"
                 T operator*();


#line 70 "syntax.cog"
  void operator++();


#line 75 "syntax.cog"
  

#line 75 "syntax.cog"
                           

#line 75 "syntax.cog"
                          T

#line 75 "syntax.cog"
                           * adjust(

#line 75 "syntax.cog"
                    

#line 75 "syntax.cog"
                   U

#line 75 "syntax.cog"
                    * obj);
};


#line 90 "syntax.cog"
 template<typename T, typename U >
struct FilteredArray
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 92 "syntax.cog"
  

#line 92 "syntax.cog"
                  

#line 92 "syntax.cog"
                 U

#line 92 "syntax.cog"
                  * beginPtr;


#line 93 "syntax.cog"
  

#line 93 "syntax.cog"
                

#line 93 "syntax.cog"
               U

#line 93 "syntax.cog"
                * endPtr;


#line 96 "syntax.cog"
  

#line 96 "syntax.cog"
                                   

#line 96 "syntax.cog"
                  FilteredArrayIter<

#line 96 "syntax.cog"
                                    T, 

#line 96 "syntax.cog"
                                      U>  begin();


#line 101 "syntax.cog"
  

#line 101 "syntax.cog"
                                 

#line 101 "syntax.cog"
                FilteredArrayIter<

#line 101 "syntax.cog"
                                  T, 

#line 101 "syntax.cog"
                                    U>  end();


#line 106 "syntax.cog"
  FilteredArray();


#line 112 "syntax.cog"
  FilteredArray(

#line 112 "syntax.cog"
                  

#line 112 "syntax.cog"
                 U

#line 112 "syntax.cog"
                  * beginPtr, 

#line 112 "syntax.cog"
                              

#line 112 "syntax.cog"
                             U

#line 112 "syntax.cog"
                              * endPtr);


#line 118 "syntax.cog"
  FilteredArray(

#line 118 "syntax.cog"
                     

#line 118 "syntax.cog"
             ConstRef<

#line 118 "syntax.cog"
                           

#line 118 "syntax.cog"
                      Array<

#line 118 "syntax.cog"
                            U> >  list);
};


#line 125 "syntax.cog"
 using Syntax = struct SyntaxImpl* ;
struct SyntaxImpl : cog::ObjectImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 127 "syntax.cog"
  

#line 127 "syntax.cog"
            SourceLoc loc;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::Syntax > { typedef cogc::SyntaxImpl Impl; };
} namespace cogc {


#line 130 "syntax.cog"
 using Attr = struct AttrImpl* ;
struct AttrImpl : 

#line 130 "syntax.cog"
              SyntaxImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::Attr > { typedef cogc::AttrImpl Impl; };
} namespace cogc {


#line 134 "syntax.cog"
 using BuiltinAttr = struct BuiltinAttrImpl* ;
struct BuiltinAttrImpl : 

#line 134 "syntax.cog"
                     AttrImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 136 "syntax.cog"
  

#line 136 "syntax.cog"
                

#line 136 "syntax.cog"
             Ptr<

#line 136 "syntax.cog"
                 Name>  name;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::BuiltinAttr > { typedef cogc::BuiltinAttrImpl Impl; };
} namespace cogc {


#line 139 "syntax.cog"
 using DeclRefClassAttr = struct DeclRefClassAttrImpl* ;
struct DeclRefClassAttrImpl : 

#line 139 "syntax.cog"
                          AttrImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 141 "syntax.cog"
  

#line 141 "syntax.cog"
                       

#line 141 "syntax.cog"
                    Ptr<

#line 141 "syntax.cog"
                        Class>  syntaxClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::DeclRefClassAttr > { typedef cogc::DeclRefClassAttrImpl Impl; };
} namespace cogc {


#line 144 "syntax.cog"
 using Stmt = struct StmtImpl* ;
struct StmtImpl : 

#line 144 "syntax.cog"
              SyntaxImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 146 "syntax.cog"
  

#line 146 "syntax.cog"
                   

#line 146 "syntax.cog"
              Array<

#line 146 "syntax.cog"
                    Attr>  attrs;


#line 148 "syntax.cog"
  

#line 148 "syntax.cog"
                                              Attr findAttrImpl(

#line 148 "syntax.cog"
                                  

#line 148 "syntax.cog"
                               Ptr<

#line 148 "syntax.cog"
                                   Class>  attrClass);


#line 160 "syntax.cog"
  template<typename T >


#line 160 "syntax.cog"
       

#line 160 "syntax.cog"
                        T findAttr();
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::Stmt > { typedef cogc::StmtImpl Impl; };
} namespace cogc {


#line 174 "syntax.cog"
 using Decl = struct DeclImpl* ;
struct DeclImpl : 

#line 174 "syntax.cog"
              StmtImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 176 "syntax.cog"
  

#line 176 "syntax.cog"
                

#line 176 "syntax.cog"
             Ptr<

#line 176 "syntax.cog"
                 Name>  name;


#line 177 "syntax.cog"
  

#line 177 "syntax.cog"
               ContainerStmt parent;


#line 178 "syntax.cog"
  

#line 178 "syntax.cog"
                   DeclCheckState checkState = 

#line 178 "syntax.cog"
                                    kDeclCheckState_Unchecked;


#line 180 "syntax.cog"
  

#line 180 "syntax.cog"
                      ContainerStmt getParent();
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::Decl > { typedef cogc::DeclImpl Impl; };
} namespace cogc {


#line 186 "syntax.cog"
 using SpecializationArg = struct SpecializationArgImpl* ;
struct SpecializationArgImpl : 

#line 186 "syntax.cog"
                           ObjectImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 188 "syntax.cog"
  

#line 188 "syntax.cog"
              Decl param;


#line 189 "syntax.cog"
  

#line 189 "syntax.cog"
              Val value;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::SpecializationArg > { typedef cogc::SpecializationArgImpl Impl; };
} namespace cogc {


#line 192 "syntax.cog"
 using Specializations = struct SpecializationsImpl* ;
struct SpecializationsImpl : 

#line 192 "syntax.cog"
                         ObjectImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 194 "syntax.cog"
  

#line 194 "syntax.cog"
                                     

#line 194 "syntax.cog"
                       DeclRefValImpl<

#line 194 "syntax.cog"
                                      GenericDecl>  genericDeclRef;


#line 195 "syntax.cog"
  

#line 195 "syntax.cog"
                  

#line 195 "syntax.cog"
             Array<

#line 195 "syntax.cog"
                   SpecializationArg>  args;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::Specializations > { typedef cogc::SpecializationsImpl Impl; };
} namespace cogc {


#line 199 "syntax.cog"
 using SpecializedDecl = struct SpecializedDeclImpl* ;
struct SpecializedDeclImpl : 

#line 199 "syntax.cog"
                         ObjectImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 201 "syntax.cog"
  

#line 201 "syntax.cog"
             Decl decl;


#line 202 "syntax.cog"
  

#line 202 "syntax.cog"
                       Specializations specializations;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::SpecializedDecl > { typedef cogc::SpecializedDeclImpl Impl; };
} namespace cogc {


#line 210 "syntax.cog"
 using Val = struct ValImpl* ;
struct ValImpl : 

#line 210 "syntax.cog"
             ObjectImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::Val > { typedef cogc::ValImpl Impl; };
} namespace cogc {


#line 214 "syntax.cog"
 using ContainerStmt = struct ContainerStmtImpl* ;
struct ContainerStmtImpl : 

#line 214 "syntax.cog"
                       DeclImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 216 "syntax.cog"
  

#line 216 "syntax.cog"
                   

#line 216 "syntax.cog"
              Array<

#line 216 "syntax.cog"
                    Stmt>  stmts;


#line 218 "syntax.cog"
  

#line 218 "syntax.cog"
                          

#line 218 "syntax.cog"
                     Array<

#line 218 "syntax.cog"
                           Stmt>  getStmts();


#line 223 "syntax.cog"
  

#line 223 "syntax.cog"
                                  

#line 223 "syntax.cog"
                     FilteredArray<

#line 223 "syntax.cog"
                                   Decl, 

#line 223 "syntax.cog"
                                         Stmt>  getDecls();
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::ContainerStmt > { typedef cogc::ContainerStmtImpl Impl; };
} namespace cogc {


#line 229 "syntax.cog"
 using ContainerDecl = struct ContainerDeclImpl* ;
struct ContainerDeclImpl : 

#line 229 "syntax.cog"
                       ContainerStmtImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 233 "syntax.cog"
  

#line 233 "syntax.cog"
                        

#line 233 "syntax.cog"
                     Ref<

#line 233 "syntax.cog"
                              

#line 233 "syntax.cog"
                         Array<

#line 233 "syntax.cog"
                               Decl> >  getDecls();
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::ContainerDecl > { typedef cogc::ContainerDeclImpl Impl; };
} namespace cogc {


#line 236 "syntax.cog"
 template<typename T >
struct DeclRefListIterator
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 238 "syntax.cog"
  

#line 238 "syntax.cog"
                    

#line 238 "syntax.cog"
                Decl

#line 238 "syntax.cog"
                    * current;


#line 239 "syntax.cog"
  

#line 239 "syntax.cog"
                

#line 239 "syntax.cog"
            Decl

#line 239 "syntax.cog"
                * end;


#line 240 "syntax.cog"
  

#line 240 "syntax.cog"
                        Specializations specializations;


#line 242 "syntax.cog"
  DeclRefListIterator(

#line 243 "syntax.cog"
                 

#line 243 "syntax.cog"
             Decl

#line 243 "syntax.cog"
                 * current, 

#line 244 "syntax.cog"
             

#line 244 "syntax.cog"
         Decl

#line 244 "syntax.cog"
             * end, 

#line 245 "syntax.cog"
                    Specializations specializations);


#line 254 "syntax.cog"
  void operator++();


#line 262 "syntax.cog"
  

#line 262 "syntax.cog"
                            

#line 262 "syntax.cog"
              DeclRefValImpl<

#line 262 "syntax.cog"
                             T>  operator*();


#line 269 "syntax.cog"
  void adjust();
};


#line 282 "syntax.cog"
 template<typename T >
struct DeclRefList
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 284 "syntax.cog"
  

#line 284 "syntax.cog"
                   

#line 284 "syntax.cog"
              Array<

#line 284 "syntax.cog"
                    Decl>  decls;


#line 285 "syntax.cog"
  

#line 285 "syntax.cog"
                        Specializations specializations;


#line 287 "syntax.cog"
  

#line 287 "syntax.cog"
                                     

#line 287 "syntax.cog"
                  DeclRefListIterator<

#line 287 "syntax.cog"
                                      T>  begin();


#line 292 "syntax.cog"
  

#line 292 "syntax.cog"
                                   

#line 292 "syntax.cog"
                DeclRefListIterator<

#line 292 "syntax.cog"
                                    T>  end();


#line 297 "syntax.cog"
  DeclRefList();


#line 303 "syntax.cog"
  DeclRefList(

#line 303 "syntax.cog"
                   

#line 303 "syntax.cog"
              Array<

#line 303 "syntax.cog"
                    Decl>  decls, 

#line 303 "syntax.cog"
                                            Specializations specializations);
};


#line 310 "syntax.cog"
 template<typename T >


#line 310 "syntax.cog"
      

#line 312 "syntax.cog"
                                    Bool operator!=(

#line 311 "syntax.cog"
                           

#line 311 "syntax.cog"
        DeclRefListIterator<

#line 311 "syntax.cog"
                            T>  left, 

#line 312 "syntax.cog"
                            

#line 312 "syntax.cog"
         DeclRefListIterator<

#line 312 "syntax.cog"
                             T>  right);


#line 317 "syntax.cog"
 

#line 318 "syntax.cog"
                

#line 318 "syntax.cog"
     DeclRefList<

#line 318 "syntax.cog"
                 Decl>  getDecls(

#line 317 "syntax.cog"
                                        

#line 317 "syntax.cog"
                          DeclRefValImpl<

#line 317 "syntax.cog"
                                         ContainerDecl>  container);


#line 325 "syntax.cog"
 using GenericDecl = struct GenericDeclImpl* ;
struct GenericDeclImpl : 

#line 325 "syntax.cog"
                     ContainerDeclImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 327 "syntax.cog"
  

#line 327 "syntax.cog"
              Decl inner;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::GenericDecl > { typedef cogc::GenericDeclImpl Impl; };
} namespace cogc {


#line 330 "syntax.cog"
 

#line 331 "syntax.cog"
     DeclRefVal getInner(

#line 330 "syntax.cog"
                                      

#line 330 "syntax.cog"
                        DeclRefValImpl<

#line 330 "syntax.cog"
                                       GenericDecl>  declRef);


#line 338 "syntax.cog"
 using TypeVarDecl = struct TypeVarDeclImpl* ;
struct TypeVarDeclImpl : 

#line 338 "syntax.cog"
                     DeclImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 340 "syntax.cog"
  

#line 340 "syntax.cog"
              TypeExp bound;


#line 341 "syntax.cog"
  

#line 341 "syntax.cog"
             TypeExp init;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::TypeVarDecl > { typedef cogc::TypeVarDeclImpl Impl; };
} namespace cogc {


#line 344 "syntax.cog"
 using ImportDecl = struct ImportDeclImpl* ;
struct ImportDeclImpl : 

#line 344 "syntax.cog"
                    DeclImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 347 "syntax.cog"
  

#line 347 "syntax.cog"
                 

#line 347 "syntax.cog"
              Ptr<

#line 347 "syntax.cog"
                  Scope>  scope;


#line 349 "syntax.cog"
  

#line 349 "syntax.cog"
                

#line 349 "syntax.cog"
             Ptr<

#line 349 "syntax.cog"
                 Name>  name;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::ImportDecl > { typedef cogc::ImportDeclImpl Impl; };
} namespace cogc {


#line 352 "syntax.cog"
 using GenericParamDecl = struct GenericParamDeclImpl* ;
struct GenericParamDeclImpl : 

#line 352 "syntax.cog"
                          TypeVarDeclImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::GenericParamDecl > { typedef cogc::GenericParamDeclImpl Impl; };
} namespace cogc {


#line 356 "syntax.cog"
 

#line 358 "syntax.cog"
     Type getBoundType(

#line 357 "syntax.cog"
                         

#line 357 "syntax.cog"
           DeclRefValImpl<

#line 357 "syntax.cog"
                          GenericParamDecl>  declRef);


#line 365 "syntax.cog"
 using TypeAliasDecl = struct TypeAliasDeclImpl* ;
struct TypeAliasDeclImpl : 

#line 365 "syntax.cog"
                       TypeVarDeclImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::TypeAliasDecl > { typedef cogc::TypeAliasDeclImpl Impl; };
} namespace cogc {


#line 369 "syntax.cog"
 using ModuleDecl = struct ModuleDeclImpl* ;
struct ModuleDeclImpl : 

#line 369 "syntax.cog"
                    ContainerDeclImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::ModuleDecl > { typedef cogc::ModuleDeclImpl Impl; };
} namespace cogc {


#line 373 "syntax.cog"
 using PatternDecl = struct PatternDeclImpl* ;
struct PatternDeclImpl : 

#line 373 "syntax.cog"
                     ContainerDeclImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::PatternDecl > { typedef cogc::PatternDeclImpl Impl; };
} namespace cogc {


#line 377 "syntax.cog"
 using AggTypeDecl = struct AggTypeDeclImpl* ;
struct AggTypeDeclImpl : 

#line 377 "syntax.cog"
                     PatternDeclImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 379 "syntax.cog"
  

#line 379 "syntax.cog"
             TypeExp base;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::AggTypeDecl > { typedef cogc::AggTypeDeclImpl Impl; };
} namespace cogc {


#line 382 "syntax.cog"
 using ClassDecl = struct ClassDeclImpl* ;
struct ClassDeclImpl : 

#line 382 "syntax.cog"
                   AggTypeDeclImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::ClassDecl > { typedef cogc::ClassDeclImpl Impl; };
} namespace cogc {


#line 386 "syntax.cog"
 using StructDecl = struct StructDeclImpl* ;
struct StructDeclImpl : 

#line 386 "syntax.cog"
                    AggTypeDeclImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::StructDecl > { typedef cogc::StructDeclImpl Impl; };
} namespace cogc {


#line 390 "syntax.cog"
 using FuncDeclBase = struct FuncDeclBaseImpl* ;
struct FuncDeclBaseImpl : 

#line 390 "syntax.cog"
                      PatternDeclImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 392 "syntax.cog"
  

#line 392 "syntax.cog"
                   TypeExp resultType;


#line 393 "syntax.cog"
  

#line 393 "syntax.cog"
             Stmt body;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::FuncDeclBase > { typedef cogc::FuncDeclBaseImpl Impl; };
} namespace cogc {


#line 396 "syntax.cog"
 

#line 398 "syntax.cog"
     Type getResultType(

#line 397 "syntax.cog"
                         

#line 397 "syntax.cog"
           DeclRefValImpl<

#line 397 "syntax.cog"
                          FuncDeclBase>  declRef);


#line 405 "syntax.cog"
 using FuncDecl = struct FuncDeclImpl* ;
struct FuncDeclImpl : 

#line 405 "syntax.cog"
                  FuncDeclBaseImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::FuncDecl > { typedef cogc::FuncDeclImpl Impl; };
} namespace cogc {


#line 409 "syntax.cog"
 using SubscriptDecl = struct SubscriptDeclImpl* ;
struct SubscriptDeclImpl : 

#line 409 "syntax.cog"
                       FuncDeclBaseImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::SubscriptDecl > { typedef cogc::SubscriptDeclImpl Impl; };
} namespace cogc {


#line 413 "syntax.cog"
 using InitializerDecl = struct InitializerDeclImpl* ;
struct InitializerDeclImpl : 

#line 413 "syntax.cog"
                         FuncDeclBaseImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::InitializerDecl > { typedef cogc::InitializerDeclImpl Impl; };
} namespace cogc {


#line 417 "syntax.cog"
 using VarDeclBase = struct VarDeclBaseImpl* ;
struct VarDeclBaseImpl : 

#line 417 "syntax.cog"
                     DeclImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 419 "syntax.cog"
  

#line 419 "syntax.cog"
             TypeExp type;


#line 420 "syntax.cog"
  

#line 420 "syntax.cog"
             Exp init;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::VarDeclBase > { typedef cogc::VarDeclBaseImpl Impl; };
} namespace cogc {


#line 423 "syntax.cog"
 

#line 423 "syntax.cog"
                                                       Type getType(

#line 423 "syntax.cog"
                                     

#line 423 "syntax.cog"
                       DeclRefValImpl<

#line 423 "syntax.cog"
                                      VarDeclBase>  declRef);


#line 430 "syntax.cog"
 using VarDecl = struct VarDeclImpl* ;
struct VarDeclImpl : 

#line 430 "syntax.cog"
                 VarDeclBaseImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::VarDecl > { typedef cogc::VarDeclImpl Impl; };
} namespace cogc {


#line 434 "syntax.cog"
 using LetDecl = struct LetDeclImpl* ;
struct LetDeclImpl : 

#line 434 "syntax.cog"
                 VarDeclBaseImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::LetDecl > { typedef cogc::LetDeclImpl Impl; };
} namespace cogc {


#line 438 "syntax.cog"
 using ParamDecl = struct ParamDeclImpl* ;
struct ParamDeclImpl : 

#line 438 "syntax.cog"
                   LetDeclImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::ParamDecl > { typedef cogc::ParamDeclImpl Impl; };
} namespace cogc {


#line 442 "syntax.cog"
 using SyntaxDecl = struct SyntaxDeclImpl* ;
struct SyntaxDeclImpl : 

#line 442 "syntax.cog"
                    DeclImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 444 "syntax.cog"
  

#line 444 "syntax.cog"
                       

#line 444 "syntax.cog"
                    Ptr<

#line 444 "syntax.cog"
                        Class>  syntaxClass;


#line 445 "syntax.cog"
  

#line 445 "syntax.cog"
                 SyntaxCallback callback;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::SyntaxDecl > { typedef cogc::SyntaxDeclImpl Impl; };
} namespace cogc {


#line 450 "syntax.cog"
 using IfStmtBase = struct IfStmtBaseImpl* ;
struct IfStmtBaseImpl : 

#line 450 "syntax.cog"
                    StmtImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 452 "syntax.cog"
  

#line 452 "syntax.cog"
                 Stmt thenStmt;


#line 453 "syntax.cog"
  

#line 453 "syntax.cog"
                 Stmt elseStmt;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::IfStmtBase > { typedef cogc::IfStmtBaseImpl Impl; };
} namespace cogc {


#line 457 "syntax.cog"
 using IfStmt = struct IfStmtImpl* ;
struct IfStmtImpl : 

#line 457 "syntax.cog"
                IfStmtBaseImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 459 "syntax.cog"
  

#line 459 "syntax.cog"
                  Exp condition;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::IfStmt > { typedef cogc::IfStmtImpl Impl; };
} namespace cogc {


#line 462 "syntax.cog"
 using IfLetStmt = struct IfLetStmtImpl* ;
struct IfLetStmtImpl : 

#line 462 "syntax.cog"
                   IfStmtBaseImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 464 "syntax.cog"
  

#line 464 "syntax.cog"
                 

#line 464 "syntax.cog"
             Name

#line 464 "syntax.cog"
                 * name;


#line 465 "syntax.cog"
  

#line 465 "syntax.cog"
             Exp init;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::IfLetStmt > { typedef cogc::IfLetStmtImpl Impl; };
} namespace cogc {


#line 469 "syntax.cog"
 using WhileStmt = struct WhileStmtImpl* ;
struct WhileStmtImpl : 

#line 469 "syntax.cog"
                   StmtImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 471 "syntax.cog"
  

#line 471 "syntax.cog"
                  Exp condition;


#line 472 "syntax.cog"
  

#line 472 "syntax.cog"
             Stmt body;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::WhileStmt > { typedef cogc::WhileStmtImpl Impl; };
} namespace cogc {


#line 475 "syntax.cog"
 using ForStmt = struct ForStmtImpl* ;
struct ForStmtImpl : 

#line 475 "syntax.cog"
                 ContainerStmtImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 477 "syntax.cog"
  

#line 477 "syntax.cog"
             Stmt init;


#line 478 "syntax.cog"
  

#line 478 "syntax.cog"
                  Exp condition;


#line 479 "syntax.cog"
  

#line 479 "syntax.cog"
             Exp iter;


#line 480 "syntax.cog"
  

#line 480 "syntax.cog"
             Stmt body;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::ForStmt > { typedef cogc::ForStmtImpl Impl; };
} namespace cogc {


#line 483 "syntax.cog"
 using ReturnStmt = struct ReturnStmtImpl* ;
struct ReturnStmtImpl : 

#line 483 "syntax.cog"
                    StmtImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 485 "syntax.cog"
  

#line 485 "syntax.cog"
              Exp value;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::ReturnStmt > { typedef cogc::ReturnStmtImpl Impl; };
} namespace cogc {


#line 488 "syntax.cog"
 using BreakStmt = struct BreakStmtImpl* ;
struct BreakStmtImpl : 

#line 488 "syntax.cog"
                   StmtImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::BreakStmt > { typedef cogc::BreakStmtImpl Impl; };
} namespace cogc {


#line 492 "syntax.cog"
 using ContinueStmt = struct ContinueStmtImpl* ;
struct ContinueStmtImpl : 

#line 492 "syntax.cog"
                      StmtImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::ContinueStmt > { typedef cogc::ContinueStmtImpl Impl; };
} namespace cogc {


#line 496 "syntax.cog"
 using SwitchCase = struct SwitchCaseImpl* ;
struct SwitchCaseImpl : 

#line 496 "syntax.cog"
                    SyntaxImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 498 "syntax.cog"
  

#line 498 "syntax.cog"
                    

#line 498 "syntax.cog"
               Array<

#line 498 "syntax.cog"
                     Arg>  values;


#line 499 "syntax.cog"
  

#line 499 "syntax.cog"
             Stmt body;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::SwitchCase > { typedef cogc::SwitchCaseImpl Impl; };
} namespace cogc {


#line 502 "syntax.cog"
 using SwitchStmt = struct SwitchStmtImpl* ;
struct SwitchStmtImpl : 

#line 502 "syntax.cog"
                    StmtImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 504 "syntax.cog"
  

#line 504 "syntax.cog"
                  Exp condition;


#line 505 "syntax.cog"
  

#line 505 "syntax.cog"
                   

#line 505 "syntax.cog"
              Array<

#line 505 "syntax.cog"
                    SwitchCase>  cases;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::SwitchStmt > { typedef cogc::SwitchStmtImpl Impl; };
} namespace cogc {


#line 510 "syntax.cog"
 using Arg = struct ArgImpl* ;
struct ArgImpl : 

#line 510 "syntax.cog"
             SyntaxImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 512 "syntax.cog"
  

#line 512 "syntax.cog"
            Exp exp;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::Arg > { typedef cogc::ArgImpl Impl; };
} namespace cogc {


#line 515 "syntax.cog"
 using PositionalArg = struct PositionalArgImpl* ;
struct PositionalArgImpl : 

#line 515 "syntax.cog"
                       ArgImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::PositionalArg > { typedef cogc::PositionalArgImpl Impl; };
} namespace cogc {


#line 522 "syntax.cog"
 using Exp = struct ExpImpl* ;
struct ExpImpl : 

#line 522 "syntax.cog"
             StmtImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 524 "syntax.cog"
  

#line 524 "syntax.cog"
             Type type;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::Exp > { typedef cogc::ExpImpl Impl; };
} namespace cogc {


#line 527 "syntax.cog"
 using LitExp = struct LitExpImpl* ;
struct LitExpImpl : 

#line 527 "syntax.cog"
                ExpImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::LitExp > { typedef cogc::LitExpImpl Impl; };
} namespace cogc {


#line 533 "syntax.cog"
 using IntLitExp = struct IntLitExpImpl* ;
struct IntLitExpImpl : 

#line 533 "syntax.cog"
                   LitExpImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 535 "syntax.cog"
  

#line 535 "syntax.cog"
            IntLitVal val;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::IntLitExp > { typedef cogc::IntLitExpImpl Impl; };
} namespace cogc {


#line 538 "syntax.cog"
 using StringLitExp = struct StringLitExpImpl* ;
struct StringLitExpImpl : 

#line 538 "syntax.cog"
                      LitExpImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 540 "syntax.cog"
  

#line 540 "syntax.cog"
            String val;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::StringLitExp > { typedef cogc::StringLitExpImpl Impl; };
} namespace cogc {


#line 543 "syntax.cog"
 using CharacterLitExp = struct CharacterLitExpImpl* ;
struct CharacterLitExpImpl : 

#line 543 "syntax.cog"
                         LitExpImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 545 "syntax.cog"
  

#line 545 "syntax.cog"
            String val;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::CharacterLitExp > { typedef cogc::CharacterLitExpImpl Impl; };
} namespace cogc {


#line 549 "syntax.cog"
 using AppExpBase = struct AppExpBaseImpl* ;
struct AppExpBaseImpl : 

#line 549 "syntax.cog"
                    ExpImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 551 "syntax.cog"
  

#line 551 "syntax.cog"
             Exp base;


#line 552 "syntax.cog"
  

#line 552 "syntax.cog"
                  

#line 552 "syntax.cog"
             Array<

#line 552 "syntax.cog"
                   Arg>  args;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::AppExpBase > { typedef cogc::AppExpBaseImpl Impl; };
} namespace cogc {


#line 555 "syntax.cog"
 using GenericAppExp = struct GenericAppExpImpl* ;
struct GenericAppExpImpl : 

#line 555 "syntax.cog"
                       AppExpBaseImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::GenericAppExp > { typedef cogc::GenericAppExpImpl Impl; };
} namespace cogc {


#line 559 "syntax.cog"
 using AppExp = struct AppExpImpl* ;
struct AppExpImpl : 

#line 559 "syntax.cog"
                AppExpBaseImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::AppExp > { typedef cogc::AppExpImpl Impl; };
} namespace cogc {


#line 563 "syntax.cog"
 using IndexExp = struct IndexExpImpl* ;
struct IndexExpImpl : 

#line 563 "syntax.cog"
                  AppExpBaseImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::IndexExp > { typedef cogc::IndexExpImpl Impl; };
} namespace cogc {


#line 567 "syntax.cog"
 using OperatorAppExp = struct OperatorAppExpImpl* ;
struct OperatorAppExpImpl : 

#line 567 "syntax.cog"
                        AppExpImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::OperatorAppExp > { typedef cogc::OperatorAppExpImpl Impl; };
} namespace cogc {


#line 571 "syntax.cog"
 using InfixExp = struct InfixExpImpl* ;
struct InfixExpImpl : 

#line 571 "syntax.cog"
                  OperatorAppExpImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::InfixExp > { typedef cogc::InfixExpImpl Impl; };
} namespace cogc {


#line 575 "syntax.cog"
 using PrefixExp = struct PrefixExpImpl* ;
struct PrefixExpImpl : 

#line 575 "syntax.cog"
                   OperatorAppExpImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::PrefixExp > { typedef cogc::PrefixExpImpl Impl; };
} namespace cogc {


#line 579 "syntax.cog"
 using PostfixExp = struct PostfixExpImpl* ;
struct PostfixExpImpl : 

#line 579 "syntax.cog"
                    OperatorAppExpImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::PostfixExp > { typedef cogc::PostfixExpImpl Impl; };
} namespace cogc {


#line 583 "syntax.cog"
 using AssignExp = struct AssignExpImpl* ;
struct AssignExpImpl : 

#line 583 "syntax.cog"
                   ExpImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 585 "syntax.cog"
  

#line 585 "syntax.cog"
             Exp left;


#line 586 "syntax.cog"
  

#line 586 "syntax.cog"
              Exp right;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::AssignExp > { typedef cogc::AssignExpImpl Impl; };
} namespace cogc {


#line 589 "syntax.cog"
 using DeclRefExp = struct DeclRefExpImpl* ;
struct DeclRefExpImpl : 

#line 589 "syntax.cog"
                    ExpImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 591 "syntax.cog"
  

#line 591 "syntax.cog"
                CompactDeclRef declRef;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::DeclRefExp > { typedef cogc::DeclRefExpImpl Impl; };
} namespace cogc {


#line 594 "syntax.cog"
 using NameExp = struct NameExpImpl* ;
struct NameExpImpl : 

#line 594 "syntax.cog"
                 DeclRefExpImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 596 "syntax.cog"
  

#line 596 "syntax.cog"
                

#line 596 "syntax.cog"
             Ptr<

#line 596 "syntax.cog"
                 Name>  name;


#line 597 "syntax.cog"
  

#line 597 "syntax.cog"
                 

#line 597 "syntax.cog"
              Ptr<

#line 597 "syntax.cog"
                  Scope>  scope;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::NameExp > { typedef cogc::NameExpImpl Impl; };
} namespace cogc {


#line 601 "syntax.cog"
 using MemberExp = struct MemberExpImpl* ;
struct MemberExpImpl : 

#line 601 "syntax.cog"
                   DeclRefExpImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 603 "syntax.cog"
  

#line 603 "syntax.cog"
             Exp base;


#line 604 "syntax.cog"
  

#line 604 "syntax.cog"
                      

#line 604 "syntax.cog"
                   Ptr<

#line 604 "syntax.cog"
                       Name>  memberName;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::MemberExp > { typedef cogc::MemberExpImpl Impl; };
} namespace cogc {


#line 607 "syntax.cog"
 using ErrorExp = struct ErrorExpImpl* ;
struct ErrorExpImpl : 

#line 607 "syntax.cog"
                  ExpImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::ErrorExp > { typedef cogc::ErrorExpImpl Impl; };
} namespace cogc {


#line 657 "syntax.cog"
 using OverloadedExpr = struct OverloadedExprImpl* ;
struct OverloadedExprImpl : 

#line 657 "syntax.cog"
                        ExpImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 659 "syntax.cog"
  

#line 659 "syntax.cog"
                     LookupResult lookupResult;


#line 660 "syntax.cog"
  

#line 660 "syntax.cog"
             Exp base;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::OverloadedExpr > { typedef cogc::OverloadedExprImpl Impl; };
} namespace cogc {


#line 665 "syntax.cog"
 using BlockStmt = struct BlockStmtImpl* ;
struct BlockStmtImpl : 

#line 665 "syntax.cog"
                   ContainerDeclImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::BlockStmt > { typedef cogc::BlockStmtImpl Impl; };
} namespace cogc {


#line 672 "syntax.cog"
 using Type = struct TypeImpl* ;
struct TypeImpl : 

#line 672 "syntax.cog"
              ValImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::Type > { typedef cogc::TypeImpl Impl; };
} namespace cogc {


#line 677 "syntax.cog"
 using DeclRefType = struct DeclRefTypeImpl* ;
struct DeclRefTypeImpl : 

#line 677 "syntax.cog"
                     TypeImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 679 "syntax.cog"
  

#line 679 "syntax.cog"
                CompactDeclRef declRef;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::DeclRefType > { typedef cogc::DeclRefTypeImpl Impl; };
} namespace cogc {


#line 683 "syntax.cog"
 using VoidType = struct VoidTypeImpl* ;
struct VoidTypeImpl : 

#line 683 "syntax.cog"
                  DeclRefTypeImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::VoidType > { typedef cogc::VoidTypeImpl Impl; };
} namespace cogc {


#line 686 "syntax.cog"
 using NullType = struct NullTypeImpl* ;
struct NullTypeImpl : 

#line 686 "syntax.cog"
                  DeclRefTypeImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::NullType > { typedef cogc::NullTypeImpl Impl; };
} namespace cogc {


#line 689 "syntax.cog"
 using PtrType = struct PtrTypeImpl* ;
struct PtrTypeImpl : 

#line 689 "syntax.cog"
                 DeclRefTypeImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::PtrType > { typedef cogc::PtrTypeImpl Impl; };
} namespace cogc {


#line 693 "syntax.cog"
 using ClassType = struct ClassTypeImpl* ;
struct ClassTypeImpl : 

#line 693 "syntax.cog"
                   DeclRefTypeImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::ClassType > { typedef cogc::ClassTypeImpl Impl; };
} namespace cogc {


#line 697 "syntax.cog"
 using TypeType = struct TypeTypeImpl* ;
struct TypeTypeImpl : 

#line 697 "syntax.cog"
                  TypeImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 699 "syntax.cog"
  

#line 699 "syntax.cog"
             Type type;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::TypeType > { typedef cogc::TypeTypeImpl Impl; };
} namespace cogc {


#line 703 "syntax.cog"
 using FuncType = struct FuncTypeImpl* ;
struct FuncTypeImpl : 

#line 703 "syntax.cog"
                  TypeImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::FuncType > { typedef cogc::FuncTypeImpl Impl; };
} namespace cogc {


#line 709 "syntax.cog"
 using ErrorType = struct ErrorTypeImpl* ;
struct ErrorTypeImpl : 

#line 709 "syntax.cog"
                   TypeImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::ErrorType > { typedef cogc::ErrorTypeImpl Impl; };
} namespace cogc {


#line 714 "syntax.cog"
 using OverloadGroupType = struct OverloadGroupTypeImpl* ;
struct OverloadGroupTypeImpl : 

#line 714 "syntax.cog"
                           TypeImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::OverloadGroupType > { typedef cogc::OverloadGroupTypeImpl Impl; };
} namespace cogc {


#line 721 "syntax.cog"
 using EnumDecl = struct EnumDeclImpl* ;
struct EnumDeclImpl : 

#line 721 "syntax.cog"
                  AggTypeDeclImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::EnumDecl > { typedef cogc::EnumDeclImpl Impl; };
} namespace cogc {


#line 724 "syntax.cog"
 using EnumTagDecl = struct EnumTagDeclImpl* ;
struct EnumTagDeclImpl : 

#line 724 "syntax.cog"
                     VarDeclBaseImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::EnumTagDecl > { typedef cogc::EnumTagDeclImpl Impl; };
} namespace cogc {


#line 727 "syntax.cog"
 using ForEachStmt = struct ForEachStmtImpl* ;
struct ForEachStmtImpl : 

#line 727 "syntax.cog"
                     StmtImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 729 "syntax.cog"
  

#line 729 "syntax.cog"
                 

#line 729 "syntax.cog"
             Name

#line 729 "syntax.cog"
                 * name;


#line 730 "syntax.cog"
  

#line 730 "syntax.cog"
           Exp exp;


#line 731 "syntax.cog"
  

#line 731 "syntax.cog"
            Stmt body;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::ForEachStmt > { typedef cogc::ForEachStmtImpl Impl; };
} namespace cogc {


#line 734 "syntax.cog"
 using ParenExp = struct ParenExpImpl* ;
struct ParenExpImpl : 

#line 734 "syntax.cog"
                  ExpImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 736 "syntax.cog"
  

#line 736 "syntax.cog"
            Exp base;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::ParenExp > { typedef cogc::ParenExpImpl Impl; };
} namespace cogc {


#line 741 "syntax.cog"
 using ThisExpr = struct ThisExprImpl* ;
struct ThisExprImpl : 

#line 741 "syntax.cog"
                  ExpImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 743 "syntax.cog"
  

#line 743 "syntax.cog"
                   

#line 743 "syntax.cog"
              Scope

#line 743 "syntax.cog"
                   * scope;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::ThisExpr > { typedef cogc::ThisExprImpl Impl; };
} namespace cogc {


#line 746 "syntax.cog"
 using CastExpr = struct CastExprImpl* ;
struct CastExprImpl : 

#line 746 "syntax.cog"
                  ExpImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;


#line 748 "syntax.cog"
  

#line 748 "syntax.cog"
               TypeExp toType;


#line 749 "syntax.cog"
  

#line 749 "syntax.cog"
            Exp arg;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::CastExpr > { typedef cogc::CastExprImpl Impl; };
} namespace cogc {


#line 752 "syntax.cog"
 using NullLitExpr = struct NullLitExprImpl* ;
struct NullLitExprImpl : 

#line 752 "syntax.cog"
                     ExpImpl
{
typedef cog::Class StaticClass;
static StaticClass staticClass;
};
} namespace cog {
template<> struct ObjectClassImpl<cogc::NullLitExpr > { typedef cogc::NullLitExprImpl Impl; };
} namespace cogc {


#line 3 "token.cog"
 

#line 7 "token.cog"
 enum TokenFlag : int
{
kTokenFlag_AtStartOfLine = 

#line 9 "token.cog"
                                

#line 9 "token.cog"
                              1 

#line 9 "token.cog"
                                << 

#line 9 "token.cog"
                                   0,
kTokenFlag_AfterSpace = 

#line 10 "token.cog"
                              

#line 10 "token.cog"
                            1 

#line 10 "token.cog"
                              << 

#line 10 "token.cog"
                                 1,
};


#line 3 "check.cog"
 

#line 5 "check.cog"
 void checkModule(

#line 6 "check.cog"
              Session session)
{


#line 8 "check.cog"
             

#line 8 "check.cog"
             

#line 8 "check.cog"
  checkModule(

#line 8 "check.cog"
              session, 

#line 8 "check.cog"
                              DEREF(

#line 8 "check.cog"
                       session).moduleDecl);
}


#line 12 "check.cog"
 void checkModule(

#line 13 "check.cog"
           Session session, 

#line 14 "check.cog"
              ModuleDecl moduleDecl)
{


#line 16 "check.cog"
  

#line 16 "check.cog"
  

#line 16 "check.cog"
                      SharedCheckContext sharedContext;


#line 17 "check.cog"
               DEREF(

#line 17 "check.cog"
  sharedContext).session = 

#line 17 "check.cog"
                          session;


#line 19 "check.cog"
  

#line 19 "check.cog"
  

#line 19 "check.cog"
                CheckContext context;


#line 20 "check.cog"
         DEREF(

#line 20 "check.cog"
  context).shared = 

#line 20 "check.cog"
                   

#line 20 "check.cog"
                   &

#line 20 "check.cog"
                    sharedContext;


#line 22 "check.cog"
             

#line 22 "check.cog"
             

#line 22 "check.cog"
  checkModule(

#line 22 "check.cog"
              

#line 22 "check.cog"
              &

#line 22 "check.cog"
               context, 

#line 22 "check.cog"
                        moduleDecl);
}


#line 25 "check.cog"
 

#line 30 "check.cog"
 

#line 38 "diagnostic.cog"
 

#line 35 "check.cog"
 

#line 36 "check.cog"
                                           

#line 36 "check.cog"
                             DiagnosticSink

#line 36 "check.cog"
                                           * getSink(

#line 36 "check.cog"
                       

#line 36 "check.cog"
           CheckContext

#line 36 "check.cog"
                       * context)
{


#line 38 "check.cog"
  return 

#line 38 "check.cog"
         

#line 38 "check.cog"
         &

#line 38 "check.cog"
                                DEREF(

#line 38 "check.cog"
                        DEREF(

#line 38 "check.cog"
                 DEREF(

#line 38 "check.cog"
          context).shared).session).sink;
}


#line 41 "check.cog"
 void checkModule(

#line 42 "check.cog"
                       

#line 42 "check.cog"
           CheckContext

#line 42 "check.cog"
                       * context, 

#line 43 "check.cog"
              ModuleDecl moduleDecl)
{


#line 45 "check.cog"
            

#line 45 "check.cog"
            

#line 45 "check.cog"
  checkDecls(

#line 45 "check.cog"
             context, 

#line 45 "check.cog"
                      moduleDecl);
}


#line 48 "check.cog"
 void checkImportDecls(

#line 49 "check.cog"
                       

#line 49 "check.cog"
           CheckContext

#line 49 "check.cog"
                       * context, 

#line 50 "check.cog"
                 ContainerDecl containerDecl)
{


#line 52 "check.cog"
  for(auto decl : 

#line 52 "check.cog"
                                        

#line 52 "check.cog"
                               DEREF(

#line 52 "check.cog"
                  containerDecl).getDecls())
{
{


#line 54 "check.cog"
   if(auto importDecl = 

#line 54 "check.cog"
                                     

#line 54 "check.cog"
                         

#line 54 "check.cog"
                       as<

#line 54 "check.cog"
                          ImportDecl> (

#line 54 "check.cog"
                                      decl))
{


#line 58 "check.cog"
       

#line 58 "check.cog"
       auto module = 

#line 58 "check.cog"
                                      

#line 58 "check.cog"
                    findOrImportModule(

#line 58 "check.cog"
                                                     DEREF(

#line 58 "check.cog"
                                              DEREF(

#line 58 "check.cog"
                                       context).shared).session, 

#line 58 "check.cog"
                                                                         DEREF(

#line 58 "check.cog"
                                                               importDecl).loc, 

#line 58 "check.cog"
                                                                                         DEREF(

#line 58 "check.cog"
                                                                               importDecl).name);


#line 60 "check.cog"
                    

#line 60 "check.cog"
                    

#line 60 "check.cog"
       attachToScope(

#line 60 "check.cog"
                               DEREF(

#line 60 "check.cog"
                     importDecl).scope, 

#line 60 "check.cog"
                                       module);
}
}
}
}


#line 66 "check.cog"
 void checkDecls(

#line 67 "check.cog"
                         

#line 67 "check.cog"
             CheckContext

#line 67 "check.cog"
                         * context, 

#line 68 "check.cog"
                  ContainerDecl containerDecl)
{


#line 70 "check.cog"
                  

#line 70 "check.cog"
                  

#line 70 "check.cog"
  checkImportDecls(

#line 70 "check.cog"
                   context, 

#line 70 "check.cog"
                            containerDecl);


#line 72 "check.cog"
  for(auto decl : 

#line 72 "check.cog"
                                        

#line 72 "check.cog"
                               DEREF(

#line 72 "check.cog"
                  containerDecl).getDecls())
{
{


#line 74 "check.cog"
            

#line 74 "check.cog"
            

#line 74 "check.cog"
   checkDecl(

#line 74 "check.cog"
             context, 

#line 74 "check.cog"
                      decl);
}
}
}


#line 5 "scope.cog"
 

#line 11 "scope.cog"
 

#line 78 "check.cog"
 void attachToScope(

#line 79 "check.cog"
              

#line 79 "check.cog"
         Scope

#line 79 "check.cog"
              * scope, 

#line 80 "check.cog"
         ContainerDecl decl)
{


#line 82 "check.cog"
     

#line 82 "check.cog"
     auto link = 

#line 82 "check.cog"
                cast<

#line 82 "check.cog"
                        

#line 82 "check.cog"
                     Ptr<

#line 82 "check.cog"
                         ScopeLink> >(

#line 82 "check.cog"
                                            

#line 82 "check.cog"
                                      malloc(

#line 82 "check.cog"
                                                   

#line 82 "check.cog"
                                             sizeof(

#line 82 "check.cog"
                                                    ScopeLink)));


#line 83 "check.cog"
      DEREF(

#line 83 "check.cog"
  link).container = 

#line 83 "check.cog"
                   decl;


#line 84 "check.cog"
      DEREF(

#line 84 "check.cog"
  link).next = 

#line 84 "check.cog"
              nullptr;


#line 86 "check.cog"
      DEREF(

#line 86 "check.cog"
  link).next = 

#line 86 "check.cog"
                              DEREF(

#line 86 "check.cog"
                   DEREF(

#line 86 "check.cog"
              scope).directLink).next;


#line 87 "check.cog"
                  DEREF(

#line 87 "check.cog"
       DEREF(

#line 87 "check.cog"
  scope).directLink).next = 

#line 87 "check.cog"
                          link;
}


#line 90 "check.cog"
 void checkDecl(

#line 91 "check.cog"
                        

#line 91 "check.cog"
            CheckContext

#line 91 "check.cog"
                        * context, 

#line 92 "check.cog"
         Decl decl)
{


#line 95 "check.cog"
  if(

#line 95 "check.cog"
                     

#line 95 "check.cog"
         DEREF(

#line 95 "check.cog"
     decl).checkState 

#line 95 "check.cog"
                     == 

#line 95 "check.cog"
                        kDeclCheckState_Checked)
{


#line 96 "check.cog"
   return;
}


#line 98 "check.cog"
  if(

#line 98 "check.cog"
                     

#line 98 "check.cog"
         DEREF(

#line 98 "check.cog"
     decl).checkState 

#line 98 "check.cog"
                     != 

#line 98 "check.cog"
                        kDeclCheckState_Unchecked)
{


#line 101 "check.cog"
           

#line 101 "check.cog"
           

#line 101 "check.cog"
   diagnose(

#line 101 "check.cog"
                   

#line 101 "check.cog"
            getSink(

#line 101 "check.cog"
                    context), 

#line 101 "check.cog"
                                  DEREF(

#line 101 "check.cog"
                              decl).loc, 

#line 101 "check.cog"
                                        kDiagnostic_unimplemented, 

#line 101 "check.cog"
                                                                   "circularity");


#line 102 "check.cog"
   return;
}


#line 105 "check.cog"
      DEREF(

#line 105 "check.cog"
  decl).checkState = 

#line 105 "check.cog"
                    kDeclCheckState_CheckingHead;


#line 106 "check.cog"
               

#line 106 "check.cog"
               

#line 106 "check.cog"
  checkDeclImpl(

#line 106 "check.cog"
                context, 

#line 106 "check.cog"
                         decl);


#line 107 "check.cog"
      DEREF(

#line 107 "check.cog"
  decl).checkState = 

#line 107 "check.cog"
                    kDeclCheckState_Checked;
}


#line 110 "check.cog"
 void checkDeclImpl(

#line 111 "check.cog"
                        

#line 111 "check.cog"
            CheckContext

#line 111 "check.cog"
                        * context, 

#line 112 "check.cog"
         Decl decl)
{


#line 114 "check.cog"
  if(auto classDecl = 

#line 114 "check.cog"
                                  

#line 114 "check.cog"
                       

#line 114 "check.cog"
                     as<

#line 114 "check.cog"
                        ClassDecl> (

#line 114 "check.cog"
                                   decl))
{


#line 116 "check.cog"
                 

#line 116 "check.cog"
                 

#line 116 "check.cog"
   checkClassDecl(

#line 116 "check.cog"
                  context, 

#line 116 "check.cog"
                           classDecl);
}
else
{


#line 118 "check.cog"
       if(auto structDecl = 

#line 118 "check.cog"
                                         

#line 118 "check.cog"
                             

#line 118 "check.cog"
                           as<

#line 118 "check.cog"
                              StructDecl> (

#line 118 "check.cog"
                                          decl))
{


#line 120 "check.cog"
                  

#line 120 "check.cog"
                  

#line 120 "check.cog"
   checkStructDecl(

#line 120 "check.cog"
                   context, 

#line 120 "check.cog"
                            structDecl);
}
else
{


#line 122 "check.cog"
       if(auto funcDecl = 

#line 122 "check.cog"
                                         

#line 122 "check.cog"
                           

#line 122 "check.cog"
                         as<

#line 122 "check.cog"
                            FuncDeclBase> (

#line 122 "check.cog"
                                          decl))
{


#line 124 "check.cog"
                

#line 124 "check.cog"
                

#line 124 "check.cog"
   checkFuncDecl(

#line 124 "check.cog"
                 context, 

#line 124 "check.cog"
                          funcDecl);
}
else
{


#line 126 "check.cog"
       if(auto varDecl = 

#line 126 "check.cog"
                                       

#line 126 "check.cog"
                          

#line 126 "check.cog"
                        as<

#line 126 "check.cog"
                           VarDeclBase> (

#line 126 "check.cog"
                                        decl))
{


#line 128 "check.cog"
               

#line 128 "check.cog"
               

#line 128 "check.cog"
   checkVarDecl(

#line 128 "check.cog"
                context, 

#line 128 "check.cog"
                         varDecl);
}
else
{


#line 130 "check.cog"
       if(auto genericDecl = 

#line 130 "check.cog"
                                           

#line 130 "check.cog"
                              

#line 130 "check.cog"
                            as<

#line 130 "check.cog"
                               GenericDecl> (

#line 130 "check.cog"
                                            decl))
{


#line 132 "check.cog"
                   

#line 132 "check.cog"
                   

#line 132 "check.cog"
   checkGenericDecl(

#line 132 "check.cog"
                    context, 

#line 132 "check.cog"
                             genericDecl);
}
else
{


#line 134 "check.cog"
       if(auto typeAliasDecl = 

#line 134 "check.cog"
                                               

#line 134 "check.cog"
                                

#line 134 "check.cog"
                              as<

#line 134 "check.cog"
                                 TypeAliasDecl> (

#line 134 "check.cog"
                                                decl))
{


#line 136 "check.cog"
                     

#line 136 "check.cog"
                     

#line 136 "check.cog"
   checkTypeAliasDecl(

#line 136 "check.cog"
                      context, 

#line 136 "check.cog"
                               typeAliasDecl);
}
else
{


#line 138 "check.cog"
       if(auto genericParamDecl = 

#line 138 "check.cog"
                                                     

#line 138 "check.cog"
                                   

#line 138 "check.cog"
                                 as<

#line 138 "check.cog"
                                    GenericParamDecl> (

#line 138 "check.cog"
                                                      decl))
{
}
else
{


#line 142 "check.cog"
          if(auto importDecl = 

#line 142 "check.cog"
                                            

#line 142 "check.cog"
                                

#line 142 "check.cog"
                              as<

#line 142 "check.cog"
                                 ImportDecl> (

#line 142 "check.cog"
                                             decl))
{
}
else
{
}
}
}
}
}
}
}
}
}


#line 152 "check.cog"
 void checkGenericDecl(

#line 153 "check.cog"
                       

#line 153 "check.cog"
           CheckContext

#line 153 "check.cog"
                       * context, 

#line 154 "check.cog"
        GenericDecl decl)
{


#line 159 "check.cog"
            

#line 159 "check.cog"
            

#line 159 "check.cog"
  checkDecls(

#line 159 "check.cog"
             context, 

#line 159 "check.cog"
                      decl);


#line 161 "check.cog"
      DEREF(

#line 161 "check.cog"
  decl).checkState = 

#line 161 "check.cog"
                    kDeclCheckState_CheckedHead;


#line 164 "check.cog"
           

#line 164 "check.cog"
           

#line 164 "check.cog"
  checkDecl(

#line 164 "check.cog"
            context, 

#line 164 "check.cog"
                         DEREF(

#line 164 "check.cog"
                     decl).inner);
}


#line 167 "check.cog"
 void checkTypeAliasDecl(

#line 168 "check.cog"
                       

#line 168 "check.cog"
           CheckContext

#line 168 "check.cog"
                       * context, 

#line 169 "check.cog"
        TypeAliasDecl decl)
{
}


#line 174 "check.cog"
 void checkVarDecl(

#line 175 "check.cog"
                       

#line 175 "check.cog"
           CheckContext

#line 175 "check.cog"
                       * context, 

#line 176 "check.cog"
        VarDeclBase decl)
{


#line 179 "check.cog"
              

#line 179 "check.cog"
              

#line 179 "check.cog"
  checkTypeExp(

#line 179 "check.cog"
               context, 

#line 179 "check.cog"
                        

#line 179 "check.cog"
                        &

#line 179 "check.cog"
                             DEREF(

#line 179 "check.cog"
                         decl).type);


#line 180 "check.cog"
     

#line 180 "check.cog"
     auto type = 

#line 180 "check.cog"
                         DEREF(

#line 180 "check.cog"
                    DEREF(

#line 180 "check.cog"
                decl).type).type;


#line 182 "check.cog"
     

#line 182 "check.cog"
     auto initExpr = 

#line 182 "check.cog"
                        DEREF(

#line 182 "check.cog"
                    decl).init;


#line 183 "check.cog"
     if(

#line 183 "check.cog"
        initExpr)
{


#line 185 "check.cog"
         initExpr = 

#line 185 "check.cog"
                             

#line 185 "check.cog"
                    checkTerm(

#line 185 "check.cog"
                              context, 

#line 185 "check.cog"
                                       initExpr);


#line 186 "check.cog"
         if(

#line 186 "check.cog"
            type)
{


#line 188 "check.cog"
             initExpr = 

#line 188 "check.cog"
                              

#line 188 "check.cog"
                        coerce(

#line 188 "check.cog"
                               context, 

#line 188 "check.cog"
                                        initExpr, 

#line 188 "check.cog"
                                                  type);
}
else
{


#line 194 "check.cog"
             type = 

#line 194 "check.cog"
                            DEREF(

#line 194 "check.cog"
                    initExpr).type;
}
}
else
{


#line 199 "check.cog"
         if(

#line 199 "check.cog"
            

#line 199 "check.cog"
            !

#line 199 "check.cog"
             type)
{


#line 201 "check.cog"
                     

#line 201 "check.cog"
                     

#line 201 "check.cog"
             diagnose(

#line 201 "check.cog"
                             

#line 201 "check.cog"
                      getSink(

#line 201 "check.cog"
                              context), 

#line 201 "check.cog"
                                            DEREF(

#line 201 "check.cog"
                                        decl).loc, 

#line 201 "check.cog"
                                                  kDiagnostic_unimplemented, 

#line 201 "check.cog"
                                                                             "decl without init must have type");


#line 202 "check.cog"
             type = 

#line 202 "check.cog"
                                   

#line 202 "check.cog"
                    createErrorType(

#line 202 "check.cog"
                                    context);
}
}


#line 211 "check.cog"
         DEREF(

#line 211 "check.cog"
     decl).init = 

#line 211 "check.cog"
                 initExpr;


#line 212 "check.cog"
              DEREF(

#line 212 "check.cog"
         DEREF(

#line 212 "check.cog"
     decl).type).type = 

#line 212 "check.cog"
                      type;
}


#line 215 "check.cog"
 void checkFuncDecl(

#line 216 "check.cog"
                       

#line 216 "check.cog"
           CheckContext

#line 216 "check.cog"
                       * context, 

#line 217 "check.cog"
        FuncDeclBase decl)
{


#line 220 "check.cog"
            

#line 220 "check.cog"
            

#line 220 "check.cog"
  checkDecls(

#line 220 "check.cog"
             context, 

#line 220 "check.cog"
                      decl);


#line 223 "check.cog"
              

#line 223 "check.cog"
              

#line 223 "check.cog"
  checkTypeExp(

#line 223 "check.cog"
               context, 

#line 223 "check.cog"
                        

#line 223 "check.cog"
                        &

#line 223 "check.cog"
                             DEREF(

#line 223 "check.cog"
                         decl).resultType);


#line 224 "check.cog"
     if(

#line 224 "check.cog"
        

#line 224 "check.cog"
        !

#line 224 "check.cog"
               

#line 224 "check.cog"
         asBool(

#line 224 "check.cog"
                    DEREF(

#line 224 "check.cog"
                decl).resultType))
{


#line 226 "check.cog"
                        DEREF(

#line 226 "check.cog"
             DEREF(

#line 226 "check.cog"
         decl).resultType).type = 

#line 226 "check.cog"
                                              

#line 226 "check.cog"
                                getBuiltinType(

#line 226 "check.cog"
                                               context, 

#line 226 "check.cog"
                                                            DEREF(

#line 226 "check.cog"
                                                        decl).loc, 

#line 226 "check.cog"
                                                                  "Void");
}


#line 229 "check.cog"
      DEREF(

#line 229 "check.cog"
  decl).checkState = 

#line 229 "check.cog"
                    kDeclCheckState_CheckedHead;


#line 231 "check.cog"
  if(auto body = 

#line 231 "check.cog"
                    DEREF(

#line 231 "check.cog"
                decl).body)
{


#line 233 "check.cog"
       DEREF(

#line 233 "check.cog"
   decl).body = 

#line 233 "check.cog"
                        

#line 233 "check.cog"
               checkStmt(

#line 233 "check.cog"
                         context, 

#line 233 "check.cog"
                                  body);
}
}


#line 237 "check.cog"
 void checkClassDecl(

#line 238 "check.cog"
                       

#line 238 "check.cog"
           CheckContext

#line 238 "check.cog"
                       * context, 

#line 239 "check.cog"
        ClassDecl decl)
{


#line 241 "check.cog"
                        

#line 241 "check.cog"
                        

#line 241 "check.cog"
  checkAggTypeDeclCommon(

#line 241 "check.cog"
                         context, 

#line 241 "check.cog"
                                  decl);
}


#line 244 "check.cog"
 void checkStructDecl(

#line 245 "check.cog"
                       

#line 245 "check.cog"
           CheckContext

#line 245 "check.cog"
                       * context, 

#line 246 "check.cog"
        StructDecl decl)
{


#line 248 "check.cog"
                        

#line 248 "check.cog"
                        

#line 248 "check.cog"
  checkAggTypeDeclCommon(

#line 248 "check.cog"
                         context, 

#line 248 "check.cog"
                                  decl);
}


#line 251 "check.cog"
 void checkAggTypeDeclCommon(

#line 252 "check.cog"
                       

#line 252 "check.cog"
           CheckContext

#line 252 "check.cog"
                       * context, 

#line 253 "check.cog"
        AggTypeDecl decl)
{


#line 256 "check.cog"
              

#line 256 "check.cog"
              

#line 256 "check.cog"
  checkTypeExp(

#line 256 "check.cog"
               context, 

#line 256 "check.cog"
                        

#line 256 "check.cog"
                        &

#line 256 "check.cog"
                             DEREF(

#line 256 "check.cog"
                         decl).base);


#line 258 "check.cog"
      DEREF(

#line 258 "check.cog"
  decl).checkState = 

#line 258 "check.cog"
                    kDeclCheckState_CheckedHead;


#line 264 "check.cog"
            

#line 264 "check.cog"
            

#line 264 "check.cog"
  checkDecls(

#line 264 "check.cog"
             context, 

#line 264 "check.cog"
                      decl);
}


#line 269 "check.cog"
 

#line 272 "check.cog"
     Exp checkPrediateExpr(

#line 270 "check.cog"
                       

#line 270 "check.cog"
           CheckContext

#line 270 "check.cog"
                       * context, 

#line 271 "check.cog"
        Exp expr)
{


#line 275 "check.cog"
  return 

#line 275 "check.cog"
                 

#line 275 "check.cog"
         checkExp(

#line 275 "check.cog"
                  context, 

#line 275 "check.cog"
                           expr);
}


#line 278 "check.cog"
 

#line 281 "check.cog"
     Stmt checkStmt(

#line 279 "check.cog"
                       

#line 279 "check.cog"
           CheckContext

#line 279 "check.cog"
                       * context, 

#line 280 "check.cog"
        Stmt stmt)
{


#line 283 "check.cog"
     if(

#line 283 "check.cog"
        

#line 283 "check.cog"
        !

#line 283 "check.cog"
         stmt)
{


#line 284 "check.cog"
         return 

#line 284 "check.cog"
                nullptr;
}


#line 286 "check.cog"
  if(auto blockStmt = 

#line 286 "check.cog"
                                  

#line 286 "check.cog"
                       

#line 286 "check.cog"
                     as<

#line 286 "check.cog"
                        BlockStmt> (

#line 286 "check.cog"
                                   stmt))
{


#line 288 "check.cog"
   return 

#line 288 "check.cog"
                        

#line 288 "check.cog"
          checkBlockStmt(

#line 288 "check.cog"
                         context, 

#line 288 "check.cog"
                                  blockStmt);
}
else
{


#line 290 "check.cog"
          if(auto decl = 

#line 290 "check.cog"
                                

#line 290 "check.cog"
                          

#line 290 "check.cog"
                        as<

#line 290 "check.cog"
                           Decl> (

#line 290 "check.cog"
                                 stmt))
{


#line 292 "check.cog"
                  

#line 292 "check.cog"
                  

#line 292 "check.cog"
         checkDecl(

#line 292 "check.cog"
                   context, 

#line 292 "check.cog"
                            decl);


#line 293 "check.cog"
         return 

#line 293 "check.cog"
                decl;
}
else
{


#line 295 "check.cog"
          if(auto exp = 

#line 295 "check.cog"
                              

#line 295 "check.cog"
                         

#line 295 "check.cog"
                       as<

#line 295 "check.cog"
                          Exp> (

#line 295 "check.cog"
                               stmt))
{


#line 297 "check.cog"
         return 

#line 297 "check.cog"
                        

#line 297 "check.cog"
                checkExp(

#line 297 "check.cog"
                         context, 

#line 297 "check.cog"
                                  exp);
}
else
{


#line 299 "check.cog"
          if(auto ifStmt = 

#line 299 "check.cog"
                                    

#line 299 "check.cog"
                            

#line 299 "check.cog"
                          as<

#line 299 "check.cog"
                             IfStmt> (

#line 299 "check.cog"
                                     stmt))
{


#line 301 "check.cog"
               DEREF(

#line 301 "check.cog"
         ifStmt).condition = 

#line 301 "check.cog"
                                             

#line 301 "check.cog"
                            checkPrediateExpr(

#line 301 "check.cog"
                                              context, 

#line 301 "check.cog"
                                                             DEREF(

#line 301 "check.cog"
                                                       ifStmt).condition);


#line 302 "check.cog"
               DEREF(

#line 302 "check.cog"
         ifStmt).thenStmt = 

#line 302 "check.cog"
                                    

#line 302 "check.cog"
                           checkStmt(

#line 302 "check.cog"
                                     context, 

#line 302 "check.cog"
                                                    DEREF(

#line 302 "check.cog"
                                              ifStmt).thenStmt);


#line 303 "check.cog"
               DEREF(

#line 303 "check.cog"
         ifStmt).elseStmt = 

#line 303 "check.cog"
                                    

#line 303 "check.cog"
                           checkStmt(

#line 303 "check.cog"
                                     context, 

#line 303 "check.cog"
                                                    DEREF(

#line 303 "check.cog"
                                              ifStmt).elseStmt);


#line 304 "check.cog"
         return 

#line 304 "check.cog"
                ifStmt;
}
else
{


#line 306 "check.cog"
          if(auto ifLetStmt = 

#line 306 "check.cog"
                                          

#line 306 "check.cog"
                               

#line 306 "check.cog"
                             as<

#line 306 "check.cog"
                                IfLetStmt> (

#line 306 "check.cog"
                                           stmt))
{


#line 308 "check.cog"
                  DEREF(

#line 308 "check.cog"
         ifLetStmt).init = 

#line 308 "check.cog"
                                       

#line 308 "check.cog"
                              checkExp(

#line 308 "check.cog"
                                        context, 

#line 308 "check.cog"
                                                          DEREF(

#line 308 "check.cog"
                                                 ifLetStmt).init);


#line 309 "check.cog"
                  DEREF(

#line 309 "check.cog"
         ifLetStmt).thenStmt = 

#line 309 "check.cog"
                                       

#line 309 "check.cog"
                              checkStmt(

#line 309 "check.cog"
                                        context, 

#line 309 "check.cog"
                                                          DEREF(

#line 309 "check.cog"
                                                 ifLetStmt).thenStmt);


#line 310 "check.cog"
                  DEREF(

#line 310 "check.cog"
         ifLetStmt).elseStmt = 

#line 310 "check.cog"
                                       

#line 310 "check.cog"
                              checkStmt(

#line 310 "check.cog"
                                        context, 

#line 310 "check.cog"
                                                          DEREF(

#line 310 "check.cog"
                                                 ifLetStmt).elseStmt);


#line 311 "check.cog"
         return 

#line 311 "check.cog"
                ifLetStmt;
}
else
{


#line 313 "check.cog"
          if(auto whileStmt = 

#line 313 "check.cog"
                                          

#line 313 "check.cog"
                               

#line 313 "check.cog"
                             as<

#line 313 "check.cog"
                                WhileStmt> (

#line 313 "check.cog"
                                           stmt))
{


#line 315 "check.cog"
                  DEREF(

#line 315 "check.cog"
         whileStmt).condition = 

#line 315 "check.cog"
                                                

#line 315 "check.cog"
                               checkPrediateExpr(

#line 315 "check.cog"
                                                 context, 

#line 315 "check.cog"
                                                                   DEREF(

#line 315 "check.cog"
                                                          whileStmt).condition);


#line 316 "check.cog"
                  DEREF(

#line 316 "check.cog"
         whileStmt).body = 

#line 316 "check.cog"
                                   

#line 316 "check.cog"
                          checkStmt(

#line 316 "check.cog"
                                    context, 

#line 316 "check.cog"
                                                      DEREF(

#line 316 "check.cog"
                                             whileStmt).body);


#line 317 "check.cog"
         return 

#line 317 "check.cog"
                whileStmt;
}
else
{


#line 319 "check.cog"
          if(auto forStmt = 

#line 319 "check.cog"
                                      

#line 319 "check.cog"
                             

#line 319 "check.cog"
                           as<

#line 319 "check.cog"
                              ForStmt> (

#line 319 "check.cog"
                                       stmt))
{


#line 321 "check.cog"
                DEREF(

#line 321 "check.cog"
         forStmt).init = 

#line 321 "check.cog"
                                 

#line 321 "check.cog"
                        checkStmt(

#line 321 "check.cog"
                                  context, 

#line 321 "check.cog"
                                                  DEREF(

#line 321 "check.cog"
                                           forStmt).init);


#line 322 "check.cog"
                DEREF(

#line 322 "check.cog"
         forStmt).condition = 

#line 322 "check.cog"
                                              

#line 322 "check.cog"
                             checkPrediateExpr(

#line 322 "check.cog"
                                               context, 

#line 322 "check.cog"
                                                               DEREF(

#line 322 "check.cog"
                                                        forStmt).condition);


#line 323 "check.cog"
                DEREF(

#line 323 "check.cog"
         forStmt).iter = 

#line 323 "check.cog"
                                

#line 323 "check.cog"
                        checkExp(

#line 323 "check.cog"
                                 context, 

#line 323 "check.cog"
                                                 DEREF(

#line 323 "check.cog"
                                          forStmt).iter);


#line 324 "check.cog"
                DEREF(

#line 324 "check.cog"
         forStmt).body = 

#line 324 "check.cog"
                                 

#line 324 "check.cog"
                        checkStmt(

#line 324 "check.cog"
                                  context, 

#line 324 "check.cog"
                                                  DEREF(

#line 324 "check.cog"
                                           forStmt).body);


#line 325 "check.cog"
         return 

#line 325 "check.cog"
                forStmt;
}
else
{


#line 327 "check.cog"
          if(auto forEachStmt = 

#line 327 "check.cog"
                                              

#line 327 "check.cog"
                                 

#line 327 "check.cog"
                               as<

#line 327 "check.cog"
                                  ForEachStmt> (

#line 327 "check.cog"
                                               stmt))
{


#line 330 "check.cog"
                    DEREF(

#line 330 "check.cog"
         forEachStmt).exp = 

#line 330 "check.cog"
                                   

#line 330 "check.cog"
                           checkExp(

#line 330 "check.cog"
                                    context, 

#line 330 "check.cog"
                                                        DEREF(

#line 330 "check.cog"
                                             forEachStmt).exp);


#line 331 "check.cog"
                    DEREF(

#line 331 "check.cog"
         forEachStmt).body = 

#line 331 "check.cog"
                                     

#line 331 "check.cog"
                            checkStmt(

#line 331 "check.cog"
                                      context, 

#line 331 "check.cog"
                                                          DEREF(

#line 331 "check.cog"
                                               forEachStmt).body);


#line 332 "check.cog"
         return 

#line 332 "check.cog"
                forEachStmt;
}
else
{


#line 334 "check.cog"
          if(auto returnStmt = 

#line 334 "check.cog"
                                            

#line 334 "check.cog"
                                

#line 334 "check.cog"
                              as<

#line 334 "check.cog"
                                 ReturnStmt> (

#line 334 "check.cog"
                                             stmt))
{


#line 337 "check.cog"
                   DEREF(

#line 337 "check.cog"
         returnStmt).value = 

#line 337 "check.cog"
                                    

#line 337 "check.cog"
                            checkExp(

#line 337 "check.cog"
                                     context, 

#line 337 "check.cog"
                                                        DEREF(

#line 337 "check.cog"
                                              returnStmt).value);


#line 338 "check.cog"
         return 

#line 338 "check.cog"
                returnStmt;
}
else
{


#line 340 "check.cog"
          if(auto breakStmt = 

#line 340 "check.cog"
                                          

#line 340 "check.cog"
                               

#line 340 "check.cog"
                             as<

#line 340 "check.cog"
                                BreakStmt> (

#line 340 "check.cog"
                                           stmt))
{


#line 343 "check.cog"
         return 

#line 343 "check.cog"
                breakStmt;
}
else
{


#line 345 "check.cog"
          if(auto continueStmt = 

#line 345 "check.cog"
                                                

#line 345 "check.cog"
                                  

#line 345 "check.cog"
                                as<

#line 345 "check.cog"
                                   ContinueStmt> (

#line 345 "check.cog"
                                                 stmt))
{


#line 348 "check.cog"
         return 

#line 348 "check.cog"
                continueStmt;
}
else
{


#line 350 "check.cog"
          if(auto switchStmt = 

#line 350 "check.cog"
                                            

#line 350 "check.cog"
                                

#line 350 "check.cog"
                              as<

#line 350 "check.cog"
                                 SwitchStmt> (

#line 350 "check.cog"
                                             stmt))
{


#line 352 "check.cog"
                   DEREF(

#line 352 "check.cog"
         switchStmt).condition = 

#line 352 "check.cog"
                                        

#line 352 "check.cog"
                                checkExp(

#line 352 "check.cog"
                                         context, 

#line 352 "check.cog"
                                                            DEREF(

#line 352 "check.cog"
                                                  switchStmt).condition);


#line 353 "check.cog"
   for(auto c : 

#line 353 "check.cog"
                          DEREF(

#line 353 "check.cog"
                switchStmt).cases)
{
{


#line 355 "check.cog"
    for(auto a : 

#line 355 "check.cog"
                  DEREF(

#line 355 "check.cog"
                 c).values)
{
{


#line 357 "check.cog"
      DEREF(

#line 357 "check.cog"
     a).exp = 

#line 357 "check.cog"
                     

#line 357 "check.cog"
             checkExp(

#line 357 "check.cog"
                      context, 

#line 357 "check.cog"
                                DEREF(

#line 357 "check.cog"
                               a).exp);
}
}


#line 360 "check.cog"
     DEREF(

#line 360 "check.cog"
    c).body = 

#line 360 "check.cog"
                      

#line 360 "check.cog"
             checkStmt(

#line 360 "check.cog"
                       context, 

#line 360 "check.cog"
                                 DEREF(

#line 360 "check.cog"
                                c).body);
}
}


#line 363 "check.cog"
         return 

#line 363 "check.cog"
                switchStmt;
}
else
{


#line 367 "check.cog"
                 

#line 367 "check.cog"
                 

#line 367 "check.cog"
         diagnose(

#line 367 "check.cog"
                         

#line 367 "check.cog"
                  getSink(

#line 367 "check.cog"
                          context), 

#line 367 "check.cog"
                                        DEREF(

#line 367 "check.cog"
                                    stmt).loc, 

#line 367 "check.cog"
                                              kDiagnostic_unimplemented, 

#line 367 "check.cog"
                                                                                         DEREF(

#line 367 "check.cog"
                                                                             DEREF(

#line 367 "check.cog"
                                                                         stmt).directClass).name);


#line 368 "check.cog"
            

#line 368 "check.cog"
            

#line 368 "check.cog"
   cogAssert(

#line 368 "check.cog"
             

#line 368 "check.cog"
             !

#line 368 "check.cog"
              "unimplemented");
}
}
}
}
}
}
}
}
}
}
}
}
}


#line 372 "check.cog"
 

#line 375 "check.cog"
     Stmt checkBlockStmt(

#line 373 "check.cog"
                       

#line 373 "check.cog"
           CheckContext

#line 373 "check.cog"
                       * context, 

#line 374 "check.cog"
        BlockStmt stmt)
{


#line 377 "check.cog"
  for(auto stmt : 

#line 377 "check.cog"
                      DEREF(

#line 377 "check.cog"
                  stmt).stmts)
{
{


#line 379 "check.cog"
            

#line 379 "check.cog"
            

#line 379 "check.cog"
   checkStmt(

#line 379 "check.cog"
             context, 

#line 379 "check.cog"
                      stmt);
}
}


#line 382 "check.cog"
  return 

#line 382 "check.cog"
         stmt;
}


#line 387 "check.cog"
 

#line 390 "check.cog"
     Exp checkExp(

#line 388 "check.cog"
                       

#line 388 "check.cog"
           CheckContext

#line 388 "check.cog"
                       * context, 

#line 389 "check.cog"
       Exp exp)
{


#line 393 "check.cog"
  return 

#line 393 "check.cog"
                    

#line 393 "check.cog"
         coerceToExp(

#line 393 "check.cog"
                     context, 

#line 393 "check.cog"
                                       

#line 393 "check.cog"
                              checkTerm(

#line 393 "check.cog"
                                        context, 

#line 393 "check.cog"
                                                 exp));
}


#line 396 "check.cog"
 

#line 399 "check.cog"
     Exp coerceToExp(

#line 397 "check.cog"
                       

#line 397 "check.cog"
           CheckContext

#line 397 "check.cog"
                       * context, 

#line 398 "check.cog"
        Syntax term)
{


#line 401 "check.cog"
  if(

#line 401 "check.cog"
     

#line 401 "check.cog"
     !

#line 401 "check.cog"
      term)
{


#line 402 "check.cog"
   return 

#line 402 "check.cog"
          nullptr;
}


#line 404 "check.cog"
     if(auto exp = 

#line 404 "check.cog"
                         

#line 404 "check.cog"
                    

#line 404 "check.cog"
                  as<

#line 404 "check.cog"
                     Exp> (

#line 404 "check.cog"
                          term))
{


#line 406 "check.cog"
         return 

#line 406 "check.cog"
                exp;
}


#line 409 "check.cog"
              

#line 409 "check.cog"
              

#line 409 "check.cog"
     cogAssert(

#line 409 "check.cog"
               

#line 409 "check.cog"
               !

#line 409 "check.cog"
                "need an exp");
}


#line 414 "check.cog"
 

#line 417 "check.cog"
     Type checkType(

#line 415 "check.cog"
                       

#line 415 "check.cog"
           CheckContext

#line 415 "check.cog"
                       * context, 

#line 416 "check.cog"
       Exp exp)
{


#line 420 "check.cog"
  return 

#line 420 "check.cog"
                     

#line 420 "check.cog"
         coerceToType(

#line 420 "check.cog"
                      context, 

#line 420 "check.cog"
                                        

#line 420 "check.cog"
                               checkTerm(

#line 420 "check.cog"
                                         context, 

#line 420 "check.cog"
                                                  exp));
}


#line 5 "syntax.cog"
 

#line 423 "check.cog"
 void checkTypeExp(

#line 424 "check.cog"
                       

#line 424 "check.cog"
           CheckContext

#line 424 "check.cog"
                       * context, 

#line 425 "check.cog"
                  

#line 425 "check.cog"
           TypeExp

#line 425 "check.cog"
                  * typeExp)
{


#line 427 "check.cog"
  

#line 427 "check.cog"
  auto exp = 

#line 427 "check.cog"
                   DEREF(

#line 427 "check.cog"
            typeExp).exp;


#line 428 "check.cog"
  if(

#line 428 "check.cog"
     

#line 428 "check.cog"
     !

#line 428 "check.cog"
      exp)
{


#line 429 "check.cog"
   return;
}


#line 431 "check.cog"
  

#line 431 "check.cog"
  auto type = 

#line 431 "check.cog"
                      

#line 431 "check.cog"
             checkType(

#line 431 "check.cog"
                       context, 

#line 431 "check.cog"
                                exp);


#line 432 "check.cog"
         DEREF(

#line 432 "check.cog"
  typeExp).type = 

#line 432 "check.cog"
                 type;
}


#line 435 "check.cog"
 

#line 438 "check.cog"
     Exp tryCoerceToTypeExpr(

#line 436 "check.cog"
                       

#line 436 "check.cog"
           CheckContext

#line 436 "check.cog"
                       * context, 

#line 437 "check.cog"
       Exp exp)
{


#line 440 "check.cog"
  

#line 440 "check.cog"
  auto expType = 

#line 440 "check.cog"
                   DEREF(

#line 440 "check.cog"
                exp).type;


#line 441 "check.cog"
  if(auto typeType = 

#line 441 "check.cog"
                                

#line 441 "check.cog"
                      

#line 441 "check.cog"
                    as<

#line 441 "check.cog"
                       TypeType> (

#line 441 "check.cog"
                                 expType))
{


#line 443 "check.cog"
   return 

#line 443 "check.cog"
          exp;
}
else
{


#line 445 "check.cog"
          if(auto errorType = 

#line 445 "check.cog"
                                          

#line 445 "check.cog"
                               

#line 445 "check.cog"
                             as<

#line 445 "check.cog"
                                ErrorType> (

#line 445 "check.cog"
                                           expType))
{


#line 447 "check.cog"
         return 

#line 447 "check.cog"
                exp;
}
else
{


#line 451 "check.cog"
   return 

#line 451 "check.cog"
          nullptr;
}
}
}


#line 456 "check.cog"
 

#line 459 "check.cog"
     Type tryCoerceToType(

#line 457 "check.cog"
                       

#line 457 "check.cog"
           CheckContext

#line 457 "check.cog"
                       * context, 

#line 458 "check.cog"
       Exp exp)
{


#line 461 "check.cog"
  

#line 461 "check.cog"
  auto typeExpr = 

#line 461 "check.cog"
                                    

#line 461 "check.cog"
                 tryCoerceToTypeExpr(

#line 461 "check.cog"
                                     context, 

#line 461 "check.cog"
                                              exp);


#line 462 "check.cog"
  if(

#line 462 "check.cog"
     

#line 462 "check.cog"
     !

#line 462 "check.cog"
      typeExpr)
{


#line 463 "check.cog"
   return 

#line 463 "check.cog"
          nullptr;
}


#line 465 "check.cog"
  

#line 465 "check.cog"
  auto exprType = 

#line 465 "check.cog"
                         DEREF(

#line 465 "check.cog"
                 typeExpr).type;


#line 466 "check.cog"
  if(auto typeType = 

#line 466 "check.cog"
                                

#line 466 "check.cog"
                      

#line 466 "check.cog"
                    as<

#line 466 "check.cog"
                       TypeType> (

#line 466 "check.cog"
                                 exprType))
{


#line 468 "check.cog"
   return 

#line 468 "check.cog"
                  DEREF(

#line 468 "check.cog"
          typeType).type;
}
else
{


#line 470 "check.cog"
          if(auto errorType = 

#line 470 "check.cog"
                                          

#line 470 "check.cog"
                               

#line 470 "check.cog"
                             as<

#line 470 "check.cog"
                                ErrorType> (

#line 470 "check.cog"
                                           exprType))
{


#line 472 "check.cog"
         return 

#line 472 "check.cog"
                errorType;
}
else
{


#line 476 "check.cog"
   return 

#line 476 "check.cog"
          nullptr;
}
}
}


#line 480 "check.cog"
 

#line 483 "check.cog"
     Type coerceToType(

#line 481 "check.cog"
                       

#line 481 "check.cog"
           CheckContext

#line 481 "check.cog"
                       * context, 

#line 482 "check.cog"
       Exp exp)
{


#line 485 "check.cog"
  if(auto type = 

#line 485 "check.cog"
                               

#line 485 "check.cog"
                tryCoerceToType(

#line 485 "check.cog"
                                context, 

#line 485 "check.cog"
                                         exp))
{


#line 487 "check.cog"
   return 

#line 487 "check.cog"
          type;
}
else
{


#line 491 "check.cog"
                 

#line 491 "check.cog"
                 

#line 491 "check.cog"
         diagnose(

#line 491 "check.cog"
                         

#line 491 "check.cog"
                  getSink(

#line 491 "check.cog"
                          context), 

#line 491 "check.cog"
                                       DEREF(

#line 491 "check.cog"
                                    exp).loc, 

#line 491 "check.cog"
                                             kDiagnostic_unimplemented, 

#line 491 "check.cog"
                                                                                            DEREF(

#line 491 "check.cog"
                                                                                DEREF(

#line 491 "check.cog"
                                                                           DEREF(

#line 491 "check.cog"
                                                                        exp).type).directClass).name);


#line 492 "check.cog"
   return 

#line 492 "check.cog"
                         

#line 492 "check.cog"
          createErrorType(

#line 492 "check.cog"
                          context);
}
}


#line 496 "check.cog"
 

#line 499 "check.cog"
     Exp coerceToTypeExpr(

#line 497 "check.cog"
                       

#line 497 "check.cog"
           CheckContext

#line 497 "check.cog"
                       * context, 

#line 498 "check.cog"
       Exp exp)
{


#line 501 "check.cog"
  if(auto typeExpr = 

#line 501 "check.cog"
                                       

#line 501 "check.cog"
                    tryCoerceToTypeExpr(

#line 501 "check.cog"
                                        context, 

#line 501 "check.cog"
                                                 exp))
{


#line 503 "check.cog"
   return 

#line 503 "check.cog"
          typeExpr;
}
else
{


#line 507 "check.cog"
                 

#line 507 "check.cog"
                 

#line 507 "check.cog"
         diagnose(

#line 507 "check.cog"
                         

#line 507 "check.cog"
                  getSink(

#line 507 "check.cog"
                          context), 

#line 507 "check.cog"
                                       DEREF(

#line 507 "check.cog"
                                    exp).loc, 

#line 507 "check.cog"
                                             kDiagnostic_unimplemented, 

#line 507 "check.cog"
                                                                                            DEREF(

#line 507 "check.cog"
                                                                                DEREF(

#line 507 "check.cog"
                                                                           DEREF(

#line 507 "check.cog"
                                                                        exp).type).directClass).name);


#line 508 "check.cog"
   return 

#line 508 "check.cog"
                        

#line 508 "check.cog"
          createErrorExp(

#line 508 "check.cog"
                         context, 

#line 508 "check.cog"
                                  exp);
}
}


#line 514 "check.cog"
 

#line 517 "check.cog"
     Exp makeErrorExpr(

#line 515 "check.cog"
                       

#line 515 "check.cog"
           CheckContext

#line 515 "check.cog"
                       * context, 

#line 516 "check.cog"
        Exp expr)
{


#line 519 "check.cog"
  

#line 519 "check.cog"
  auto errorType = 

#line 519 "check.cog"
                                         

#line 519 "check.cog"
                              

#line 519 "check.cog"
                  createObject<

#line 519 "check.cog"
                               ErrorType> ();


#line 520 "check.cog"
      DEREF(

#line 520 "check.cog"
  expr).type = 

#line 520 "check.cog"
              errorType;


#line 521 "check.cog"
  return 

#line 521 "check.cog"
         expr;
}


#line 524 "check.cog"
 

#line 527 "check.cog"
     Exp checkTerm(

#line 525 "check.cog"
                       

#line 525 "check.cog"
           CheckContext

#line 525 "check.cog"
                       * context, 

#line 526 "check.cog"
       Exp exp)
{


#line 529 "check.cog"
  if(

#line 529 "check.cog"
     

#line 529 "check.cog"
     !

#line 529 "check.cog"
      exp)
{


#line 529 "check.cog"
           return 

#line 529 "check.cog"
                  nullptr;
}


#line 531 "check.cog"
  if(auto nameExp = 

#line 531 "check.cog"
                              

#line 531 "check.cog"
                     

#line 531 "check.cog"
                   as<

#line 531 "check.cog"
                      NameExp> (

#line 531 "check.cog"
                               exp))
{


#line 533 "check.cog"
   

#line 533 "check.cog"
   auto scope = 

#line 533 "check.cog"
                      DEREF(

#line 533 "check.cog"
               nameExp).scope;


#line 534 "check.cog"
         

#line 534 "check.cog"
         auto result = 

#line 534 "check.cog"
                            

#line 534 "check.cog"
                      lookup(

#line 534 "check.cog"
                             scope, 

#line 534 "check.cog"
                                           DEREF(

#line 534 "check.cog"
                                    nameExp).name);


#line 535 "check.cog"
         if(

#line 535 "check.cog"
                          

#line 535 "check.cog"
                  DEREF(

#line 535 "check.cog"
            result).isEmpty())
{


#line 538 "check.cog"
            

#line 538 "check.cog"
            

#line 538 "check.cog"
    diagnose(

#line 538 "check.cog"
                    

#line 538 "check.cog"
             getSink(

#line 538 "check.cog"
                     context), 

#line 538 "check.cog"
                                      DEREF(

#line 538 "check.cog"
                               nameExp).loc, 

#line 538 "check.cog"
                                            kDiagnostic_undefinedIdentifier, 

#line 538 "check.cog"
                                                                                    DEREF(

#line 538 "check.cog"
                                                                             nameExp).name);


#line 539 "check.cog"
             return 

#line 539 "check.cog"
                                  

#line 539 "check.cog"
                    createErrorExp(

#line 539 "check.cog"
                                   context, 

#line 539 "check.cog"
                                                   DEREF(

#line 539 "check.cog"
                                            nameExp).loc);
}
else
{


#line 541 "check.cog"
              if(

#line 541 "check.cog"
                 

#line 541 "check.cog"
                 !

#line 541 "check.cog"
                                     

#line 541 "check.cog"
                        DEREF(

#line 541 "check.cog"
                  result).isOverloaded())
{


#line 544 "check.cog"
             

#line 544 "check.cog"
             auto declRef = 

#line 544 "check.cog"
                                         

#line 544 "check.cog"
                           CompactDeclRef(

#line 544 "check.cog"
                                                        

#line 544 "check.cog"
                                                DEREF(

#line 544 "check.cog"
                                          result).getDecl());


#line 545 "check.cog"
             

#line 545 "check.cog"
             auto declRefExp = 

#line 545 "check.cog"
                                                      

#line 545 "check.cog"
                                          

#line 545 "check.cog"
                              createObject<

#line 545 "check.cog"
                                           DeclRefExp> ();


#line 546 "check.cog"
                       DEREF(

#line 546 "check.cog"
             declRefExp).loc = 

#line 546 "check.cog"
                                 DEREF(

#line 546 "check.cog"
                              exp).loc;


#line 547 "check.cog"
                       DEREF(

#line 547 "check.cog"
             declRefExp).declRef = 

#line 547 "check.cog"
                                  declRef;


#line 548 "check.cog"
                       DEREF(

#line 548 "check.cog"
             declRefExp).type = 

#line 548 "check.cog"
                                                

#line 548 "check.cog"
                               getTypeForDeclRef(

#line 548 "check.cog"
                                                 context, 

#line 548 "check.cog"
                                                          declRef);


#line 549 "check.cog"
             return 

#line 549 "check.cog"
                    declRefExp;
}
else
{


#line 553 "check.cog"
             

#line 553 "check.cog"
             auto overloadedExpr = 

#line 553 "check.cog"
                                                              

#line 553 "check.cog"
                                              

#line 553 "check.cog"
                                  createObject<

#line 553 "check.cog"
                                               OverloadedExpr> ();


#line 554 "check.cog"
                           DEREF(

#line 554 "check.cog"
             overloadedExpr).loc = 

#line 554 "check.cog"
                                     DEREF(

#line 554 "check.cog"
                                  exp).loc;


#line 555 "check.cog"
                           DEREF(

#line 555 "check.cog"
             overloadedExpr).lookupResult = 

#line 555 "check.cog"
                                           result;


#line 556 "check.cog"
                           DEREF(

#line 556 "check.cog"
             overloadedExpr).type = 

#line 556 "check.cog"
                                                                   

#line 556 "check.cog"
                                                

#line 556 "check.cog"
                                    createObject<

#line 556 "check.cog"
                                                 OverloadGroupType> ();


#line 557 "check.cog"
             return 

#line 557 "check.cog"
                    overloadedExpr;
}
}
}
else
{


#line 560 "check.cog"
          if(auto memberExp = 

#line 560 "check.cog"
                                          

#line 560 "check.cog"
                               

#line 560 "check.cog"
                             as<

#line 560 "check.cog"
                                MemberExp> (

#line 560 "check.cog"
                                           exp))
{


#line 562 "check.cog"
         return 

#line 562 "check.cog"
                              

#line 562 "check.cog"
                checkMemberExp(

#line 562 "check.cog"
                               context, 

#line 562 "check.cog"
                                        memberExp);
}
else
{


#line 565 "check.cog"
          if(auto intLitExp = 

#line 565 "check.cog"
                                          

#line 565 "check.cog"
                               

#line 565 "check.cog"
                             as<

#line 565 "check.cog"
                                IntLitExp> (

#line 565 "check.cog"
                                           exp))
{


#line 568 "check.cog"
                  DEREF(

#line 568 "check.cog"
         intLitExp).type = 

#line 568 "check.cog"
                                        

#line 568 "check.cog"
                          getBuiltinType(

#line 568 "check.cog"
                                         context, 

#line 568 "check.cog"
                                                           DEREF(

#line 568 "check.cog"
                                                  intLitExp).loc, 

#line 568 "check.cog"
                                                                 "Int");


#line 569 "check.cog"
         return 

#line 569 "check.cog"
                intLitExp;
}
else
{


#line 571 "check.cog"
          if(auto stringLitExp = 

#line 571 "check.cog"
                                                

#line 571 "check.cog"
                                  

#line 571 "check.cog"
                                as<

#line 571 "check.cog"
                                   StringLitExp> (

#line 571 "check.cog"
                                                 exp))
{


#line 574 "check.cog"
                     DEREF(

#line 574 "check.cog"
         stringLitExp).type = 

#line 574 "check.cog"
                                           

#line 574 "check.cog"
                             getBuiltinType(

#line 574 "check.cog"
                                            context, 

#line 574 "check.cog"
                                                                 DEREF(

#line 574 "check.cog"
                                                     stringLitExp).loc, 

#line 574 "check.cog"
                                                                       "String");


#line 575 "check.cog"
         return 

#line 575 "check.cog"
                stringLitExp;
}
else
{


#line 577 "check.cog"
          if(auto charLitExp = 

#line 577 "check.cog"
                                                 

#line 577 "check.cog"
                                

#line 577 "check.cog"
                              as<

#line 577 "check.cog"
                                 CharacterLitExp> (

#line 577 "check.cog"
                                                  exp))
{


#line 580 "check.cog"
                   DEREF(

#line 580 "check.cog"
         charLitExp).type = 

#line 580 "check.cog"
                                         

#line 580 "check.cog"
                           getBuiltinType(

#line 580 "check.cog"
                                          context, 

#line 580 "check.cog"
                                                             DEREF(

#line 580 "check.cog"
                                                   charLitExp).loc, 

#line 580 "check.cog"
                                                                   "Char");


#line 581 "check.cog"
         return 

#line 581 "check.cog"
                charLitExp;
}
else
{


#line 583 "check.cog"
          if(auto assignExp = 

#line 583 "check.cog"
                                          

#line 583 "check.cog"
                               

#line 583 "check.cog"
                             as<

#line 583 "check.cog"
                                AssignExp> (

#line 583 "check.cog"
                                           exp))
{


#line 585 "check.cog"
         

#line 585 "check.cog"
         auto left = 

#line 585 "check.cog"
                            

#line 585 "check.cog"
                    checkExp(

#line 585 "check.cog"
                             context, 

#line 585 "check.cog"
                                               DEREF(

#line 585 "check.cog"
                                      assignExp).left);


#line 586 "check.cog"
         

#line 586 "check.cog"
         auto right = 

#line 586 "check.cog"
                              

#line 586 "check.cog"
                     checkTerm(

#line 586 "check.cog"
                               context, 

#line 586 "check.cog"
                                                 DEREF(

#line 586 "check.cog"
                                        assignExp).right);


#line 587 "check.cog"
         right = 

#line 587 "check.cog"
                       

#line 587 "check.cog"
                 coerce(

#line 587 "check.cog"
                        context, 

#line 587 "check.cog"
                                 right, 

#line 587 "check.cog"
                                            DEREF(

#line 587 "check.cog"
                                        left).type);


#line 589 "check.cog"
                  DEREF(

#line 589 "check.cog"
         assignExp).left = 

#line 589 "check.cog"
                          left;


#line 590 "check.cog"
                  DEREF(

#line 590 "check.cog"
         assignExp).right = 

#line 590 "check.cog"
                           right;


#line 591 "check.cog"
                  DEREF(

#line 591 "check.cog"
         assignExp).type = 

#line 591 "check.cog"
                              DEREF(

#line 591 "check.cog"
                          left).type;


#line 592 "check.cog"
         return 

#line 592 "check.cog"
                assignExp;
}
else
{


#line 594 "check.cog"
          if(auto indexExp = 

#line 594 "check.cog"
                                        

#line 594 "check.cog"
                              

#line 594 "check.cog"
                            as<

#line 594 "check.cog"
                               IndexExp> (

#line 594 "check.cog"
                                         exp))
{


#line 596 "check.cog"
         

#line 596 "check.cog"
         auto base = 

#line 596 "check.cog"
                             

#line 596 "check.cog"
                    checkTerm(

#line 596 "check.cog"
                              context, 

#line 596 "check.cog"
                                               DEREF(

#line 596 "check.cog"
                                       indexExp).base);


#line 597 "check.cog"
                 DEREF(

#line 597 "check.cog"
         indexExp).base = 

#line 597 "check.cog"
                         base;


#line 598 "check.cog"
         for(auto arg : 

#line 598 "check.cog"
                                DEREF(

#line 598 "check.cog"
                        indexExp).args)
{
{


#line 600 "check.cog"
                DEREF(

#line 600 "check.cog"
             arg).exp = 

#line 600 "check.cog"
                                

#line 600 "check.cog"
                       checkTerm(

#line 600 "check.cog"
                                 context, 

#line 600 "check.cog"
                                             DEREF(

#line 600 "check.cog"
                                          arg).exp);
}
}


#line 605 "check.cog"
         if(

#line 605 "check.cog"
                               

#line 605 "check.cog"
                        

#line 605 "check.cog"
              

#line 605 "check.cog"
            as<

#line 605 "check.cog"
               ErrorExp> (

#line 605 "check.cog"
                         base) 

#line 605 "check.cog"
                               || 

#line 605 "check.cog"
                                               

#line 605 "check.cog"
                                    

#line 605 "check.cog"
                                  as<

#line 605 "check.cog"
                                     ErrorType> (

#line 605 "check.cog"
                                                    DEREF(

#line 605 "check.cog"
                                                base).type))
{


#line 607 "check.cog"
             return 

#line 607 "check.cog"
                                  

#line 607 "check.cog"
                    createErrorExp(

#line 607 "check.cog"
                                   context, 

#line 607 "check.cog"
                                                    DEREF(

#line 607 "check.cog"
                                            indexExp).loc);
}


#line 610 "check.cog"
         

#line 610 "check.cog"
         

#line 610 "check.cog"
                               OverloadResolveContext overloadContext;


#line 611 "check.cog"
                        DEREF(

#line 611 "check.cog"
         overloadContext).checkContext = 

#line 611 "check.cog"
                                        context;


#line 612 "check.cog"
                        DEREF(

#line 612 "check.cog"
         overloadContext).appExp = 

#line 612 "check.cog"
                                  indexExp;


#line 613 "check.cog"
                        DEREF(

#line 613 "check.cog"
         overloadContext).baseExp = 

#line 613 "check.cog"
                                   base;


#line 615 "check.cog"
         

#line 615 "check.cog"
         auto baseType = 

#line 615 "check.cog"
                            DEREF(

#line 615 "check.cog"
                        base).type;


#line 616 "check.cog"
         if(auto baseDeclRefType = 

#line 616 "check.cog"
                                                 

#line 616 "check.cog"
                                    

#line 616 "check.cog"
                                  as<

#line 616 "check.cog"
                                     DeclRefType> (

#line 616 "check.cog"
                                                  baseType))
{


#line 618 "check.cog"
             

#line 618 "check.cog"
             auto baseDeclRef = 

#line 618 "check.cog"
                                              DEREF(

#line 618 "check.cog"
                               baseDeclRefType).declRef;


#line 619 "check.cog"
             if(auto aggTypeDeclRef = 

#line 619 "check.cog"
                                                    

#line 619 "check.cog"
                                       

#line 619 "check.cog"
                                     as<

#line 619 "check.cog"
                                        AggTypeDecl> (

#line 619 "check.cog"
                                                     baseDeclRef))
{


#line 623 "check.cog"
                 for(auto memberDeclRef : 

#line 623 "check.cog"
                                                  

#line 623 "check.cog"
                                          getDecls(

#line 623 "check.cog"
                                                   aggTypeDeclRef))
{
{


#line 625 "check.cog"
                     if(auto memberSubscriptDeclRef = 

#line 625 "check.cog"
                                                                      

#line 625 "check.cog"
                                                       

#line 625 "check.cog"
                                                     as<

#line 625 "check.cog"
                                                        SubscriptDecl> (

#line 625 "check.cog"
                                                                       memberDeclRef))
{


#line 627 "check.cog"
                                                      

#line 627 "check.cog"
                                                      

#line 627 "check.cog"
                         addSubscriptOverloadCandidate(

#line 627 "check.cog"
                                                       

#line 627 "check.cog"
                                                       &

#line 627 "check.cog"
                                                        overloadContext, 

#line 627 "check.cog"
                                                                         memberSubscriptDeclRef);
}
}
}
}
}


#line 634 "check.cog"
         return 

#line 634 "check.cog"
                                

#line 634 "check.cog"
                completeOverload(

#line 634 "check.cog"
                                 

#line 634 "check.cog"
                                 &

#line 634 "check.cog"
                                  overloadContext);
}
else
{


#line 636 "check.cog"
          if(auto appExp = 

#line 636 "check.cog"
                                    

#line 636 "check.cog"
                            

#line 636 "check.cog"
                          as<

#line 636 "check.cog"
                             AppExp> (

#line 636 "check.cog"
                                     exp))
{


#line 638 "check.cog"
         

#line 638 "check.cog"
         auto base = 

#line 638 "check.cog"
                             

#line 638 "check.cog"
                    checkTerm(

#line 638 "check.cog"
                              context, 

#line 638 "check.cog"
                                             DEREF(

#line 638 "check.cog"
                                       appExp).base);


#line 639 "check.cog"
               DEREF(

#line 639 "check.cog"
         appExp).base = 

#line 639 "check.cog"
                       base;


#line 640 "check.cog"
         for(auto arg : 

#line 640 "check.cog"
                              DEREF(

#line 640 "check.cog"
                        appExp).args)
{
{


#line 642 "check.cog"
                DEREF(

#line 642 "check.cog"
             arg).exp = 

#line 642 "check.cog"
                                

#line 642 "check.cog"
                       checkTerm(

#line 642 "check.cog"
                                 context, 

#line 642 "check.cog"
                                             DEREF(

#line 642 "check.cog"
                                          arg).exp);
}
}


#line 647 "check.cog"
         if(

#line 647 "check.cog"
                   

#line 647 "check.cog"
            isError(

#line 647 "check.cog"
                    context, 

#line 647 "check.cog"
                             base))
{


#line 649 "check.cog"
             return 

#line 649 "check.cog"
                                  

#line 649 "check.cog"
                    createErrorExp(

#line 649 "check.cog"
                                   context, 

#line 649 "check.cog"
                                            appExp);
}


#line 652 "check.cog"
         

#line 652 "check.cog"
         

#line 652 "check.cog"
                               OverloadResolveContext overloadContext;


#line 653 "check.cog"
                        DEREF(

#line 653 "check.cog"
         overloadContext).checkContext = 

#line 653 "check.cog"
                                        context;


#line 654 "check.cog"
                        DEREF(

#line 654 "check.cog"
         overloadContext).appExp = 

#line 654 "check.cog"
                                  appExp;


#line 655 "check.cog"
                        DEREF(

#line 655 "check.cog"
         overloadContext).baseExp = 

#line 655 "check.cog"
                                   nullptr;


#line 658 "check.cog"
         if(auto baseMemberRef = 

#line 658 "check.cog"
                                             

#line 658 "check.cog"
                                  

#line 658 "check.cog"
                                as<

#line 658 "check.cog"
                                   MemberExp> (

#line 658 "check.cog"
                                              base))
{


#line 660 "check.cog"
                            DEREF(

#line 660 "check.cog"
             overloadContext).baseExp = 

#line 660 "check.cog"
                                                    DEREF(

#line 660 "check.cog"
                                       baseMemberRef).base;
}


#line 663 "check.cog"
                                 

#line 663 "check.cog"
                                 

#line 663 "check.cog"
         addAppOverloadCandidates(

#line 664 "check.cog"
             

#line 664 "check.cog"
             &

#line 664 "check.cog"
              overloadContext, 

#line 665 "check.cog"
             base);


#line 667 "check.cog"
         return 

#line 667 "check.cog"
                                

#line 667 "check.cog"
                completeOverload(

#line 667 "check.cog"
                                 

#line 667 "check.cog"
                                 &

#line 667 "check.cog"
                                  overloadContext);
}
else
{


#line 669 "check.cog"
       if(auto subscriptExpr = 

#line 669 "check.cog"
                                          

#line 669 "check.cog"
                                

#line 669 "check.cog"
                              as<

#line 669 "check.cog"
                                 IndexExp> (

#line 669 "check.cog"
                                           exp))
{


#line 671 "check.cog"
           

#line 671 "check.cog"
           

#line 671 "check.cog"
   diagnose(

#line 671 "check.cog"
                   

#line 671 "check.cog"
            getSink(

#line 671 "check.cog"
                    context), 

#line 671 "check.cog"
                                 DEREF(

#line 671 "check.cog"
                              exp).loc, 

#line 671 "check.cog"
                                       kDiagnostic_unimplemented, 

#line 671 "check.cog"
                                                                                 DEREF(

#line 671 "check.cog"
                                                                     DEREF(

#line 671 "check.cog"
                                                                  exp).directClass).name);


#line 672 "check.cog"
   return 

#line 672 "check.cog"
                       

#line 672 "check.cog"
          makeErrorExpr(

#line 672 "check.cog"
                        context, 

#line 672 "check.cog"
                                 exp);
}
else
{


#line 674 "check.cog"
       if(auto genericAppExpr = 

#line 674 "check.cog"
                                                

#line 674 "check.cog"
                                 

#line 674 "check.cog"
                               as<

#line 674 "check.cog"
                                  GenericAppExp> (

#line 674 "check.cog"
                                                 exp))
{


#line 676 "check.cog"
         

#line 676 "check.cog"
         auto base = 

#line 676 "check.cog"
                             

#line 676 "check.cog"
                    checkTerm(

#line 676 "check.cog"
                              context, 

#line 676 "check.cog"
                                                     DEREF(

#line 676 "check.cog"
                                       genericAppExpr).base);


#line 677 "check.cog"
                       DEREF(

#line 677 "check.cog"
         genericAppExpr).base = 

#line 677 "check.cog"
                               base;


#line 678 "check.cog"
         for(auto arg : 

#line 678 "check.cog"
                                      DEREF(

#line 678 "check.cog"
                        genericAppExpr).args)
{
{


#line 680 "check.cog"
                DEREF(

#line 680 "check.cog"
             arg).exp = 

#line 680 "check.cog"
                                

#line 680 "check.cog"
                       checkTerm(

#line 680 "check.cog"
                                 context, 

#line 680 "check.cog"
                                             DEREF(

#line 680 "check.cog"
                                          arg).exp);
}
}


#line 685 "check.cog"
         if(

#line 685 "check.cog"
                   

#line 685 "check.cog"
            isError(

#line 685 "check.cog"
                    context, 

#line 685 "check.cog"
                             base))
{


#line 687 "check.cog"
             return 

#line 687 "check.cog"
                                  

#line 687 "check.cog"
                    createErrorExp(

#line 687 "check.cog"
                                   context, 

#line 687 "check.cog"
                                            exp);
}


#line 690 "check.cog"
         

#line 690 "check.cog"
         

#line 690 "check.cog"
                               OverloadResolveContext overloadContext;


#line 691 "check.cog"
                        DEREF(

#line 691 "check.cog"
         overloadContext).checkContext = 

#line 691 "check.cog"
                                        context;


#line 692 "check.cog"
                        DEREF(

#line 692 "check.cog"
         overloadContext).appExp = 

#line 692 "check.cog"
                                  genericAppExpr;


#line 693 "check.cog"
                        DEREF(

#line 693 "check.cog"
         overloadContext).baseExp = 

#line 693 "check.cog"
                                   nullptr;


#line 695 "check.cog"
         if(auto baseMemberRef = 

#line 695 "check.cog"
                                             

#line 695 "check.cog"
                                  

#line 695 "check.cog"
                                as<

#line 695 "check.cog"
                                   MemberExp> (

#line 695 "check.cog"
                                              base))
{


#line 697 "check.cog"
                            DEREF(

#line 697 "check.cog"
             overloadContext).baseExp = 

#line 697 "check.cog"
                                                    DEREF(

#line 697 "check.cog"
                                       baseMemberRef).base;
}


#line 700 "check.cog"
                                        

#line 700 "check.cog"
                                        

#line 700 "check.cog"
         addGenericAppOverloadCandidates(

#line 701 "check.cog"
             

#line 701 "check.cog"
             &

#line 701 "check.cog"
              overloadContext, 

#line 702 "check.cog"
             base);


#line 704 "check.cog"
         return 

#line 704 "check.cog"
                                

#line 704 "check.cog"
                completeOverload(

#line 704 "check.cog"
                                 

#line 704 "check.cog"
                                 &

#line 704 "check.cog"
                                  overloadContext);
}
else
{


#line 801 "check.cog"
       if(auto thisExpr = 

#line 801 "check.cog"
                                     

#line 801 "check.cog"
                           

#line 801 "check.cog"
                         as<

#line 801 "check.cog"
                            ThisExpr> (

#line 801 "check.cog"
                                      exp))
{


#line 803 "check.cog"
   

#line 803 "check.cog"
   auto scope = 

#line 803 "check.cog"
                       DEREF(

#line 803 "check.cog"
               thisExpr).scope;


#line 804 "check.cog"
   while(

#line 804 "check.cog"
         scope)
{
{


#line 806 "check.cog"
    

#line 806 "check.cog"
    auto containerDecl = 

#line 806 "check.cog"
                                        DEREF(

#line 806 "check.cog"
                             DEREF(

#line 806 "check.cog"
                        scope).directLink).container;


#line 807 "check.cog"
    

#line 807 "check.cog"
    auto aggTypeDecl = 

#line 807 "check.cog"
                                     

#line 807 "check.cog"
                        

#line 807 "check.cog"
                      as<

#line 807 "check.cog"
                         AggTypeDecl> (

#line 807 "check.cog"
                                      containerDecl);


#line 808 "check.cog"
    if(

#line 808 "check.cog"
       aggTypeDecl)
{


#line 810 "check.cog"
             DEREF(

#line 810 "check.cog"
     thisExpr).type = 

#line 810 "check.cog"
                                      

#line 810 "check.cog"
                     createDeclRefType(

#line 811 "check.cog"
                

#line 811 "check.cog"
      DeclRefVal(

#line 811 "check.cog"
                 aggTypeDecl));


#line 812 "check.cog"
     return 

#line 812 "check.cog"
            thisExpr;
}


#line 815 "check.cog"
    scope = 

#line 815 "check.cog"
                 DEREF(

#line 815 "check.cog"
            scope).parent;
}
}


#line 820 "check.cog"
           

#line 820 "check.cog"
           

#line 820 "check.cog"
   diagnose(

#line 820 "check.cog"
                   

#line 820 "check.cog"
            getSink(

#line 820 "check.cog"
                    context), 

#line 820 "check.cog"
                                 DEREF(

#line 820 "check.cog"
                              exp).loc, 

#line 820 "check.cog"
                                       kDiagnostic_unimplemented, 

#line 820 "check.cog"
                                                                  "this expression type");


#line 822 "check.cog"
   return 

#line 822 "check.cog"
                        

#line 822 "check.cog"
          createErrorExp(

#line 822 "check.cog"
                         context, 

#line 822 "check.cog"
                                  exp);
}
else
{


#line 824 "check.cog"
       if(auto castExpr = 

#line 824 "check.cog"
                                     

#line 824 "check.cog"
                           

#line 824 "check.cog"
                         as<

#line 824 "check.cog"
                            CastExpr> (

#line 824 "check.cog"
                                      exp))
{


#line 826 "check.cog"
               

#line 826 "check.cog"
               

#line 826 "check.cog"
   checkTypeExp(

#line 826 "check.cog"
                context, 

#line 826 "check.cog"
                         

#line 826 "check.cog"
                         &

#line 826 "check.cog"
                                  DEREF(

#line 826 "check.cog"
                          castExpr).toType);


#line 827 "check.cog"
           DEREF(

#line 827 "check.cog"
   castExpr).arg = 

#line 827 "check.cog"
                           

#line 827 "check.cog"
                  checkTerm(

#line 827 "check.cog"
                            context, 

#line 827 "check.cog"
                                             DEREF(

#line 827 "check.cog"
                                     castExpr).arg);


#line 831 "check.cog"
           DEREF(

#line 831 "check.cog"
   castExpr).type = 

#line 831 "check.cog"
                                  DEREF(

#line 831 "check.cog"
                           DEREF(

#line 831 "check.cog"
                   castExpr).toType).type;


#line 832 "check.cog"
   return 

#line 832 "check.cog"
          castExpr;
}
else
{


#line 834 "check.cog"
       if(auto parenExpr = 

#line 834 "check.cog"
                                      

#line 834 "check.cog"
                            

#line 834 "check.cog"
                          as<

#line 834 "check.cog"
                             ParenExp> (

#line 834 "check.cog"
                                       exp))
{


#line 836 "check.cog"
   

#line 836 "check.cog"
   auto base = 

#line 836 "check.cog"
                       

#line 836 "check.cog"
              checkTerm(

#line 836 "check.cog"
                        context, 

#line 836 "check.cog"
                                          DEREF(

#line 836 "check.cog"
                                 parenExpr).base);


#line 837 "check.cog"
            DEREF(

#line 837 "check.cog"
   parenExpr).base = 

#line 837 "check.cog"
                    base;


#line 838 "check.cog"
            DEREF(

#line 838 "check.cog"
   parenExpr).type = 

#line 838 "check.cog"
                        DEREF(

#line 838 "check.cog"
                    base).type;


#line 839 "check.cog"
   return 

#line 839 "check.cog"
          parenExpr;
}
else
{


#line 841 "check.cog"
       if(auto nullLitExpr = 

#line 841 "check.cog"
                                           

#line 841 "check.cog"
                              

#line 841 "check.cog"
                            as<

#line 841 "check.cog"
                               NullLitExpr> (

#line 841 "check.cog"
                                            exp))
{


#line 843 "check.cog"
              DEREF(

#line 843 "check.cog"
   nullLitExpr).type = 

#line 843 "check.cog"
                                    

#line 843 "check.cog"
                      getBuiltinType(

#line 843 "check.cog"
                                     context, 

#line 843 "check.cog"
                                                         DEREF(

#line 843 "check.cog"
                                              nullLitExpr).loc, 

#line 843 "check.cog"
                                                               "Null");


#line 844 "check.cog"
   return 

#line 844 "check.cog"
          nullLitExpr;
}
else
{


#line 848 "check.cog"
           

#line 848 "check.cog"
           

#line 848 "check.cog"
   diagnose(

#line 848 "check.cog"
                   

#line 848 "check.cog"
            getSink(

#line 848 "check.cog"
                    context), 

#line 848 "check.cog"
                                 DEREF(

#line 848 "check.cog"
                              exp).loc, 

#line 848 "check.cog"
                                       kDiagnostic_unimplemented, 

#line 848 "check.cog"
                                                                                 DEREF(

#line 848 "check.cog"
                                                                     DEREF(

#line 848 "check.cog"
                                                                  exp).directClass).name);


#line 849 "check.cog"
            

#line 849 "check.cog"
            

#line 849 "check.cog"
   cogAssert(

#line 849 "check.cog"
             

#line 849 "check.cog"
             !

#line 849 "check.cog"
              "unimplemented");


#line 850 "check.cog"
   return 

#line 850 "check.cog"
          0;
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}


#line 856 "check.cog"
 

#line 858 "check.cog"
        Val extractVal(

#line 857 "check.cog"
       Exp exp)
{


#line 860 "check.cog"
     if(auto typeType = 

#line 860 "check.cog"
                                   

#line 860 "check.cog"
                         

#line 860 "check.cog"
                       as<

#line 860 "check.cog"
                          TypeType> (

#line 860 "check.cog"
                                       DEREF(

#line 860 "check.cog"
                                    exp).type))
{


#line 862 "check.cog"
         return 

#line 862 "check.cog"
                        DEREF(

#line 862 "check.cog"
                typeType).type;
}
else
{


#line 866 "check.cog"
                  

#line 866 "check.cog"
                  

#line 866 "check.cog"
         cogAssert(

#line 866 "check.cog"
                   

#line 866 "check.cog"
                   !

#line 866 "check.cog"
                    "unimplemented");
}
}


#line 5 "string.cog"
 

#line 10 "string.cog"
  StringSpan::StringSpan()
{
}


#line 13 "string.cog"
  StringSpan::StringSpan(

#line 14 "string.cog"
             

#line 14 "string.cog"
          Ptr<

#line 14 "string.cog"
              Char>  begin, 

#line 15 "string.cog"
           

#line 15 "string.cog"
        Ptr<

#line 15 "string.cog"
            Char>  end)
{


#line 17 "string.cog"
       DEREF(

#line 17 "string.cog"
   this).begin = 

#line 17 "string.cog"
                begin;


#line 18 "string.cog"
       DEREF(

#line 18 "string.cog"
   this).end = 

#line 18 "string.cog"
              end;
}


#line 21 "string.cog"
  StringSpan::StringSpan(

#line 22 "string.cog"
                  

#line 22 "string.cog"
          ConstPtr<

#line 22 "string.cog"
                   Char>  begin, 

#line 23 "string.cog"
                

#line 23 "string.cog"
        ConstPtr<

#line 23 "string.cog"
                 Char>  end)
{


#line 25 "string.cog"
       DEREF(

#line 25 "string.cog"
   this).begin = 

#line 25 "string.cog"
                cast<

#line 25 "string.cog"
                        

#line 25 "string.cog"
                     Ptr<

#line 25 "string.cog"
                         Char> >(

#line 25 "string.cog"
                                 begin);


#line 26 "string.cog"
       DEREF(

#line 26 "string.cog"
   this).end = 

#line 26 "string.cog"
              cast<

#line 26 "string.cog"
                      

#line 26 "string.cog"
                   Ptr<

#line 26 "string.cog"
                       Char> >(

#line 26 "string.cog"
                               end);
}


#line 29 "string.cog"
  

#line 29 "string.cog"
                      UInt StringSpan::getLength()
{


#line 31 "string.cog"
   return 

#line 31 "string.cog"
              

#line 31 "string.cog"
          end 

#line 31 "string.cog"
              - 

#line 31 "string.cog"
                begin;
}


#line 34 "string.cog"
  

#line 34 "string.cog"
                                       Bool StringSpan::endsWith(

#line 34 "string.cog"
                        StringSpan suffix)
{


#line 36 "string.cog"
   

#line 36 "string.cog"
   auto len = 

#line 36 "string.cog"
                      

#line 36 "string.cog"
             getLength();


#line 37 "string.cog"
   

#line 37 "string.cog"
   auto suffixLen = 

#line 37 "string.cog"
                                   

#line 37 "string.cog"
                         DEREF(

#line 37 "string.cog"
                   suffix).getLength();


#line 39 "string.cog"
   if(

#line 39 "string.cog"
                

#line 39 "string.cog"
      suffixLen 

#line 39 "string.cog"
                > 

#line 39 "string.cog"
                  len)
{


#line 39 "string.cog"
                       return 

#line 39 "string.cog"
                              false;
}


#line 41 "string.cog"
   return 

#line 41 "string.cog"
                                           

#line 41 "string.cog"
                    

#line 41 "string.cog"
          StringSpan(

#line 41 "string.cog"
                         

#line 41 "string.cog"
                     end 

#line 41 "string.cog"
                         - 

#line 41 "string.cog"
                           suffixLen, 

#line 41 "string.cog"
                                      end) 

#line 41 "string.cog"
                                           == 

#line 41 "string.cog"
                                              suffix;
}


#line 44 "string.cog"
  

#line 44 "string.cog"
                                          Bool StringSpan::trimFromEnd(

#line 44 "string.cog"
                           StringSpan suffix)
{


#line 46 "string.cog"
   if(

#line 46 "string.cog"
      

#line 46 "string.cog"
      !

#line 46 "string.cog"
               

#line 46 "string.cog"
       endsWith(

#line 46 "string.cog"
                suffix))
{


#line 47 "string.cog"
    return 

#line 47 "string.cog"
           false;
}


#line 49 "string.cog"
   

#line 49 "string.cog"
   auto suffixLen = 

#line 49 "string.cog"
                                   

#line 49 "string.cog"
                         DEREF(

#line 49 "string.cog"
                   suffix).getLength();


#line 50 "string.cog"
       

#line 50 "string.cog"
       

#line 50 "string.cog"
   end 

#line 50 "string.cog"
       -= 

#line 50 "string.cog"
          suffixLen;


#line 51 "string.cog"
   return 

#line 51 "string.cog"
          true;
}


#line 54 "string.cog"
  

#line 54 "string.cog"
                                   StringSpan StringSpan::suffixAfterLast(

#line 54 "string.cog"
                          Char c)
{


#line 56 "string.cog"
   

#line 56 "string.cog"
   auto cursor = 

#line 56 "string.cog"
                end;


#line 57 "string.cog"
   while(

#line 57 "string.cog"
                

#line 57 "string.cog"
         cursor 

#line 57 "string.cog"
                != 

#line 57 "string.cog"
                   begin)
{
{


#line 59 "string.cog"
    

#line 59 "string.cog"
    

#line 59 "string.cog"
    --

#line 59 "string.cog"
      cursor;


#line 60 "string.cog"
    if(

#line 60 "string.cog"
               

#line 60 "string.cog"
       

#line 60 "string.cog"
       *

#line 60 "string.cog"
        cursor 

#line 60 "string.cog"
               == 

#line 60 "string.cog"
                  c)
{


#line 62 "string.cog"
     return 

#line 62 "string.cog"
                      

#line 62 "string.cog"
            StringSpan(

#line 62 "string.cog"
                             

#line 62 "string.cog"
                       cursor 

#line 62 "string.cog"
                             + 

#line 62 "string.cog"
                              1, 

#line 62 "string.cog"
                                 end);
}
}
}


#line 65 "string.cog"
   return 

#line 65 "string.cog"
          

#line 65 "string.cog"
          *

#line 65 "string.cog"
           this;
}


#line 87 "string.cog"
 

#line 92 "string.cog"
  TerminatedStringSpan::TerminatedStringSpan(

#line 92 "string.cog"
                     

#line 92 "string.cog"
             ConstPtr<

#line 92 "string.cog"
                      Char>  text)
{


#line 94 "string.cog"
       DEREF(

#line 94 "string.cog"
   this).begin = 

#line 94 "string.cog"
                cast<

#line 94 "string.cog"
                        

#line 94 "string.cog"
                     Ptr<

#line 94 "string.cog"
                         Char> >(

#line 94 "string.cog"
                                 text);


#line 95 "string.cog"
       DEREF(

#line 95 "string.cog"
   this).end = 

#line 95 "string.cog"
              cast<

#line 95 "string.cog"
                      

#line 95 "string.cog"
                   Ptr<

#line 95 "string.cog"
                       Char> >(

#line 95 "string.cog"
                                    

#line 95 "string.cog"
                               text 

#line 95 "string.cog"
                                    + 

#line 95 "string.cog"
                                            

#line 95 "string.cog"
                                      strlen(

#line 95 "string.cog"
                                             text));
}


#line 99 "string.cog"
  TerminatedStringSpan::TerminatedStringSpan()
{
}


#line 102 "string.cog"
  TerminatedStringSpan::TerminatedStringSpan(

#line 103 "string.cog"
             

#line 103 "string.cog"
          Ptr<

#line 103 "string.cog"
              Char>  begin, 

#line 104 "string.cog"
           

#line 104 "string.cog"
        Ptr<

#line 104 "string.cog"
            Char>  end)
{


#line 106 "string.cog"
       DEREF(

#line 106 "string.cog"
   this).begin = 

#line 106 "string.cog"
                begin;


#line 107 "string.cog"
       DEREF(

#line 107 "string.cog"
   this).end = 

#line 107 "string.cog"
              end;
}


#line 110 "string.cog"
  

#line 110 "string.cog"
                         StringSpan TerminatedStringSpan::asStringSpan()
{


#line 112 "string.cog"
   return 

#line 112 "string.cog"
                    

#line 112 "string.cog"
          StringSpan(

#line 112 "string.cog"
                     begin, 

#line 112 "string.cog"
                            end);
}


#line 5 "name.cog"
 

#line 872 "check.cog"
 

#line 878 "check.cog"
     Exp lookUpMemberInType(

#line 873 "check.cog"
                       

#line 873 "check.cog"
           CheckContext

#line 873 "check.cog"
                       * context, 

#line 874 "check.cog"
        MemberExp exp, 

#line 875 "check.cog"
         Exp base, 

#line 876 "check.cog"
            Type baseType, 

#line 877 "check.cog"
                  

#line 877 "check.cog"
              Name

#line 877 "check.cog"
                  * memberName)
{


#line 880 "check.cog"
     if(auto baseDeclRefType = 

#line 880 "check.cog"
                                             

#line 880 "check.cog"
                                

#line 880 "check.cog"
                              as<

#line 880 "check.cog"
                                 DeclRefType> (

#line 880 "check.cog"
                                              baseType))
{


#line 882 "check.cog"
         

#line 882 "check.cog"
         auto baseDeclRef = 

#line 882 "check.cog"
                                          DEREF(

#line 882 "check.cog"
                           baseDeclRefType).declRef;


#line 883 "check.cog"
         if(auto aggTypeDeclRef = 

#line 883 "check.cog"
                                                

#line 883 "check.cog"
                                   

#line 883 "check.cog"
                                 as<

#line 883 "check.cog"
                                    AggTypeDecl> (

#line 883 "check.cog"
                                                 baseDeclRef))
{


#line 889 "check.cog"
             

#line 889 "check.cog"
             auto lookupResult = 

#line 889 "check.cog"
                                            

#line 889 "check.cog"
                                lookupDirect(

#line 890 "check.cog"
                 aggTypeDeclRef, 

#line 891 "check.cog"
                 memberName);


#line 893 "check.cog"
             if(

#line 893 "check.cog"
                                     

#line 893 "check.cog"
                            DEREF(

#line 893 "check.cog"
                lookupResult).isUnique())
{


#line 895 "check.cog"
                 return 

#line 895 "check.cog"
                                        

#line 895 "check.cog"
                        createDeclRefExp(

#line 896 "check.cog"
                     context, 

#line 897 "check.cog"
                                   

#line 897 "check.cog"
                     CompactDeclRef(

#line 897 "check.cog"
                                                        

#line 897 "check.cog"
                                                DEREF(

#line 897 "check.cog"
                                    lookupResult).getDecl()), 

#line 898 "check.cog"
                        DEREF(

#line 898 "check.cog"
                     exp).loc, 

#line 899 "check.cog"
                     base);
}
else
{


#line 901 "check.cog"
                  if(

#line 901 "check.cog"
                                              

#line 901 "check.cog"
                                 DEREF(

#line 901 "check.cog"
                     lookupResult).isOverloaded())
{


#line 903 "check.cog"
                 

#line 903 "check.cog"
                 auto overloadedExpr = 

#line 903 "check.cog"
                                                                  

#line 903 "check.cog"
                                                  

#line 903 "check.cog"
                                      createObject<

#line 903 "check.cog"
                                                   OverloadedExpr> ();


#line 904 "check.cog"
                               DEREF(

#line 904 "check.cog"
                 overloadedExpr).loc = 

#line 904 "check.cog"
                                         DEREF(

#line 904 "check.cog"
                                      exp).loc;


#line 905 "check.cog"
                               DEREF(

#line 905 "check.cog"
                 overloadedExpr).lookupResult = 

#line 905 "check.cog"
                                               lookupResult;


#line 906 "check.cog"
                               DEREF(

#line 906 "check.cog"
                 overloadedExpr).type = 

#line 906 "check.cog"
                                                                       

#line 906 "check.cog"
                                                    

#line 906 "check.cog"
                                        createObject<

#line 906 "check.cog"
                                                     OverloadGroupType> ();


#line 907 "check.cog"
                               DEREF(

#line 907 "check.cog"
                 overloadedExpr).base = 

#line 907 "check.cog"
                                       base;


#line 908 "check.cog"
                 return 

#line 908 "check.cog"
                        overloadedExpr;
}
}
}
else
{


#line 911 "check.cog"
        if(auto genericParamDeclRef = 

#line 911 "check.cog"
                                                         

#line 911 "check.cog"
                                       

#line 911 "check.cog"
                                     as<

#line 911 "check.cog"
                                        GenericParamDecl> (

#line 911 "check.cog"
                                                          baseDeclRef))
{


#line 916 "check.cog"
    

#line 916 "check.cog"
    auto genericParamBoundType = 

#line 916 "check.cog"
                                            

#line 916 "check.cog"
                                getBoundType(

#line 916 "check.cog"
                                             genericParamDeclRef);


#line 917 "check.cog"
    return 

#line 917 "check.cog"
                             

#line 917 "check.cog"
           lookUpMemberInType(

#line 918 "check.cog"
     context, 

#line 919 "check.cog"
     exp, 

#line 920 "check.cog"
     base, 

#line 921 "check.cog"
     genericParamBoundType, 

#line 922 "check.cog"
     memberName);
}
}
}


#line 926 "check.cog"
  return 

#line 926 "check.cog"
         nullptr;
}


#line 929 "check.cog"
 

#line 932 "check.cog"
        Exp checkMemberExp(

#line 930 "check.cog"
                       

#line 930 "check.cog"
           CheckContext

#line 930 "check.cog"
                       * context, 

#line 931 "check.cog"
       MemberExp exp)
{


#line 934 "check.cog"
     

#line 934 "check.cog"
     auto base = 

#line 934 "check.cog"
                   DEREF(

#line 934 "check.cog"
                exp).base;


#line 935 "check.cog"
     base = 

#line 935 "check.cog"
                     

#line 935 "check.cog"
            checkTerm(

#line 935 "check.cog"
                      context, 

#line 935 "check.cog"
                               base);


#line 937 "check.cog"
     

#line 937 "check.cog"
     auto memberName = 

#line 937 "check.cog"
                         DEREF(

#line 937 "check.cog"
                      exp).memberName;


#line 941 "check.cog"
     if(

#line 941 "check.cog"
               

#line 941 "check.cog"
        isError(

#line 941 "check.cog"
                context, 

#line 941 "check.cog"
                         base))
{


#line 943 "check.cog"
         return 

#line 943 "check.cog"
                              

#line 943 "check.cog"
                createErrorExp(

#line 943 "check.cog"
                               context, 

#line 943 "check.cog"
                                        exp);
}


#line 946 "check.cog"
     

#line 946 "check.cog"
     auto baseType = 

#line 946 "check.cog"
                        DEREF(

#line 946 "check.cog"
                    base).type;


#line 948 "check.cog"
  if(auto result = 

#line 948 "check.cog"
                                    

#line 948 "check.cog"
                  lookUpMemberInType(

#line 948 "check.cog"
                                     context, 

#line 948 "check.cog"
                                              exp, 

#line 948 "check.cog"
                                                   base, 

#line 948 "check.cog"
                                                         baseType, 

#line 948 "check.cog"
                                                                   memberName))
{


#line 950 "check.cog"
   return 

#line 950 "check.cog"
          result;
}


#line 953 "check.cog"
             

#line 953 "check.cog"
             

#line 953 "check.cog"
     diagnose(

#line 953 "check.cog"
                     

#line 953 "check.cog"
              getSink(

#line 953 "check.cog"
                      context), 

#line 953 "check.cog"
                                   DEREF(

#line 953 "check.cog"
                                exp).loc, 

#line 953 "check.cog"
                                         kDiagnostic_noMemberOfNameInType, 

#line 953 "check.cog"
                                                                           memberName, 

#line 953 "check.cog"
                                                                                       baseType);


#line 954 "check.cog"
     return 

#line 954 "check.cog"
                          

#line 954 "check.cog"
            createErrorExp(

#line 954 "check.cog"
                           context, 

#line 954 "check.cog"
                                    exp);
}


#line 1518 "check.cog"
 

#line 1501 "check.cog"
 

#line 1511 "check.cog"
 

#line 1524 "check.cog"
 

#line 959 "check.cog"
 void addAppOverloadCandidates(

#line 960 "check.cog"
                                 

#line 960 "check.cog"
           OverloadResolveContext

#line 960 "check.cog"
                                 * context, 

#line 961 "check.cog"
           Exp baseExp)
{


#line 964 "check.cog"
     if(auto typeType = 

#line 964 "check.cog"
                                   

#line 964 "check.cog"
                         

#line 964 "check.cog"
                       as<

#line 964 "check.cog"
                          TypeType> (

#line 964 "check.cog"
                                           DEREF(

#line 964 "check.cog"
                                    baseExp).type))
{


#line 968 "check.cog"
                                  

#line 968 "check.cog"
                                  

#line 968 "check.cog"
         addTypeOverloadCandidates(

#line 968 "check.cog"
                                   context, 

#line 968 "check.cog"
                                            baseExp, 

#line 968 "check.cog"
                                                             DEREF(

#line 968 "check.cog"
                                                     typeType).type);
}
else
{


#line 970 "check.cog"
          if(auto declRefExp = 

#line 970 "check.cog"
                                            

#line 970 "check.cog"
                                

#line 970 "check.cog"
                              as<

#line 970 "check.cog"
                                 DeclRefExp> (

#line 970 "check.cog"
                                             baseExp))
{


#line 974 "check.cog"
                                     

#line 974 "check.cog"
                                     

#line 974 "check.cog"
         addDeclRefOverloadCandidates(

#line 974 "check.cog"
                                      context, 

#line 974 "check.cog"
                                                         DEREF(

#line 974 "check.cog"
                                               declRefExp).declRef);
}
else
{


#line 976 "check.cog"
          if(auto overloadedExpr = 

#line 976 "check.cog"
                                                    

#line 976 "check.cog"
                                    

#line 976 "check.cog"
                                  as<

#line 976 "check.cog"
                                     OverloadedExpr> (

#line 976 "check.cog"
                                                     baseExp))
{


#line 978 "check.cog"
                  

#line 978 "check.cog"
                  

#line 978 "check.cog"
         cogAssert(

#line 978 "check.cog"
                   

#line 978 "check.cog"
                   !

#line 978 "check.cog"
                           DEREF(

#line 978 "check.cog"
                    context).baseExp);


#line 979 "check.cog"
                DEREF(

#line 979 "check.cog"
         context).baseExp = 

#line 979 "check.cog"
                                         DEREF(

#line 979 "check.cog"
                           overloadedExpr).base;


#line 982 "check.cog"
                  

#line 982 "check.cog"
                  

#line 982 "check.cog"
         cogAssert(

#line 982 "check.cog"
                                                                

#line 982 "check.cog"
                                                             

#line 982 "check.cog"
                                                    DEREF(

#line 982 "check.cog"
                                              DEREF(

#line 982 "check.cog"
                                 DEREF(

#line 982 "check.cog"
                   overloadedExpr).lookupResult).items).getCount() 

#line 982 "check.cog"
                                                                != 

#line 982 "check.cog"
                                                                   0);


#line 983 "check.cog"
         for(auto item : 

#line 983 "check.cog"
                                       DEREF(

#line 983 "check.cog"
                         overloadedExpr).lookupResult)
{
{


#line 986 "check.cog"
                                         

#line 986 "check.cog"
                                         

#line 986 "check.cog"
             addDeclRefOverloadCandidates(

#line 987 "check.cog"
                 context, 

#line 988 "check.cog"
                           

#line 988 "check.cog"
                 DeclRefVal(

#line 988 "check.cog"
                                DEREF(

#line 988 "check.cog"
                            item).decl));
}
}
}
else
{
}
}
}
}


#line 1000 "check.cog"
 void addGenericGenericOverloadCandidate(

#line 1001 "check.cog"
                                    

#line 1001 "check.cog"
              OverloadResolveContext

#line 1001 "check.cog"
                                    * context, 

#line 1002 "check.cog"
                                

#line 1002 "check.cog"
                  DeclRefValImpl<

#line 1002 "check.cog"
                                 GenericDecl>  genericDeclRef)
{


#line 1004 "check.cog"
            

#line 1004 "check.cog"
            

#line 1004 "check.cog"
  ensureDecl(

#line 1004 "check.cog"
                    DEREF(

#line 1004 "check.cog"
             context).checkContext, 

#line 1004 "check.cog"
                                                         

#line 1004 "check.cog"
                                                 DEREF(

#line 1004 "check.cog"
                                   genericDeclRef).getDecl());


#line 1006 "check.cog"
     

#line 1006 "check.cog"
     

#line 1006 "check.cog"
                    OverloadCandidate candidate;


#line 1007 "check.cog"
              DEREF(

#line 1007 "check.cog"
     candidate).declRef = 

#line 1007 "check.cog"
                         genericDeclRef;


#line 1008 "check.cog"
              DEREF(

#line 1008 "check.cog"
     candidate).resultType = 

#line 1008 "check.cog"
                            nullptr;


#line 1010 "check.cog"
                         

#line 1010 "check.cog"
                         

#line 1010 "check.cog"
     addOverloadCandidate(

#line 1010 "check.cog"
                          context, 

#line 1010 "check.cog"
                                   candidate);
}


#line 1013 "check.cog"
 void addDeclRefGenericOverloadCandidates(

#line 1014 "check.cog"
                                    

#line 1014 "check.cog"
              OverloadResolveContext

#line 1014 "check.cog"
                                    * context, 

#line 1015 "check.cog"
          DeclRefVal val)
{


#line 1017 "check.cog"
     if(auto genericDeclRef = 

#line 1017 "check.cog"
                                            

#line 1017 "check.cog"
                               

#line 1017 "check.cog"
                             as<

#line 1017 "check.cog"
                                GenericDecl> (

#line 1017 "check.cog"
                                             val))
{


#line 1019 "check.cog"
                                           

#line 1019 "check.cog"
                                           

#line 1019 "check.cog"
         addGenericGenericOverloadCandidate(

#line 1019 "check.cog"
                                            context, 

#line 1019 "check.cog"
                                                     genericDeclRef);
}
else
{
}
}


#line 1028 "check.cog"
 void addGenericAppOverloadCandidates(

#line 1029 "check.cog"
                                 

#line 1029 "check.cog"
           OverloadResolveContext

#line 1029 "check.cog"
                                 * context, 

#line 1030 "check.cog"
           Exp baseExp)
{


#line 1032 "check.cog"
  if(auto declRefExp = 

#line 1032 "check.cog"
                                    

#line 1032 "check.cog"
                        

#line 1032 "check.cog"
                      as<

#line 1032 "check.cog"
                         DeclRefExp> (

#line 1032 "check.cog"
                                     baseExp))
{


#line 1034 "check.cog"
                                            

#line 1034 "check.cog"
                                            

#line 1034 "check.cog"
         addDeclRefGenericOverloadCandidates(

#line 1034 "check.cog"
                                             context, 

#line 1034 "check.cog"
                                                                DEREF(

#line 1034 "check.cog"
                                                      declRefExp).declRef);
}
else
{


#line 1036 "check.cog"
          if(auto overloadedExpr = 

#line 1036 "check.cog"
                                                    

#line 1036 "check.cog"
                                    

#line 1036 "check.cog"
                                  as<

#line 1036 "check.cog"
                                     OverloadedExpr> (

#line 1036 "check.cog"
                                                     baseExp))
{


#line 1038 "check.cog"
                  

#line 1038 "check.cog"
                  

#line 1038 "check.cog"
         cogAssert(

#line 1038 "check.cog"
                   

#line 1038 "check.cog"
                   !

#line 1038 "check.cog"
                           DEREF(

#line 1038 "check.cog"
                    context).baseExp);


#line 1039 "check.cog"
                DEREF(

#line 1039 "check.cog"
         context).baseExp = 

#line 1039 "check.cog"
                                         DEREF(

#line 1039 "check.cog"
                           overloadedExpr).base;


#line 1041 "check.cog"
                  

#line 1041 "check.cog"
                  

#line 1041 "check.cog"
         cogAssert(

#line 1041 "check.cog"
                                                                

#line 1041 "check.cog"
                                                             

#line 1041 "check.cog"
                                                    DEREF(

#line 1041 "check.cog"
                                              DEREF(

#line 1041 "check.cog"
                                 DEREF(

#line 1041 "check.cog"
                   overloadedExpr).lookupResult).items).getCount() 

#line 1041 "check.cog"
                                                                != 

#line 1041 "check.cog"
                                                                   0);


#line 1042 "check.cog"
         for(auto item : 

#line 1042 "check.cog"
                                       DEREF(

#line 1042 "check.cog"
                         overloadedExpr).lookupResult)
{
{


#line 1044 "check.cog"
                                                

#line 1044 "check.cog"
                                                

#line 1044 "check.cog"
             addDeclRefGenericOverloadCandidates(

#line 1045 "check.cog"
                 context, 

#line 1046 "check.cog"
                           

#line 1046 "check.cog"
                 DeclRefVal(

#line 1046 "check.cog"
                                DEREF(

#line 1046 "check.cog"
                            item).decl));
}
}
}
else
{
}
}
}


#line 1057 "check.cog"
 

#line 1060 "check.cog"
        Type createFuncType(

#line 1058 "check.cog"
                       

#line 1058 "check.cog"
           CheckContext

#line 1058 "check.cog"
                       * context, 

#line 1059 "check.cog"
                             

#line 1059 "check.cog"
               DeclRefValImpl<

#line 1059 "check.cog"
                              FuncDeclBase>  funcDeclRef)
{


#line 1062 "check.cog"
     

#line 1062 "check.cog"
     auto funcType = 

#line 1062 "check.cog"
                                          

#line 1062 "check.cog"
                                

#line 1062 "check.cog"
                    createObject<

#line 1062 "check.cog"
                                 FuncType> ();


#line 1063 "check.cog"
     return 

#line 1063 "check.cog"
            funcType;
}


#line 1068 "check.cog"
 

#line 1070 "check.cog"
          

#line 1070 "check.cog"
     Class

#line 1070 "check.cog"
          * getSyntaxClassForDeclRef(

#line 1069 "check.cog"
           DeclRefVal declRef)
{


#line 1072 "check.cog"
  

#line 1072 "check.cog"
  auto decl = 

#line 1072 "check.cog"
                            

#line 1072 "check.cog"
                    DEREF(

#line 1072 "check.cog"
             declRef).getDecl();


#line 1074 "check.cog"
  if(auto declRefClassAttr = 

#line 1074 "check.cog"
                                                           

#line 1074 "check.cog"
                                         

#line 1074 "check.cog"
                                DEREF(

#line 1074 "check.cog"
                            decl).findAttr<

#line 1074 "check.cog"
                                          DeclRefClassAttr> ())
{


#line 1076 "check.cog"
   if(auto declRefSyntaxClass = 

#line 1076 "check.cog"
                                               DEREF(

#line 1076 "check.cog"
                               declRefClassAttr).syntaxClass)
{


#line 1078 "check.cog"
    return 

#line 1078 "check.cog"
           declRefSyntaxClass;
}
}


#line 1082 "check.cog"
  if(auto classDecl = 

#line 1082 "check.cog"
                                  

#line 1082 "check.cog"
                       

#line 1082 "check.cog"
                     as<

#line 1082 "check.cog"
                        ClassDecl> (

#line 1082 "check.cog"
                                   decl))
{


#line 1084 "check.cog"
   return 

#line 1084 "check.cog"
                             

#line 1084 "check.cog"
                  

#line 1084 "check.cog"
          getClass<

#line 1084 "check.cog"
                   ClassType> ();
}


#line 1087 "check.cog"
  return 

#line 1087 "check.cog"
                              

#line 1087 "check.cog"
                 

#line 1087 "check.cog"
         getClass<

#line 1087 "check.cog"
                  DeclRefType> ();
}


#line 1090 "check.cog"
 

#line 1092 "check.cog"
     Type createDeclRefType(

#line 1091 "check.cog"
           DeclRefVal declRef)
{


#line 1094 "check.cog"
  

#line 1094 "check.cog"
  auto syntaxClass = 

#line 1094 "check.cog"
                                            

#line 1094 "check.cog"
                    getSyntaxClassForDeclRef(

#line 1094 "check.cog"
                                             declRef);


#line 1095 "check.cog"
  

#line 1095 "check.cog"
  auto type = 

#line 1095 "check.cog"
             cast<

#line 1095 "check.cog"
                  DeclRefType>(

#line 1095 "check.cog"
                                           

#line 1095 "check.cog"
                               createObject(

#line 1095 "check.cog"
                                            syntaxClass));


#line 1096 "check.cog"
      DEREF(

#line 1096 "check.cog"
  type).declRef = 

#line 1096 "check.cog"
                               

#line 1096 "check.cog"
                 CompactDeclRef(

#line 1096 "check.cog"
                                declRef);


#line 1097 "check.cog"
  return 

#line 1097 "check.cog"
         type;
}


#line 1100 "check.cog"
 

#line 1103 "check.cog"
     Type createDeclRefTypeType(

#line 1101 "check.cog"
                       

#line 1101 "check.cog"
           CheckContext

#line 1101 "check.cog"
                       * context, 

#line 1102 "check.cog"
           DeclRefVal declRef)
{


#line 1105 "check.cog"
  

#line 1105 "check.cog"
  auto type = 

#line 1105 "check.cog"
                              

#line 1105 "check.cog"
             createDeclRefType(

#line 1105 "check.cog"
                               declRef);


#line 1106 "check.cog"
  

#line 1106 "check.cog"
  auto typeType = 

#line 1106 "check.cog"
                               

#line 1106 "check.cog"
                 createTypeType(

#line 1106 "check.cog"
                                context, 

#line 1106 "check.cog"
                                         type);


#line 1107 "check.cog"
  return 

#line 1107 "check.cog"
         typeType;
}


#line 1110 "check.cog"
 

#line 1113 "check.cog"
     TypeType createTypeType(

#line 1111 "check.cog"
                       

#line 1111 "check.cog"
           CheckContext

#line 1111 "check.cog"
                       * context, 

#line 1112 "check.cog"
        Type type)
{


#line 1115 "check.cog"
  

#line 1115 "check.cog"
  auto typeType = 

#line 1115 "check.cog"
                                       

#line 1115 "check.cog"
                             

#line 1115 "check.cog"
                 createObject<

#line 1115 "check.cog"
                              TypeType> ();


#line 1116 "check.cog"
          DEREF(

#line 1116 "check.cog"
  typeType).type = 

#line 1116 "check.cog"
                  type;


#line 1117 "check.cog"
  return 

#line 1117 "check.cog"
         typeType;
}


#line 1120 "check.cog"
 

#line 1124 "check.cog"
     Type specializeTypeForDeclRef(

#line 1121 "check.cog"
                        

#line 1121 "check.cog"
            CheckContext

#line 1121 "check.cog"
                        * context, 

#line 1122 "check.cog"
         Type type, 

#line 1123 "check.cog"
           DeclRefVal declRef)
{


#line 1126 "check.cog"
  return 

#line 1126 "check.cog"
                       

#line 1126 "check.cog"
         specializeType(

#line 1127 "check.cog"
   type, 

#line 1128 "check.cog"
          DEREF(

#line 1128 "check.cog"
   declRef).specializations);
}


#line 1133 "check.cog"
 

#line 1136 "check.cog"
     Type getTypeForDeclRefImpl(

#line 1134 "check.cog"
                       

#line 1134 "check.cog"
           CheckContext

#line 1134 "check.cog"
                       * context, 

#line 1135 "check.cog"
           DeclRefVal declRef)
{


#line 1138 "check.cog"
     

#line 1138 "check.cog"
     auto decl = 

#line 1138 "check.cog"
                               

#line 1138 "check.cog"
                       DEREF(

#line 1138 "check.cog"
                declRef).getDecl();


#line 1140 "check.cog"
               

#line 1140 "check.cog"
               

#line 1140 "check.cog"
     ensureDecl(

#line 1140 "check.cog"
                context, 

#line 1140 "check.cog"
                         decl);


#line 1142 "check.cog"
     if(auto varDecl = 

#line 1142 "check.cog"
                                     

#line 1142 "check.cog"
                        

#line 1142 "check.cog"
                      as<

#line 1142 "check.cog"
                         VarDeclBase> (

#line 1142 "check.cog"
                                      decl))
{


#line 1145 "check.cog"
   return 

#line 1145 "check.cog"
                                  

#line 1145 "check.cog"
          specializeTypeForDeclRef(

#line 1145 "check.cog"
                                   context, 

#line 1145 "check.cog"
                                                        DEREF(

#line 1145 "check.cog"
                                                   DEREF(

#line 1145 "check.cog"
                                            varDecl).type).type, 

#line 1145 "check.cog"
                                                               declRef);
}
else
{


#line 1147 "check.cog"
       if(auto aggTypeDecl = 

#line 1147 "check.cog"
                                           

#line 1147 "check.cog"
                              

#line 1147 "check.cog"
                            as<

#line 1147 "check.cog"
                               AggTypeDecl> (

#line 1147 "check.cog"
                                            decl))
{


#line 1149 "check.cog"
         return 

#line 1149 "check.cog"
                                     

#line 1149 "check.cog"
                createDeclRefTypeType(

#line 1149 "check.cog"
                                      context, 

#line 1149 "check.cog"
                                               declRef);
}
else
{


#line 1151 "check.cog"
          if(auto typeVarDecl = 

#line 1151 "check.cog"
                                              

#line 1151 "check.cog"
                                 

#line 1151 "check.cog"
                               as<

#line 1151 "check.cog"
                                  TypeVarDecl> (

#line 1151 "check.cog"
                                               decl))
{


#line 1153 "check.cog"
         return 

#line 1153 "check.cog"
                                     

#line 1153 "check.cog"
                createDeclRefTypeType(

#line 1153 "check.cog"
                                      context, 

#line 1153 "check.cog"
                                               declRef);
}
else
{


#line 1155 "check.cog"
          if(auto genericDecl = 

#line 1155 "check.cog"
                                              

#line 1155 "check.cog"
                                 

#line 1155 "check.cog"
                               as<

#line 1155 "check.cog"
                                  GenericDecl> (

#line 1155 "check.cog"
                                               decl))
{


#line 1157 "check.cog"
         return 

#line 1157 "check.cog"
                                     

#line 1157 "check.cog"
                createDeclRefTypeType(

#line 1157 "check.cog"
                                      context, 

#line 1157 "check.cog"
                                               declRef);
}
else
{


#line 1159 "check.cog"
          if(auto funcDeclRef = 

#line 1159 "check.cog"
                                               

#line 1159 "check.cog"
                                 

#line 1159 "check.cog"
                               as<

#line 1159 "check.cog"
                                  FuncDeclBase> (

#line 1159 "check.cog"
                                                declRef))
{


#line 1161 "check.cog"
         return 

#line 1161 "check.cog"
                              

#line 1161 "check.cog"
                createFuncType(

#line 1161 "check.cog"
                               context, 

#line 1161 "check.cog"
                                        funcDeclRef);
}
else
{


#line 1165 "check.cog"
            

#line 1165 "check.cog"
            

#line 1165 "check.cog"
   cogAssert(

#line 1165 "check.cog"
             

#line 1165 "check.cog"
             !

#line 1165 "check.cog"
              "unimplemented");


#line 1166 "check.cog"
         return 

#line 1166 "check.cog"
                0;
}
}
}
}
}
}


#line 1170 "check.cog"
 

#line 1173 "check.cog"
     Type getTypeForDeclRef(

#line 1171 "check.cog"
                       

#line 1171 "check.cog"
           CheckContext

#line 1171 "check.cog"
                       * context, 

#line 1172 "check.cog"
           DeclRefVal declRef)
{


#line 1175 "check.cog"
     

#line 1175 "check.cog"
     auto result = 

#line 1175 "check.cog"
                                       

#line 1175 "check.cog"
                  getTypeForDeclRefImpl(

#line 1175 "check.cog"
                                        context, 

#line 1175 "check.cog"
                                                 declRef);


#line 1180 "check.cog"
     return 

#line 1180 "check.cog"
            result;
}


#line 1183 "check.cog"
 

#line 1186 "check.cog"
     Type getTypeForDeclRef(

#line 1184 "check.cog"
                       

#line 1184 "check.cog"
           CheckContext

#line 1184 "check.cog"
                       * context, 

#line 1185 "check.cog"
           CompactDeclRef declRef)
{


#line 1188 "check.cog"
  return 

#line 1188 "check.cog"
                          

#line 1188 "check.cog"
         getTypeForDeclRef(

#line 1189 "check.cog"
   context, 

#line 1190 "check.cog"
             

#line 1190 "check.cog"
   DeclRefVal(

#line 1190 "check.cog"
              declRef));
}


#line 1193 "check.cog"
 

#line 1195 "check.cog"
     Type createErrorType(

#line 1194 "check.cog"
                       

#line 1194 "check.cog"
           CheckContext

#line 1194 "check.cog"
                       * context)
{


#line 1197 "check.cog"
     return 

#line 1197 "check.cog"
                                   

#line 1197 "check.cog"
                        

#line 1197 "check.cog"
            createObject<

#line 1197 "check.cog"
                         ErrorType> ();
}


#line 5 "source.cog"
 

#line 9 "source.cog"
  SourceLoc::SourceLoc()
{


#line 9 "source.cog"
               DEREF(

#line 9 "source.cog"
           this).raw = 

#line 9 "source.cog"
                          

#line 9 "source.cog"
                      UInt(

#line 9 "source.cog"
                           0);
}


#line 11 "source.cog"
  SourceLoc::SourceLoc(

#line 11 "source.cog"
            UInt raw)
{


#line 13 "source.cog"
       DEREF(

#line 13 "source.cog"
   this).raw = 

#line 13 "source.cog"
              raw;
}


#line 1200 "check.cog"
 

#line 1204 "check.cog"
        Type getBuiltinType(

#line 1201 "check.cog"
                       

#line 1201 "check.cog"
           CheckContext

#line 1201 "check.cog"
                       * context, 

#line 1202 "check.cog"
       SourceLoc loc, 

#line 1203 "check.cog"
                

#line 1203 "check.cog"
        ConstPtr<

#line 1203 "check.cog"
                 Char>  name)
{


#line 1206 "check.cog"
     

#line 1206 "check.cog"
     auto cogModuleName = 

#line 1206 "check.cog"
                                

#line 1206 "check.cog"
                         getName(

#line 1206 "check.cog"
                                               DEREF(

#line 1206 "check.cog"
                                        DEREF(

#line 1206 "check.cog"
                                 context).shared).session, 

#line 1206 "check.cog"
                                                         "cog");


#line 1207 "check.cog"
     

#line 1207 "check.cog"
     

#line 1207 "check.cog"
                     ModuleDecl cogModule = 

#line 1207 "check.cog"
                                  nullptr;


#line 1208 "check.cog"
     if(

#line 1208 "check.cog"
                                               

#line 1208 "check.cog"
                                         DEREF(

#line 1208 "check.cog"
                              DEREF(

#line 1208 "check.cog"
                      DEREF(

#line 1208 "check.cog"
               DEREF(

#line 1208 "check.cog"
        context).shared).session).moduleDecl).name 

#line 1208 "check.cog"
                                               == 

#line 1208 "check.cog"
                                                  cogModuleName)
{


#line 1210 "check.cog"
         cogModule = 

#line 1210 "check.cog"
                                           DEREF(

#line 1210 "check.cog"
                                   DEREF(

#line 1210 "check.cog"
                            DEREF(

#line 1210 "check.cog"
                     context).shared).session).moduleDecl;
}
else
{


#line 1214 "check.cog"
         cogModule = 

#line 1214 "check.cog"
                                       

#line 1214 "check.cog"
                     findOrImportModule(

#line 1214 "check.cog"
                                                      DEREF(

#line 1214 "check.cog"
                                               DEREF(

#line 1214 "check.cog"
                                        context).shared).session, 

#line 1214 "check.cog"
                                                                loc, 

#line 1214 "check.cog"
                                                                     cogModuleName);
}


#line 1217 "check.cog"
     

#line 1217 "check.cog"
     auto nameSpan = 

#line 1217 "check.cog"
                                        

#line 1217 "check.cog"
                    TerminatedStringSpan(

#line 1217 "check.cog"
                                         name);


#line 1218 "check.cog"
     for(auto decl : 

#line 1218 "check.cog"
                                       

#line 1218 "check.cog"
                              DEREF(

#line 1218 "check.cog"
                     cogModule).getDecls())
{
{


#line 1220 "check.cog"
         if(

#line 1220 "check.cog"
                      

#line 1220 "check.cog"
                DEREF(

#line 1220 "check.cog"
            decl).name 

#line 1220 "check.cog"
                      && 

#line 1220 "check.cog"
                                            

#line 1220 "check.cog"
                                

#line 1220 "check.cog"
                         getText(

#line 1220 "check.cog"
                                     DEREF(

#line 1220 "check.cog"
                                 decl).name) 

#line 1220 "check.cog"
                                            == 

#line 1220 "check.cog"
                                               nameSpan)
{


#line 1222 "check.cog"
    return 

#line 1222 "check.cog"
                            

#line 1222 "check.cog"
           createDeclRefType(

#line 1222 "check.cog"
                                       

#line 1222 "check.cog"
                             DeclRefVal(

#line 1222 "check.cog"
                                        decl));
}
}
}


#line 1226 "check.cog"
             

#line 1226 "check.cog"
             

#line 1226 "check.cog"
     diagnose(

#line 1226 "check.cog"
                     

#line 1226 "check.cog"
              getSink(

#line 1226 "check.cog"
                      context), 

#line 1226 "check.cog"
                                loc, 

#line 1226 "check.cog"
                                     kDiagnostic_failedToFindBuiltinType, 

#line 1226 "check.cog"
                                                                          name);


#line 1227 "check.cog"
     return 

#line 1227 "check.cog"
                           

#line 1227 "check.cog"
            createErrorType(

#line 1227 "check.cog"
                            context);
}


#line 1230 "check.cog"
 

#line 1233 "check.cog"
     Type getResultType(

#line 1231 "check.cog"
                       

#line 1231 "check.cog"
           CheckContext

#line 1231 "check.cog"
                       * context, 

#line 1232 "check.cog"
                      

#line 1232 "check.cog"
        DeclRefValImpl<

#line 1232 "check.cog"
                       PatternDecl>  decl)
{


#line 1237 "check.cog"
  if(auto funcDeclRef = 

#line 1237 "check.cog"
                                   

#line 1237 "check.cog"
                         

#line 1237 "check.cog"
                       as<

#line 1237 "check.cog"
                          FuncDecl> (

#line 1237 "check.cog"
                                    decl))
{


#line 1239 "check.cog"
   return 

#line 1239 "check.cog"
                       

#line 1239 "check.cog"
          getResultType(

#line 1239 "check.cog"
                        funcDeclRef);
}
else
{


#line 1241 "check.cog"
          if(auto subscriptDeclRef = 

#line 1241 "check.cog"
                                                     

#line 1241 "check.cog"
                                      

#line 1241 "check.cog"
                                    as<

#line 1241 "check.cog"
                                       SubscriptDecl> (

#line 1241 "check.cog"
                                                      decl))
{


#line 1243 "check.cog"
         return 

#line 1243 "check.cog"
                             

#line 1243 "check.cog"
                getResultType(

#line 1243 "check.cog"
                              subscriptDeclRef);
}
else
{


#line 1245 "check.cog"
          if(auto typeDeclRef = 

#line 1245 "check.cog"
                                              

#line 1245 "check.cog"
                                 

#line 1245 "check.cog"
                               as<

#line 1245 "check.cog"
                                  AggTypeDecl> (

#line 1245 "check.cog"
                                               decl))
{


#line 1247 "check.cog"
         return 

#line 1247 "check.cog"
                                 

#line 1247 "check.cog"
                createDeclRefType(

#line 1248 "check.cog"
                           

#line 1248 "check.cog"
             CompactDeclRef(

#line 1248 "check.cog"
                            typeDeclRef));
}
else
{


#line 1253 "check.cog"
                 

#line 1253 "check.cog"
                 

#line 1253 "check.cog"
         diagnose(

#line 1253 "check.cog"
                         

#line 1253 "check.cog"
                  getSink(

#line 1253 "check.cog"
                          context), 

#line 1253 "check.cog"
                                             DEREF(

#line 1253 "check.cog"
                                        DEREF(

#line 1253 "check.cog"
                                    decl).decl).loc, 

#line 1253 "check.cog"
                                                   kDiagnostic_unimplemented, 

#line 1253 "check.cog"
                                                                              "result type");


#line 1254 "check.cog"
   return 

#line 1254 "check.cog"
          0;
}
}
}
}


#line 1258 "check.cog"
 

#line 1261 "check.cog"
        Exp createErrorExp(

#line 1259 "check.cog"
                       

#line 1259 "check.cog"
           CheckContext

#line 1259 "check.cog"
                       * context, 

#line 1260 "check.cog"
       Exp exp)
{


#line 1263 "check.cog"
        DEREF(

#line 1263 "check.cog"
     exp).type = 

#line 1263 "check.cog"
                               

#line 1263 "check.cog"
                createErrorType(

#line 1263 "check.cog"
                                context);


#line 1264 "check.cog"
     return 

#line 1264 "check.cog"
            exp;
}


#line 1267 "check.cog"
 

#line 1270 "check.cog"
        Exp createErrorExp(

#line 1268 "check.cog"
                       

#line 1268 "check.cog"
           CheckContext

#line 1268 "check.cog"
                       * context, 

#line 1269 "check.cog"
       SourceLoc loc)
{


#line 1272 "check.cog"
     

#line 1272 "check.cog"
     auto exp = 

#line 1272 "check.cog"
                                     

#line 1272 "check.cog"
                           

#line 1272 "check.cog"
               createObject<

#line 1272 "check.cog"
                            ErrorExp> ();


#line 1273 "check.cog"
        DEREF(

#line 1273 "check.cog"
     exp).loc = 

#line 1273 "check.cog"
               loc;


#line 1274 "check.cog"
     return 

#line 1274 "check.cog"
                          

#line 1274 "check.cog"
            createErrorExp(

#line 1274 "check.cog"
                           context, 

#line 1274 "check.cog"
                                    exp);
}


#line 1277 "check.cog"
 

#line 1280 "check.cog"
        Bool isSameVal(

#line 1278 "check.cog"
        Val left, 

#line 1279 "check.cog"
         Val right)
{


#line 1282 "check.cog"
     if(auto leftType = 

#line 1282 "check.cog"
                               

#line 1282 "check.cog"
                         

#line 1282 "check.cog"
                       as<

#line 1282 "check.cog"
                          Type> (

#line 1282 "check.cog"
                                left))
{


#line 1284 "check.cog"
         if(auto rightType = 

#line 1284 "check.cog"
                                    

#line 1284 "check.cog"
                              

#line 1284 "check.cog"
                            as<

#line 1284 "check.cog"
                               Type> (

#line 1284 "check.cog"
                                     right))
{


#line 1286 "check.cog"
             return 

#line 1286 "check.cog"
                              

#line 1286 "check.cog"
                    isSameType(

#line 1286 "check.cog"
                               leftType, 

#line 1286 "check.cog"
                                         rightType);
}
}


#line 1293 "check.cog"
              

#line 1293 "check.cog"
              

#line 1293 "check.cog"
     cogAssert(

#line 1293 "check.cog"
               

#line 1293 "check.cog"
               !

#line 1293 "check.cog"
                "unimplemented");


#line 1294 "check.cog"
     return 

#line 1294 "check.cog"
            false;
}


#line 1297 "check.cog"
 

#line 1300 "check.cog"
        Bool isSameSpecializations(

#line 1298 "check.cog"
        Specializations left, 

#line 1299 "check.cog"
            Specializations right)
{


#line 1303 "check.cog"
     if(

#line 1303 "check.cog"
              

#line 1303 "check.cog"
        

#line 1303 "check.cog"
        !

#line 1303 "check.cog"
         left 

#line 1303 "check.cog"
              || 

#line 1303 "check.cog"
                 

#line 1303 "check.cog"
                 !

#line 1303 "check.cog"
                  right)
{


#line 1304 "check.cog"
         return 

#line 1304 "check.cog"
                     

#line 1304 "check.cog"
                left 

#line 1304 "check.cog"
                     == 

#line 1304 "check.cog"
                        right;
}


#line 1306 "check.cog"
     if(

#line 1306 "check.cog"
        

#line 1306 "check.cog"
        !

#line 1306 "check.cog"
                      

#line 1306 "check.cog"
         isSameDeclRef(

#line 1307 "check.cog"
             DEREF(

#line 1307 "check.cog"
         left).genericDeclRef, 

#line 1308 "check.cog"
              DEREF(

#line 1308 "check.cog"
         right).genericDeclRef))
{


#line 1310 "check.cog"
         return 

#line 1310 "check.cog"
                false;
}


#line 1313 "check.cog"
     

#line 1313 "check.cog"
     auto leftCursor = 

#line 1313 "check.cog"
                                     

#line 1313 "check.cog"
                               DEREF(

#line 1313 "check.cog"
                          DEREF(

#line 1313 "check.cog"
                      left).args).begin();


#line 1314 "check.cog"
     

#line 1314 "check.cog"
     auto rightCursor = 

#line 1314 "check.cog"
                                       

#line 1314 "check.cog"
                                 DEREF(

#line 1314 "check.cog"
                            DEREF(

#line 1314 "check.cog"
                       right).args).begin();


#line 1316 "check.cog"
     while(

#line 1316 "check.cog"
                      

#line 1316 "check.cog"
           leftCursor 

#line 1316 "check.cog"
                      != 

#line 1316 "check.cog"
                                      

#line 1316 "check.cog"
                                  DEREF(

#line 1316 "check.cog"
                             DEREF(

#line 1316 "check.cog"
                         left).args).end())
{
{


#line 1318 "check.cog"
         

#line 1318 "check.cog"
         auto leftArg = 

#line 1318 "check.cog"
                       

#line 1318 "check.cog"
                       *

#line 1318 "check.cog"
                        leftCursor;


#line 1319 "check.cog"
         

#line 1319 "check.cog"
         auto rightArg = 

#line 1319 "check.cog"
                        

#line 1319 "check.cog"
                        *

#line 1319 "check.cog"
                         rightCursor;


#line 1321 "check.cog"
         if(

#line 1321 "check.cog"
            

#line 1321 "check.cog"
            !

#line 1321 "check.cog"
                      

#line 1321 "check.cog"
             isSameVal(

#line 1322 "check.cog"
                    DEREF(

#line 1322 "check.cog"
             leftArg).value, 

#line 1323 "check.cog"
                     DEREF(

#line 1323 "check.cog"
             rightArg).value))
{


#line 1325 "check.cog"
             return 

#line 1325 "check.cog"
                    false;
}


#line 1329 "check.cog"
         

#line 1329 "check.cog"
         

#line 1329 "check.cog"
         ++

#line 1329 "check.cog"
           leftCursor;


#line 1330 "check.cog"
         

#line 1330 "check.cog"
         

#line 1330 "check.cog"
         ++

#line 1330 "check.cog"
           rightCursor;
}
}


#line 1333 "check.cog"
     return 

#line 1333 "check.cog"
            true;
}


#line 1337 "check.cog"
 

#line 1340 "check.cog"
        Bool isSameDeclRef(

#line 1338 "check.cog"
                

#line 1338 "check.cog"
        ConstRef<

#line 1338 "check.cog"
                 DeclRefVal>  left, 

#line 1339 "check.cog"
                 

#line 1339 "check.cog"
         ConstRef<

#line 1339 "check.cog"
                  DeclRefVal>  right)
{


#line 1342 "check.cog"
     if(

#line 1342 "check.cog"
                  

#line 1342 "check.cog"
            DEREF(

#line 1342 "check.cog"
        left).decl 

#line 1342 "check.cog"
                  != 

#line 1342 "check.cog"
                          DEREF(

#line 1342 "check.cog"
                     right).decl)
{


#line 1343 "check.cog"
         return 

#line 1343 "check.cog"
                false;
}


#line 1345 "check.cog"
     return 

#line 1345 "check.cog"
                                 

#line 1345 "check.cog"
            isSameSpecializations(

#line 1346 "check.cog"
             DEREF(

#line 1346 "check.cog"
         left).specializations, 

#line 1347 "check.cog"
              DEREF(

#line 1347 "check.cog"
         right).specializations);
}


#line 1350 "check.cog"
 

#line 1353 "check.cog"
        Bool isSameType(

#line 1351 "check.cog"
        Type left, 

#line 1352 "check.cog"
         Type right)
{


#line 1355 "check.cog"
     if(

#line 1355 "check.cog"
                         

#line 1355 "check.cog"
            DEREF(

#line 1355 "check.cog"
        left).directClass 

#line 1355 "check.cog"
                         != 

#line 1355 "check.cog"
                                 DEREF(

#line 1355 "check.cog"
                            right).directClass)
{


#line 1356 "check.cog"
         return 

#line 1356 "check.cog"
                false;
}


#line 1358 "check.cog"
     if(auto leftDeclRefType = 

#line 1358 "check.cog"
                                             

#line 1358 "check.cog"
                                

#line 1358 "check.cog"
                              as<

#line 1358 "check.cog"
                                 DeclRefType> (

#line 1358 "check.cog"
                                              left))
{


#line 1360 "check.cog"
         if(auto rightDeclRefType = 

#line 1360 "check.cog"
                                                  

#line 1360 "check.cog"
                                     

#line 1360 "check.cog"
                                   as<

#line 1360 "check.cog"
                                      DeclRefType> (

#line 1360 "check.cog"
                                                   right))
{


#line 1363 "check.cog"
             if(

#line 1363 "check.cog"
                             

#line 1363 "check.cog"
                isSameDeclRef(

#line 1364 "check.cog"
                                DEREF(

#line 1364 "check.cog"
                 leftDeclRefType).declRef, 

#line 1365 "check.cog"
                                 DEREF(

#line 1365 "check.cog"
                 rightDeclRefType).declRef))
{


#line 1367 "check.cog"
                 return 

#line 1367 "check.cog"
                        true;
}
}
}


#line 1372 "check.cog"
     return 

#line 1372 "check.cog"
            false;
}


#line 1375 "check.cog"
 

#line 1378 "check.cog"
     Exp createCastExpr(

#line 1376 "check.cog"
           Type toType, 

#line 1377 "check.cog"
           Exp fromExp)
{


#line 1380 "check.cog"
  

#line 1380 "check.cog"
  auto castExpr = 

#line 1380 "check.cog"
                                       

#line 1380 "check.cog"
                             

#line 1380 "check.cog"
                 createObject<

#line 1380 "check.cog"
                              CastExpr> ();


#line 1381 "check.cog"
          DEREF(

#line 1381 "check.cog"
  castExpr).loc = 

#line 1381 "check.cog"
                        DEREF(

#line 1381 "check.cog"
                 fromExp).loc;


#line 1382 "check.cog"
                 DEREF(

#line 1382 "check.cog"
          DEREF(

#line 1382 "check.cog"
  castExpr).toType).type = 

#line 1382 "check.cog"
                         toType;


#line 1383 "check.cog"
          DEREF(

#line 1383 "check.cog"
  castExpr).type = 

#line 1383 "check.cog"
                  toType;


#line 1384 "check.cog"
          DEREF(

#line 1384 "check.cog"
  castExpr).arg = 

#line 1384 "check.cog"
                 fromExp;


#line 1385 "check.cog"
  return 

#line 1385 "check.cog"
         castExpr;
}


#line 1388 "check.cog"
 

#line 1394 "check.cog"
        Bool tryCoerceImpl(

#line 1389 "check.cog"
                        

#line 1389 "check.cog"
            CheckContext

#line 1389 "check.cog"
                        * context, 

#line 1390 "check.cog"
               Exp fromExp, 

#line 1391 "check.cog"
                Type fromType, 

#line 1392 "check.cog"
                 

#line 1392 "check.cog"
              Exp

#line 1392 "check.cog"
                 * toExp, 

#line 1393 "check.cog"
              Type toType)
{


#line 1396 "check.cog"
     if(

#line 1396 "check.cog"
                  

#line 1396 "check.cog"
        isSameType(

#line 1396 "check.cog"
                   fromType, 

#line 1396 "check.cog"
                             toType))
{


#line 1398 "check.cog"
         if(

#line 1398 "check.cog"
            toExp)
{


#line 1400 "check.cog"
             

#line 1400 "check.cog"
             *

#line 1400 "check.cog"
              toExp = 

#line 1400 "check.cog"
                      fromExp;
}


#line 1403 "check.cog"
         return 

#line 1403 "check.cog"
                true;
}


#line 1406 "check.cog"
     if(

#line 1406 "check.cog"
                          

#line 1406 "check.cog"
               

#line 1406 "check.cog"
        isError(

#line 1406 "check.cog"
                fromType) 

#line 1406 "check.cog"
                          || 

#line 1406 "check.cog"
                                    

#line 1406 "check.cog"
                             isError(

#line 1406 "check.cog"
                                     toType))
{


#line 1408 "check.cog"
         if(

#line 1408 "check.cog"
            toExp)
{


#line 1410 "check.cog"
             

#line 1410 "check.cog"
             *

#line 1410 "check.cog"
              toExp = 

#line 1410 "check.cog"
                      fromExp;
}


#line 1412 "check.cog"
         return 

#line 1412 "check.cog"
                true;
}


#line 1415 "check.cog"
  if(auto fromNullType = 

#line 1415 "check.cog"
                                    

#line 1415 "check.cog"
                          

#line 1415 "check.cog"
                        as<

#line 1415 "check.cog"
                           NullType> (

#line 1415 "check.cog"
                                     fromType))
{


#line 1417 "check.cog"
   if(auto toClassType = 

#line 1417 "check.cog"
                                     

#line 1417 "check.cog"
                          

#line 1417 "check.cog"
                        as<

#line 1417 "check.cog"
                           ClassType> (

#line 1417 "check.cog"
                                      toType))
{


#line 1419 "check.cog"
    if(

#line 1419 "check.cog"
       toExp)
{


#line 1421 "check.cog"
     

#line 1421 "check.cog"
     *

#line 1421 "check.cog"
      toExp = 

#line 1421 "check.cog"
                            

#line 1421 "check.cog"
              createCastExpr(

#line 1421 "check.cog"
                             toType, 

#line 1421 "check.cog"
                                     fromExp);
}


#line 1423 "check.cog"
    return 

#line 1423 "check.cog"
           true;
}


#line 1425 "check.cog"
   if(auto toPtrType = 

#line 1425 "check.cog"
                                 

#line 1425 "check.cog"
                        

#line 1425 "check.cog"
                      as<

#line 1425 "check.cog"
                         PtrType> (

#line 1425 "check.cog"
                                  toType))
{


#line 1427 "check.cog"
    if(

#line 1427 "check.cog"
       toExp)
{


#line 1429 "check.cog"
     

#line 1429 "check.cog"
     *

#line 1429 "check.cog"
      toExp = 

#line 1429 "check.cog"
                            

#line 1429 "check.cog"
              createCastExpr(

#line 1429 "check.cog"
                             toType, 

#line 1429 "check.cog"
                                     fromExp);
}


#line 1431 "check.cog"
    return 

#line 1431 "check.cog"
           true;
}
}


#line 1441 "check.cog"
     return 

#line 1441 "check.cog"
            false;
}


#line 1444 "check.cog"
 

#line 1449 "check.cog"
        Bool tryCoerceImpl(

#line 1445 "check.cog"
                        

#line 1445 "check.cog"
            CheckContext

#line 1445 "check.cog"
                        * context, 

#line 1446 "check.cog"
               Exp fromExp, 

#line 1447 "check.cog"
                 

#line 1447 "check.cog"
              Exp

#line 1447 "check.cog"
                 * toExp, 

#line 1448 "check.cog"
              Type toType)
{


#line 1451 "check.cog"
     if(auto fromOverloadedExpr = 

#line 1451 "check.cog"
                                                   

#line 1451 "check.cog"
                                   

#line 1451 "check.cog"
                                 as<

#line 1451 "check.cog"
                                    OverloadedExpr> (

#line 1451 "check.cog"
                                                    fromExp))
{


#line 1455 "check.cog"
                  

#line 1455 "check.cog"
                  

#line 1455 "check.cog"
         cogAssert(

#line 1455 "check.cog"
                   

#line 1455 "check.cog"
                   !

#line 1455 "check.cog"
                    "unimplemented");
}
else
{


#line 1459 "check.cog"
         return 

#line 1459 "check.cog"
                             

#line 1459 "check.cog"
                tryCoerceImpl(

#line 1460 "check.cog"
             context, 

#line 1461 "check.cog"
             fromExp, 

#line 1462 "check.cog"
                    DEREF(

#line 1462 "check.cog"
             fromExp).type, 

#line 1463 "check.cog"
             toExp, 

#line 1464 "check.cog"
             toType);
}
}


#line 1468 "check.cog"
 

#line 1472 "check.cog"
        Exp coerce(

#line 1469 "check.cog"
                        

#line 1469 "check.cog"
            CheckContext

#line 1469 "check.cog"
                        * context, 

#line 1470 "check.cog"
            Exp exp, 

#line 1471 "check.cog"
             Type type)
{


#line 1474 "check.cog"
     

#line 1474 "check.cog"
     

#line 1474 "check.cog"
                  Exp result = 

#line 1474 "check.cog"
                        nullptr;


#line 1475 "check.cog"
     if(

#line 1475 "check.cog"
                     

#line 1475 "check.cog"
        tryCoerceImpl(

#line 1476 "check.cog"
         context, 

#line 1477 "check.cog"
         exp, 

#line 1478 "check.cog"
         

#line 1478 "check.cog"
         &

#line 1478 "check.cog"
          result, 

#line 1479 "check.cog"
         type))
{


#line 1481 "check.cog"
         return 

#line 1481 "check.cog"
                result;
}


#line 1484 "check.cog"
             

#line 1484 "check.cog"
             

#line 1484 "check.cog"
     diagnose(

#line 1484 "check.cog"
                     

#line 1484 "check.cog"
              getSink(

#line 1484 "check.cog"
                      context), 

#line 1484 "check.cog"
                                   DEREF(

#line 1484 "check.cog"
                                exp).loc, 

#line 1484 "check.cog"
                                         kDiagnostic_cannotConvertType, 

#line 1484 "check.cog"
                                                                        type, 

#line 1484 "check.cog"
                                                                                 DEREF(

#line 1484 "check.cog"
                                                                              exp).type);


#line 1485 "check.cog"
     return 

#line 1485 "check.cog"
                          

#line 1485 "check.cog"
            createErrorExp(

#line 1485 "check.cog"
                           context, 

#line 1485 "check.cog"
                                    exp);
}


#line 1488 "check.cog"
 

#line 1492 "check.cog"
        Bool canCoerce(

#line 1489 "check.cog"
                        

#line 1489 "check.cog"
            CheckContext

#line 1489 "check.cog"
                        * context, 

#line 1490 "check.cog"
            Exp exp, 

#line 1491 "check.cog"
             Type type)
{


#line 1494 "check.cog"
     return 

#line 1494 "check.cog"
                         

#line 1494 "check.cog"
            tryCoerceImpl(

#line 1495 "check.cog"
         context, 

#line 1496 "check.cog"
         exp, 

#line 1497 "check.cog"
         nullptr, 

#line 1498 "check.cog"
         type);
}


#line 1536 "check.cog"
 void issueTooFewArgsError(

#line 1537 "check.cog"
                                 

#line 1537 "check.cog"
           OverloadResolveContext

#line 1537 "check.cog"
                                 * context)
{


#line 1539 "check.cog"
  if(

#line 1539 "check.cog"
                  

#line 1539 "check.cog"
            DEREF(

#line 1539 "check.cog"
     context).mode 

#line 1539 "check.cog"
                  == 

#line 1539 "check.cog"
                     kOverloadResolveMode_justTrying)
{
}
else
{


#line 1543 "check.cog"
           

#line 1543 "check.cog"
           

#line 1543 "check.cog"
   diagnose(

#line 1543 "check.cog"
                   

#line 1543 "check.cog"
            getSink(

#line 1543 "check.cog"
                           DEREF(

#line 1543 "check.cog"
                    context).checkContext), 

#line 1543 "check.cog"
                                                         DEREF(

#line 1543 "check.cog"
                                                  DEREF(

#line 1543 "check.cog"
                                           context).appExp).loc, 

#line 1543 "check.cog"
                                                               kDiagnostic_tooFewArgs);
}
}


#line 1547 "check.cog"
 void issueTooManyArgsError(

#line 1548 "check.cog"
                                 

#line 1548 "check.cog"
           OverloadResolveContext

#line 1548 "check.cog"
                                 * context)
{


#line 1550 "check.cog"
  if(

#line 1550 "check.cog"
                  

#line 1550 "check.cog"
            DEREF(

#line 1550 "check.cog"
     context).mode 

#line 1550 "check.cog"
                  == 

#line 1550 "check.cog"
                     kOverloadResolveMode_justTrying)
{
}
else
{


#line 1554 "check.cog"
           

#line 1554 "check.cog"
           

#line 1554 "check.cog"
   diagnose(

#line 1554 "check.cog"
                   

#line 1554 "check.cog"
            getSink(

#line 1554 "check.cog"
                           DEREF(

#line 1554 "check.cog"
                    context).checkContext), 

#line 1554 "check.cog"
                                                         DEREF(

#line 1554 "check.cog"
                                                  DEREF(

#line 1554 "check.cog"
                                           context).appExp).loc, 

#line 1554 "check.cog"
                                                               kDiagnostic_tooManyArgs);
}
}


#line 1558 "check.cog"
 

#line 1561 "check.cog"
        Bool checkOverloadCandidateArity(

#line 1559 "check.cog"
                                 

#line 1559 "check.cog"
           OverloadResolveContext

#line 1559 "check.cog"
                                 * context, 

#line 1560 "check.cog"
                   

#line 1560 "check.cog"
                Ref<

#line 1560 "check.cog"
                    OverloadCandidate>  candidate)
{


#line 1563 "check.cog"
     

#line 1563 "check.cog"
     auto args = 

#line 1563 "check.cog"
                

#line 1563 "check.cog"
                &

#line 1563 "check.cog"
                               DEREF(

#line 1563 "check.cog"
                        DEREF(

#line 1563 "check.cog"
                 context).appExp).args;


#line 1564 "check.cog"
     

#line 1564 "check.cog"
     auto argCursor = 

#line 1564 "check.cog"
                               

#line 1564 "check.cog"
                         DEREF(

#line 1564 "check.cog"
                     args).begin();


#line 1565 "check.cog"
     

#line 1565 "check.cog"
     auto argEnd = 

#line 1565 "check.cog"
                          

#line 1565 "check.cog"
                      DEREF(

#line 1565 "check.cog"
                  args).end();


#line 1567 "check.cog"
     if(auto funcDeclRef = 

#line 1567 "check.cog"
                                          

#line 1567 "check.cog"
                            

#line 1567 "check.cog"
                          as<

#line 1567 "check.cog"
                             FuncDeclBase> (

#line 1567 "check.cog"
                                                    DEREF(

#line 1567 "check.cog"
                                           candidate).declRef))
{


#line 1569 "check.cog"
         for(auto dd : 

#line 1569 "check.cog"
                               

#line 1569 "check.cog"
                       getDecls(

#line 1569 "check.cog"
                                funcDeclRef))
{
{


#line 1571 "check.cog"
             if(auto paramDeclRef = 

#line 1571 "check.cog"
                                                

#line 1571 "check.cog"
                                     

#line 1571 "check.cog"
                                   as<

#line 1571 "check.cog"
                                      ParamDecl> (

#line 1571 "check.cog"
                                                 dd))
{


#line 1573 "check.cog"
                 if(

#line 1573 "check.cog"
                    

#line 1573 "check.cog"
                    !

#line 1573 "check.cog"
                     (

#line 1573 "check.cog"
                                

#line 1573 "check.cog"
                      argCursor 

#line 1573 "check.cog"
                                != 

#line 1573 "check.cog"
                                   argEnd))
{


#line 1576 "check.cog"
                          

#line 1576 "check.cog"
                          

#line 1576 "check.cog"
      issueTooFewArgsError(

#line 1576 "check.cog"
                           context);


#line 1577 "check.cog"
                     return 

#line 1577 "check.cog"
                            false;
}


#line 1580 "check.cog"
                 

#line 1580 "check.cog"
                 

#line 1580 "check.cog"
                 ++

#line 1580 "check.cog"
                   argCursor;
}
else
{
}
}
}


#line 1586 "check.cog"
         if(

#line 1586 "check.cog"
                      

#line 1586 "check.cog"
            argCursor 

#line 1586 "check.cog"
                      != 

#line 1586 "check.cog"
                         argEnd)
{


#line 1589 "check.cog"
                         

#line 1589 "check.cog"
                         

#line 1589 "check.cog"
    issueTooManyArgsError(

#line 1589 "check.cog"
                          context);


#line 1590 "check.cog"
             return 

#line 1590 "check.cog"
                    false;
}


#line 1593 "check.cog"
         return 

#line 1593 "check.cog"
                true;
}
else
{


#line 1595 "check.cog"
       if(auto genericDeclRef = 

#line 1595 "check.cog"
                                              

#line 1595 "check.cog"
                                 

#line 1595 "check.cog"
                               as<

#line 1595 "check.cog"
                                  GenericDecl> (

#line 1595 "check.cog"
                                                        DEREF(

#line 1595 "check.cog"
                                               candidate).declRef))
{


#line 1597 "check.cog"
   for(auto dd : 

#line 1597 "check.cog"
                         

#line 1597 "check.cog"
                 getDecls(

#line 1597 "check.cog"
                          genericDeclRef))
{
{


#line 1599 "check.cog"
    if(auto genericParamDeclRef = 

#line 1599 "check.cog"
                                                     

#line 1599 "check.cog"
                                   

#line 1599 "check.cog"
                                 as<

#line 1599 "check.cog"
                                    GenericParamDecl> (

#line 1599 "check.cog"
                                                      dd))
{


#line 1601 "check.cog"
     if(

#line 1601 "check.cog"
        

#line 1601 "check.cog"
        !

#line 1601 "check.cog"
         (

#line 1601 "check.cog"
                    

#line 1601 "check.cog"
          argCursor 

#line 1601 "check.cog"
                    != 

#line 1601 "check.cog"
                       argEnd))
{


#line 1604 "check.cog"
                          

#line 1604 "check.cog"
                          

#line 1604 "check.cog"
      issueTooFewArgsError(

#line 1604 "check.cog"
                           context);


#line 1605 "check.cog"
      return 

#line 1605 "check.cog"
             false;
}


#line 1608 "check.cog"
     

#line 1608 "check.cog"
     

#line 1608 "check.cog"
     ++

#line 1608 "check.cog"
       argCursor;
}
else
{
}
}
}


#line 1614 "check.cog"
         if(

#line 1614 "check.cog"
                      

#line 1614 "check.cog"
            argCursor 

#line 1614 "check.cog"
                      != 

#line 1614 "check.cog"
                         argEnd)
{


#line 1617 "check.cog"
                         

#line 1617 "check.cog"
                         

#line 1617 "check.cog"
    issueTooManyArgsError(

#line 1617 "check.cog"
                          context);


#line 1618 "check.cog"
             return 

#line 1618 "check.cog"
                    false;
}


#line 1621 "check.cog"
         return 

#line 1621 "check.cog"
                true;
}
else
{


#line 1626 "check.cog"
         return 

#line 1626 "check.cog"
                false;
}
}
}


#line 1630 "check.cog"
 

#line 1633 "check.cog"
        Bool checkOverloadCandidateTypes(

#line 1631 "check.cog"
                                 

#line 1631 "check.cog"
           OverloadResolveContext

#line 1631 "check.cog"
                                 * context, 

#line 1632 "check.cog"
                   

#line 1632 "check.cog"
                Ref<

#line 1632 "check.cog"
                    OverloadCandidate>  candidate)
{


#line 1635 "check.cog"
     

#line 1635 "check.cog"
     auto args = 

#line 1635 "check.cog"
                

#line 1635 "check.cog"
                &

#line 1635 "check.cog"
                               DEREF(

#line 1635 "check.cog"
                        DEREF(

#line 1635 "check.cog"
                 context).appExp).args;


#line 1636 "check.cog"
     

#line 1636 "check.cog"
     auto argCursor = 

#line 1636 "check.cog"
                               

#line 1636 "check.cog"
                         DEREF(

#line 1636 "check.cog"
                     args).begin();


#line 1637 "check.cog"
     

#line 1637 "check.cog"
     auto argEnd = 

#line 1637 "check.cog"
                          

#line 1637 "check.cog"
                      DEREF(

#line 1637 "check.cog"
                  args).end();


#line 1639 "check.cog"
     if(auto funcDeclRef = 

#line 1639 "check.cog"
                                          

#line 1639 "check.cog"
                            

#line 1639 "check.cog"
                          as<

#line 1639 "check.cog"
                             FuncDeclBase> (

#line 1639 "check.cog"
                                                    DEREF(

#line 1639 "check.cog"
                                           candidate).declRef))
{


#line 1641 "check.cog"
         for(auto dd : 

#line 1641 "check.cog"
                               

#line 1641 "check.cog"
                       getDecls(

#line 1641 "check.cog"
                                funcDeclRef))
{
{


#line 1643 "check.cog"
             if(auto paramDeclRef = 

#line 1643 "check.cog"
                                                

#line 1643 "check.cog"
                                     

#line 1643 "check.cog"
                                   as<

#line 1643 "check.cog"
                                      ParamDecl> (

#line 1643 "check.cog"
                                                 dd))
{


#line 1645 "check.cog"
                 if(

#line 1645 "check.cog"
                    

#line 1645 "check.cog"
                    !

#line 1645 "check.cog"
                     (

#line 1645 "check.cog"
                                

#line 1645 "check.cog"
                      argCursor 

#line 1645 "check.cog"
                                != 

#line 1645 "check.cog"
                                   argEnd))
{


#line 1647 "check.cog"
                              

#line 1647 "check.cog"
                              

#line 1647 "check.cog"
                     cogAssert(

#line 1647 "check.cog"
                               false);


#line 1649 "check.cog"
                     return 

#line 1649 "check.cog"
                            false;
}


#line 1652 "check.cog"
                 

#line 1652 "check.cog"
                 auto arg = 

#line 1652 "check.cog"
                           

#line 1652 "check.cog"
                           *

#line 1652 "check.cog"
                            argCursor;


#line 1653 "check.cog"
                 

#line 1653 "check.cog"
                 auto argExpr = 

#line 1653 "check.cog"
                               

#line 1653 "check.cog"
                               &

#line 1653 "check.cog"
                                   DEREF(

#line 1653 "check.cog"
                                arg).exp;


#line 1655 "check.cog"
                 

#line 1655 "check.cog"
                 auto paramType = 

#line 1655 "check.cog"
                                        

#line 1655 "check.cog"
                                 getType(

#line 1655 "check.cog"
                                         paramDeclRef);


#line 1657 "check.cog"
                 if(

#line 1657 "check.cog"
                                 

#line 1657 "check.cog"
                           DEREF(

#line 1657 "check.cog"
                    context).mode 

#line 1657 "check.cog"
                                 == 

#line 1657 "check.cog"
                                    kOverloadResolveMode_justTrying)
{


#line 1659 "check.cog"
                     if(

#line 1659 "check.cog"
                        

#line 1659 "check.cog"
                        !

#line 1659 "check.cog"
                                  

#line 1659 "check.cog"
                         canCoerce(

#line 1660 "check.cog"
                                DEREF(

#line 1660 "check.cog"
                         context).checkContext, 

#line 1661 "check.cog"
                         

#line 1661 "check.cog"
                         *

#line 1661 "check.cog"
                          argExpr, 

#line 1662 "check.cog"
                         paramType))
{


#line 1664 "check.cog"
                         return 

#line 1664 "check.cog"
                                false;
}
}
else
{


#line 1669 "check.cog"
                     

#line 1669 "check.cog"
                     *

#line 1669 "check.cog"
                      argExpr = 

#line 1669 "check.cog"
                                      

#line 1669 "check.cog"
                                coerce(

#line 1670 "check.cog"
                                DEREF(

#line 1670 "check.cog"
                         context).checkContext, 

#line 1671 "check.cog"
                         

#line 1671 "check.cog"
                         *

#line 1671 "check.cog"
                          argExpr, 

#line 1672 "check.cog"
                         paramType);
}


#line 1675 "check.cog"
                 

#line 1675 "check.cog"
                 

#line 1675 "check.cog"
                 ++

#line 1675 "check.cog"
                   argCursor;
}
else
{
}
}
}


#line 1681 "check.cog"
         if(

#line 1681 "check.cog"
                      

#line 1681 "check.cog"
            argCursor 

#line 1681 "check.cog"
                      != 

#line 1681 "check.cog"
                         argEnd)
{


#line 1683 "check.cog"
                      

#line 1683 "check.cog"
                      

#line 1683 "check.cog"
             cogAssert(

#line 1683 "check.cog"
                       false);


#line 1685 "check.cog"
             return 

#line 1685 "check.cog"
                    false;
}


#line 1688 "check.cog"
         return 

#line 1688 "check.cog"
                true;
}
else
{


#line 1690 "check.cog"
       if(auto genericDeclRef = 

#line 1690 "check.cog"
                                              

#line 1690 "check.cog"
                                 

#line 1690 "check.cog"
                               as<

#line 1690 "check.cog"
                                  GenericDecl> (

#line 1690 "check.cog"
                                                        DEREF(

#line 1690 "check.cog"
                                               candidate).declRef))
{


#line 1692 "check.cog"
         for(auto dd : 

#line 1692 "check.cog"
                               

#line 1692 "check.cog"
                       getDecls(

#line 1692 "check.cog"
                                genericDeclRef))
{
{


#line 1694 "check.cog"
             if(auto paramDeclRef = 

#line 1694 "check.cog"
                                                       

#line 1694 "check.cog"
                                     

#line 1694 "check.cog"
                                   as<

#line 1694 "check.cog"
                                      GenericParamDecl> (

#line 1694 "check.cog"
                                                        dd))
{


#line 1696 "check.cog"
                 if(

#line 1696 "check.cog"
                    

#line 1696 "check.cog"
                    !

#line 1696 "check.cog"
                     (

#line 1696 "check.cog"
                                

#line 1696 "check.cog"
                      argCursor 

#line 1696 "check.cog"
                                != 

#line 1696 "check.cog"
                                   argEnd))
{


#line 1698 "check.cog"
                              

#line 1698 "check.cog"
                              

#line 1698 "check.cog"
                     cogAssert(

#line 1698 "check.cog"
                               false);


#line 1700 "check.cog"
                     return 

#line 1700 "check.cog"
                            false;
}


#line 1703 "check.cog"
                 

#line 1703 "check.cog"
                 auto arg = 

#line 1703 "check.cog"
                           

#line 1703 "check.cog"
                           *

#line 1703 "check.cog"
                            argCursor;


#line 1704 "check.cog"
                 

#line 1704 "check.cog"
                 auto argExpr = 

#line 1704 "check.cog"
                               

#line 1704 "check.cog"
                               &

#line 1704 "check.cog"
                                   DEREF(

#line 1704 "check.cog"
                                arg).exp;


#line 1706 "check.cog"
                 if(

#line 1706 "check.cog"
                                 

#line 1706 "check.cog"
                           DEREF(

#line 1706 "check.cog"
                    context).mode 

#line 1706 "check.cog"
                                 == 

#line 1706 "check.cog"
                                    kOverloadResolveMode_justTrying)
{


#line 1708 "check.cog"
      if(auto type = 

#line 1708 "check.cog"
                                   

#line 1708 "check.cog"
                    tryCoerceToType(

#line 1708 "check.cog"
                                           DEREF(

#line 1708 "check.cog"
                                    context).checkContext, 

#line 1708 "check.cog"
                                                          

#line 1708 "check.cog"
                                                          *

#line 1708 "check.cog"
                                                           argExpr))
{
}
else
{


#line 1712 "check.cog"
       return 

#line 1712 "check.cog"
              false;
}
}
else
{


#line 1717 "check.cog"
      

#line 1717 "check.cog"
      *

#line 1717 "check.cog"
       argExpr = 

#line 1717 "check.cog"
                                 

#line 1717 "check.cog"
                 coerceToTypeExpr(

#line 1717 "check.cog"
                                         DEREF(

#line 1717 "check.cog"
                                  context).checkContext, 

#line 1717 "check.cog"
                                                        

#line 1717 "check.cog"
                                                        *

#line 1717 "check.cog"
                                                         argExpr);
}


#line 1720 "check.cog"
                 

#line 1720 "check.cog"
                 

#line 1720 "check.cog"
                 ++

#line 1720 "check.cog"
                   argCursor;
}
else
{
}
}
}


#line 1726 "check.cog"
         if(

#line 1726 "check.cog"
                      

#line 1726 "check.cog"
            argCursor 

#line 1726 "check.cog"
                      != 

#line 1726 "check.cog"
                         argEnd)
{


#line 1728 "check.cog"
                      

#line 1728 "check.cog"
                      

#line 1728 "check.cog"
             cogAssert(

#line 1728 "check.cog"
                       false);


#line 1730 "check.cog"
             return 

#line 1730 "check.cog"
                    false;
}


#line 1733 "check.cog"
         return 

#line 1733 "check.cog"
                true;
}
else
{


#line 1739 "check.cog"
         return 

#line 1739 "check.cog"
                false;
}
}
}


#line 1743 "check.cog"
 

#line 1746 "check.cog"
        Bool checkOverloadCandidateDirections(

#line 1744 "check.cog"
                                    

#line 1744 "check.cog"
              OverloadResolveContext

#line 1744 "check.cog"
                                    * context, 

#line 1745 "check.cog"
                   

#line 1745 "check.cog"
                Ref<

#line 1745 "check.cog"
                    OverloadCandidate>  candidate)
{


#line 1748 "check.cog"
     return 

#line 1748 "check.cog"
            true;
}


#line 1751 "check.cog"
 void checkOverloadCandidateImpl(

#line 1752 "check.cog"
                                    

#line 1752 "check.cog"
              OverloadResolveContext

#line 1752 "check.cog"
                                    * context, 

#line 1753 "check.cog"
                   

#line 1753 "check.cog"
                Ref<

#line 1753 "check.cog"
                    OverloadCandidate>  candidate)
{


#line 1756 "check.cog"
              DEREF(

#line 1756 "check.cog"
     candidate).state = 

#line 1756 "check.cog"
                       kOverloadCandidateState_Unchecked;


#line 1757 "check.cog"
     if(

#line 1757 "check.cog"
        

#line 1757 "check.cog"
        !

#line 1757 "check.cog"
                                    

#line 1757 "check.cog"
         checkOverloadCandidateArity(

#line 1757 "check.cog"
                                     context, 

#line 1757 "check.cog"
                                              candidate))
{


#line 1758 "check.cog"
         return;
}


#line 1759 "check.cog"
              DEREF(

#line 1759 "check.cog"
     candidate).state = 

#line 1759 "check.cog"
                       kOverloadCandidateState_CheckedArity;


#line 1760 "check.cog"
     if(

#line 1760 "check.cog"
        

#line 1760 "check.cog"
        !

#line 1760 "check.cog"
                                    

#line 1760 "check.cog"
         checkOverloadCandidateTypes(

#line 1760 "check.cog"
                                     context, 

#line 1760 "check.cog"
                                              candidate))
{


#line 1761 "check.cog"
         return;
}


#line 1762 "check.cog"
              DEREF(

#line 1762 "check.cog"
     candidate).state = 

#line 1762 "check.cog"
                       kOverloadCandidateState_CheckedTypes;


#line 1763 "check.cog"
     if(

#line 1763 "check.cog"
        

#line 1763 "check.cog"
        !

#line 1763 "check.cog"
                                         

#line 1763 "check.cog"
         checkOverloadCandidateDirections(

#line 1763 "check.cog"
                                          context, 

#line 1763 "check.cog"
                                                   candidate))
{


#line 1764 "check.cog"
         return;
}


#line 1765 "check.cog"
              DEREF(

#line 1765 "check.cog"
     candidate).state = 

#line 1765 "check.cog"
                       kOverloadCandidateState_Applicable;
}


#line 1770 "check.cog"
 void checkOverloadCandidate(

#line 1771 "check.cog"
                                    

#line 1771 "check.cog"
              OverloadResolveContext

#line 1771 "check.cog"
                                    * context, 

#line 1772 "check.cog"
                   

#line 1772 "check.cog"
                Ref<

#line 1772 "check.cog"
                    OverloadCandidate>  candidate)
{


#line 1774 "check.cog"
                               

#line 1774 "check.cog"
                               

#line 1774 "check.cog"
     checkOverloadCandidateImpl(

#line 1774 "check.cog"
                                context, 

#line 1774 "check.cog"
                                         candidate);
}


#line 1778 "check.cog"
 

#line 1781 "check.cog"
        Int compareCandidates(

#line 1779 "check.cog"
           

#line 1779 "check.cog"
        Ref<

#line 1779 "check.cog"
            OverloadCandidate>  left, 

#line 1780 "check.cog"
            

#line 1780 "check.cog"
         Ref<

#line 1780 "check.cog"
             OverloadCandidate>  right)
{


#line 1784 "check.cog"
     if(

#line 1784 "check.cog"
                   

#line 1784 "check.cog"
            DEREF(

#line 1784 "check.cog"
        left).state 

#line 1784 "check.cog"
                   != 

#line 1784 "check.cog"
                           DEREF(

#line 1784 "check.cog"
                      right).state)
{


#line 1785 "check.cog"
         return 

#line 1785 "check.cog"
                                 

#line 1785 "check.cog"
                   

#line 1785 "check.cog"
                int(

#line 1785 "check.cog"
                         DEREF(

#line 1785 "check.cog"
                    right).state) 

#line 1785 "check.cog"
                                 - 

#line 1785 "check.cog"
                                      

#line 1785 "check.cog"
                                   int(

#line 1785 "check.cog"
                                           DEREF(

#line 1785 "check.cog"
                                       left).state);
}


#line 1790 "check.cog"
     return 

#line 1790 "check.cog"
            0;
}


#line 1793 "check.cog"
 void addCheckedOverloadCandidate(

#line 1794 "check.cog"
                                    

#line 1794 "check.cog"
              OverloadResolveContext

#line 1794 "check.cog"
                                    * context, 

#line 1795 "check.cog"
                   

#line 1795 "check.cog"
                Ref<

#line 1795 "check.cog"
                    OverloadCandidate>  candidate)
{


#line 1802 "check.cog"
     

#line 1802 "check.cog"
     

#line 1802 "check.cog"
                     Bool anyBetter = 

#line 1802 "check.cog"
                            false;


#line 1803 "check.cog"
     

#line 1803 "check.cog"
     

#line 1803 "check.cog"
                    Bool anyWorse = 

#line 1803 "check.cog"
                           false;


#line 1807 "check.cog"
     {


#line 1807 "check.cog"
         

#line 1807 "check.cog"
         

#line 1807 "check.cog"
                  UInt ii = 

#line 1807 "check.cog"
                         0;
for(;

#line 1807 "check.cog"
                               

#line 1807 "check.cog"
                            ii 

#line 1807 "check.cog"
                               < 

#line 1807 "check.cog"
                                                            

#line 1807 "check.cog"
                                                   DEREF(

#line 1807 "check.cog"
                                        DEREF(

#line 1807 "check.cog"
                                 context).candidates).getCount();

#line 1807 "check.cog"
                                                                

#line 1807 "check.cog"
                                                                ++

#line 1807 "check.cog"
                                                                  ii)
{
{


#line 1809 "check.cog"
         

#line 1809 "check.cog"
         auto compareResult = 

#line 1809 "check.cog"
                                              

#line 1809 "check.cog"
                             compareCandidates(

#line 1810 "check.cog"
             candidate, 

#line 1811 "check.cog"
                               

#line 1811 "check.cog"
                    DEREF(

#line 1811 "check.cog"
             context).candidates[

#line 1811 "check.cog"
                                ii]);


#line 1815 "check.cog"
         if(

#line 1815 "check.cog"
                          

#line 1815 "check.cog"
            compareResult 

#line 1815 "check.cog"
                          < 

#line 1815 "check.cog"
                            0)
{


#line 1819 "check.cog"
                                            

#line 1819 "check.cog"
                                            

#line 1819 "check.cog"
                               DEREF(

#line 1819 "check.cog"
                    DEREF(

#line 1819 "check.cog"
             context).candidates).fastRemoveAt(

#line 1819 "check.cog"
                                             ii);


#line 1821 "check.cog"
             anyBetter = 

#line 1821 "check.cog"
                         true;


#line 1824 "check.cog"
             

#line 1824 "check.cog"
             

#line 1824 "check.cog"
             --

#line 1824 "check.cog"
               ii;
}
else
{


#line 1826 "check.cog"
              if(

#line 1826 "check.cog"
                               

#line 1826 "check.cog"
                 compareResult 

#line 1826 "check.cog"
                               > 

#line 1826 "check.cog"
                                 0)
{


#line 1830 "check.cog"
             anyWorse = 

#line 1830 "check.cog"
                        true;
}
}
}
}}


#line 1834 "check.cog"
     if(

#line 1834 "check.cog"
        anyWorse)
{


#line 1836 "check.cog"
                  

#line 1836 "check.cog"
                  

#line 1836 "check.cog"
         cogAssert(

#line 1836 "check.cog"
                   

#line 1836 "check.cog"
                   !

#line 1836 "check.cog"
                    anyBetter);


#line 1841 "check.cog"
         return;
}


#line 1845 "check.cog"
                              

#line 1845 "check.cog"
                              

#line 1845 "check.cog"
                       DEREF(

#line 1845 "check.cog"
            DEREF(

#line 1845 "check.cog"
     context).candidates).append(

#line 1845 "check.cog"
                               candidate);
}


#line 1848 "check.cog"
 void addOverloadCandidate(

#line 1849 "check.cog"
                                    

#line 1849 "check.cog"
              OverloadResolveContext

#line 1849 "check.cog"
                                    * context, 

#line 1850 "check.cog"
                   

#line 1850 "check.cog"
                Ref<

#line 1850 "check.cog"
                    OverloadCandidate>  candidate)
{


#line 1852 "check.cog"
                           

#line 1852 "check.cog"
                           

#line 1852 "check.cog"
     checkOverloadCandidate(

#line 1852 "check.cog"
                            context, 

#line 1852 "check.cog"
                                     candidate);


#line 1853 "check.cog"
                                

#line 1853 "check.cog"
                                

#line 1853 "check.cog"
     addCheckedOverloadCandidate(

#line 1853 "check.cog"
                                 context, 

#line 1853 "check.cog"
                                          candidate);
}


#line 1856 "check.cog"
 void addSubscriptOverloadCandidate(

#line 1857 "check.cog"
                                    

#line 1857 "check.cog"
              OverloadResolveContext

#line 1857 "check.cog"
                                    * context, 

#line 1858 "check.cog"
                            

#line 1858 "check.cog"
              DeclRefValImpl<

#line 1858 "check.cog"
                             SubscriptDecl>  declRef)
{


#line 1862 "check.cog"
            

#line 1862 "check.cog"
            

#line 1862 "check.cog"
  ensureDecl(

#line 1862 "check.cog"
                    DEREF(

#line 1862 "check.cog"
             context).checkContext, 

#line 1862 "check.cog"
                                                  

#line 1862 "check.cog"
                                          DEREF(

#line 1862 "check.cog"
                                   declRef).getDecl());


#line 1864 "check.cog"
     

#line 1864 "check.cog"
     

#line 1864 "check.cog"
                    OverloadCandidate candidate;


#line 1865 "check.cog"
              DEREF(

#line 1865 "check.cog"
     candidate).declRef = 

#line 1865 "check.cog"
                         declRef;


#line 1866 "check.cog"
              DEREF(

#line 1866 "check.cog"
     candidate).resultType = 

#line 1866 "check.cog"
                                         

#line 1866 "check.cog"
                            getResultType(

#line 1866 "check.cog"
                                                 DEREF(

#line 1866 "check.cog"
                                          context).checkContext, 

#line 1866 "check.cog"
                                                                declRef);


#line 1868 "check.cog"
                         

#line 1868 "check.cog"
                         

#line 1868 "check.cog"
     addOverloadCandidate(

#line 1868 "check.cog"
                          context, 

#line 1868 "check.cog"
                                   candidate);
}


#line 1871 "check.cog"
 void addFuncOverloadCandidate(

#line 1872 "check.cog"
                                    

#line 1872 "check.cog"
              OverloadResolveContext

#line 1872 "check.cog"
                                    * context, 

#line 1873 "check.cog"
                            

#line 1873 "check.cog"
              DeclRefValImpl<

#line 1873 "check.cog"
                             FuncDeclBase>  declRef)
{


#line 1875 "check.cog"
            

#line 1875 "check.cog"
            

#line 1875 "check.cog"
  ensureDecl(

#line 1875 "check.cog"
                    DEREF(

#line 1875 "check.cog"
             context).checkContext, 

#line 1875 "check.cog"
                                                  

#line 1875 "check.cog"
                                          DEREF(

#line 1875 "check.cog"
                                   declRef).getDecl());


#line 1877 "check.cog"
     

#line 1877 "check.cog"
     

#line 1877 "check.cog"
                    OverloadCandidate candidate;


#line 1878 "check.cog"
              DEREF(

#line 1878 "check.cog"
     candidate).declRef = 

#line 1878 "check.cog"
                         declRef;


#line 1879 "check.cog"
              DEREF(

#line 1879 "check.cog"
     candidate).resultType = 

#line 1879 "check.cog"
                                         

#line 1879 "check.cog"
                            getResultType(

#line 1879 "check.cog"
                                                 DEREF(

#line 1879 "check.cog"
                                          context).checkContext, 

#line 1879 "check.cog"
                                                                declRef);


#line 1881 "check.cog"
                         

#line 1881 "check.cog"
                         

#line 1881 "check.cog"
     addOverloadCandidate(

#line 1881 "check.cog"
                          context, 

#line 1881 "check.cog"
                                   candidate);
}


#line 1884 "check.cog"
 void addInitializerOverloadCandidate(

#line 1885 "check.cog"
                                     

#line 1885 "check.cog"
               OverloadResolveContext

#line 1885 "check.cog"
                                     * context, 

#line 1886 "check.cog"
             Type type, 

#line 1887 "check.cog"
                             

#line 1887 "check.cog"
               DeclRefValImpl<

#line 1887 "check.cog"
                              InitializerDecl>  declRef)
{


#line 1889 "check.cog"
     

#line 1889 "check.cog"
     

#line 1889 "check.cog"
                    OverloadCandidate candidate;


#line 1890 "check.cog"
              DEREF(

#line 1890 "check.cog"
     candidate).declRef = 

#line 1890 "check.cog"
                         declRef;


#line 1891 "check.cog"
              DEREF(

#line 1891 "check.cog"
     candidate).resultType = 

#line 1891 "check.cog"
                            type;


#line 1892 "check.cog"
                         

#line 1892 "check.cog"
                         

#line 1892 "check.cog"
     addOverloadCandidate(

#line 1892 "check.cog"
                          context, 

#line 1892 "check.cog"
                                   candidate);
}


#line 1895 "check.cog"
 

#line 1900 "check.cog"
        Exp createDeclRefExp(

#line 1896 "check.cog"
                       

#line 1896 "check.cog"
           CheckContext

#line 1896 "check.cog"
                       * context, 

#line 1897 "check.cog"
           CompactDeclRef declRef, 

#line 1898 "check.cog"
       SourceLoc loc, 

#line 1899 "check.cog"
           Exp baseExp)
{


#line 1902 "check.cog"
     

#line 1902 "check.cog"
     

#line 1902 "check.cog"
                     DeclRefExp declRefExp = 

#line 1902 "check.cog"
                                  nullptr;


#line 1903 "check.cog"
     if(

#line 1903 "check.cog"
        baseExp)
{


#line 1905 "check.cog"
         

#line 1905 "check.cog"
         auto memberRefExp = 

#line 1905 "check.cog"
                                                   

#line 1905 "check.cog"
                                        

#line 1905 "check.cog"
                            createObject<

#line 1905 "check.cog"
                                         MemberExp> ();


#line 1906 "check.cog"
                     DEREF(

#line 1906 "check.cog"
         memberRefExp).base = 

#line 1906 "check.cog"
                             baseExp;


#line 1907 "check.cog"
         declRefExp = 

#line 1907 "check.cog"
                      memberRefExp;
}
else
{


#line 1911 "check.cog"
         declRefExp = 

#line 1911 "check.cog"
                                              

#line 1911 "check.cog"
                                  

#line 1911 "check.cog"
                      createObject<

#line 1911 "check.cog"
                                   DeclRefExp> ();
}


#line 1914 "check.cog"
               DEREF(

#line 1914 "check.cog"
     declRefExp).loc = 

#line 1914 "check.cog"
                      loc;


#line 1915 "check.cog"
               DEREF(

#line 1915 "check.cog"
     declRefExp).declRef = 

#line 1915 "check.cog"
                          declRef;


#line 1916 "check.cog"
               DEREF(

#line 1916 "check.cog"
     declRefExp).type = 

#line 1916 "check.cog"
                                        

#line 1916 "check.cog"
                       getTypeForDeclRef(

#line 1916 "check.cog"
                                         context, 

#line 1916 "check.cog"
                                                  declRef);


#line 1917 "check.cog"
     return 

#line 1917 "check.cog"
            declRefExp;
}


#line 1920 "check.cog"
 

#line 1925 "check.cog"
        Exp createDeclRefExp(

#line 1921 "check.cog"
                       

#line 1921 "check.cog"
           CheckContext

#line 1921 "check.cog"
                       * context, 

#line 1922 "check.cog"
           DeclRefVal declRef, 

#line 1923 "check.cog"
       SourceLoc loc, 

#line 1924 "check.cog"
           Exp baseExp)
{


#line 1928 "check.cog"
     

#line 1928 "check.cog"
     auto decl = 

#line 1928 "check.cog"
                               

#line 1928 "check.cog"
                       DEREF(

#line 1928 "check.cog"
                declRef).getDecl();


#line 1929 "check.cog"
     if(auto specializations = 

#line 1929 "check.cog"
                                                        

#line 1929 "check.cog"
                                     DEREF(

#line 1929 "check.cog"
                              declRef).getSpecializations())
{


#line 1931 "check.cog"
         

#line 1931 "check.cog"
         auto specializedDecl = 

#line 1931 "check.cog"
                                                            

#line 1931 "check.cog"
                                           

#line 1931 "check.cog"
                               createObject<

#line 1931 "check.cog"
                                            SpecializedDecl> ();


#line 1932 "check.cog"
                        DEREF(

#line 1932 "check.cog"
         specializedDecl).decl = 

#line 1932 "check.cog"
                                decl;


#line 1933 "check.cog"
                        DEREF(

#line 1933 "check.cog"
         specializedDecl).specializations = 

#line 1933 "check.cog"
                                           specializations;


#line 1935 "check.cog"
         return 

#line 1935 "check.cog"
                                

#line 1935 "check.cog"
                createDeclRefExp(

#line 1935 "check.cog"
                                 context, 

#line 1935 "check.cog"
                                                        

#line 1935 "check.cog"
                                          CompactDeclRef(

#line 1935 "check.cog"
                                                         specializedDecl), 

#line 1935 "check.cog"
                                                                           loc, 

#line 1935 "check.cog"
                                                                                baseExp);
}
else
{


#line 1939 "check.cog"
         return 

#line 1939 "check.cog"
                                

#line 1939 "check.cog"
                createDeclRefExp(

#line 1939 "check.cog"
                                 context, 

#line 1939 "check.cog"
                                                        

#line 1939 "check.cog"
                                          CompactDeclRef(

#line 1939 "check.cog"
                                                         decl), 

#line 1939 "check.cog"
                                                                loc, 

#line 1939 "check.cog"
                                                                     baseExp);
}
}


#line 1944 "check.cog"
 

#line 1948 "check.cog"
        Exp createDeclRefExp(

#line 1945 "check.cog"
                       

#line 1945 "check.cog"
           CheckContext

#line 1945 "check.cog"
                       * context, 

#line 1946 "check.cog"
           DeclRefVal declRef, 

#line 1947 "check.cog"
       SourceLoc loc)
{


#line 1950 "check.cog"
  return 

#line 1950 "check.cog"
                         

#line 1950 "check.cog"
         createDeclRefExp(

#line 1950 "check.cog"
                          context, 

#line 1950 "check.cog"
                                   declRef, 

#line 1950 "check.cog"
                                            loc, 

#line 1950 "check.cog"
                                                 nullptr);
}


#line 1953 "check.cog"
 

#line 1956 "check.cog"
     Val getGenericArgVal(

#line 1954 "check.cog"
                       

#line 1954 "check.cog"
           CheckContext

#line 1954 "check.cog"
                       * context, 

#line 1955 "check.cog"
        Exp expr)
{


#line 1958 "check.cog"
  

#line 1958 "check.cog"
  auto type = 

#line 1958 "check.cog"
                 DEREF(

#line 1958 "check.cog"
             expr).type;


#line 1959 "check.cog"
  if(auto typeType = 

#line 1959 "check.cog"
                                

#line 1959 "check.cog"
                      

#line 1959 "check.cog"
                    as<

#line 1959 "check.cog"
                       TypeType> (

#line 1959 "check.cog"
                                 type))
{


#line 1961 "check.cog"
   return 

#line 1961 "check.cog"
                  DEREF(

#line 1961 "check.cog"
          typeType).type;
}


#line 1963 "check.cog"
  if(auto errorType = 

#line 1963 "check.cog"
                                  

#line 1963 "check.cog"
                       

#line 1963 "check.cog"
                     as<

#line 1963 "check.cog"
                        ErrorType> (

#line 1963 "check.cog"
                                   type))
{


#line 1965 "check.cog"
   return 

#line 1965 "check.cog"
          errorType;
}


#line 1968 "check.cog"
          

#line 1968 "check.cog"
          

#line 1968 "check.cog"
  diagnose(

#line 1968 "check.cog"
                  

#line 1968 "check.cog"
           getSink(

#line 1968 "check.cog"
                   context), 

#line 1968 "check.cog"
                                 DEREF(

#line 1968 "check.cog"
                             expr).loc, 

#line 1968 "check.cog"
                                       kDiagnostic_unimplemented, 

#line 1968 "check.cog"
                                                                  "generic arg flavor");


#line 1970 "check.cog"
  return 

#line 1970 "check.cog"
                        

#line 1970 "check.cog"
         createErrorType(

#line 1970 "check.cog"
                         context);
}


#line 1973 "check.cog"
 

#line 1976 "check.cog"
     Exp completeOverloadCandidate(

#line 1974 "check.cog"
                                         

#line 1974 "check.cog"
                   OverloadResolveContext

#line 1974 "check.cog"
                                         * overloadContext, 

#line 1975 "check.cog"
                              

#line 1975 "check.cog"
             OverloadCandidate

#line 1975 "check.cog"
                              * candidate)
{


#line 1978 "check.cog"
     

#line 1978 "check.cog"
     auto context = 

#line 1978 "check.cog"
                                  DEREF(

#line 1978 "check.cog"
                   overloadContext).checkContext;


#line 1979 "check.cog"
     

#line 1979 "check.cog"
     auto appExp = 

#line 1979 "check.cog"
                                 DEREF(

#line 1979 "check.cog"
                  overloadContext).appExp;


#line 1980 "check.cog"
  

#line 1980 "check.cog"
  auto loc = 

#line 1980 "check.cog"
                  DEREF(

#line 1980 "check.cog"
            appExp).loc;


#line 1981 "check.cog"
  if(auto funcDeclRef = 

#line 1981 "check.cog"
                                       

#line 1981 "check.cog"
                         

#line 1981 "check.cog"
                       as<

#line 1981 "check.cog"
                          FuncDeclBase> (

#line 1981 "check.cog"
                                                 DEREF(

#line 1981 "check.cog"
                                        candidate).declRef))
{


#line 1983 "check.cog"
   

#line 1983 "check.cog"
   auto baseExp = 

#line 1983 "check.cog"
                                 

#line 1983 "check.cog"
                 createDeclRefExp(

#line 1984 "check.cog"
    context, 

#line 1985 "check.cog"
    funcDeclRef, 

#line 1986 "check.cog"
          DEREF(

#line 1986 "check.cog"
    appExp).loc, 

#line 1987 "check.cog"
                   DEREF(

#line 1987 "check.cog"
    overloadContext).baseExp);


#line 1989 "check.cog"
         DEREF(

#line 1989 "check.cog"
   appExp).base = 

#line 1989 "check.cog"
                 baseExp;


#line 1990 "check.cog"
         DEREF(

#line 1990 "check.cog"
   appExp).type = 

#line 1990 "check.cog"
                          DEREF(

#line 1990 "check.cog"
                 candidate).resultType;


#line 1991 "check.cog"
   return 

#line 1991 "check.cog"
          appExp;
}
else
{


#line 1993 "check.cog"
       if(auto genericDeclRef = 

#line 1993 "check.cog"
                                              

#line 1993 "check.cog"
                                 

#line 1993 "check.cog"
                               as<

#line 1993 "check.cog"
                                  GenericDecl> (

#line 1993 "check.cog"
                                                        DEREF(

#line 1993 "check.cog"
                                               candidate).declRef))
{


#line 1996 "check.cog"
   

#line 1996 "check.cog"
   auto innerDecl = 

#line 1996 "check.cog"
                                           DEREF(

#line 1996 "check.cog"
                                         

#line 1996 "check.cog"
                                 DEREF(

#line 1996 "check.cog"
                   genericDeclRef).getDecl()).inner;


#line 1997 "check.cog"
   

#line 1997 "check.cog"
   auto specializations = 

#line 1997 "check.cog"
                                                      

#line 1997 "check.cog"
                                     

#line 1997 "check.cog"
                         createObject<

#line 1997 "check.cog"
                                      Specializations> ();


#line 1998 "check.cog"
                  DEREF(

#line 1998 "check.cog"
   specializations).genericDeclRef = 

#line 1998 "check.cog"
                                    genericDeclRef;


#line 2000 "check.cog"
   

#line 2000 "check.cog"
   auto argCursor = 

#line 2000 "check.cog"
                                    

#line 2000 "check.cog"
                              DEREF(

#line 2000 "check.cog"
                         DEREF(

#line 2000 "check.cog"
                   appExp).args).begin();


#line 2002 "check.cog"
   for(auto dd : 

#line 2002 "check.cog"
                         

#line 2002 "check.cog"
                 getDecls(

#line 2002 "check.cog"
                          genericDeclRef))
{
{


#line 2004 "check.cog"
    if(auto paramDeclRef = 

#line 2004 "check.cog"
                                              

#line 2004 "check.cog"
                            

#line 2004 "check.cog"
                          as<

#line 2004 "check.cog"
                             GenericParamDecl> (

#line 2004 "check.cog"
                                               dd))
{


#line 2006 "check.cog"
     

#line 2006 "check.cog"
     auto arg = 

#line 2006 "check.cog"
               

#line 2006 "check.cog"
               *

#line 2006 "check.cog"
                argCursor;


#line 2007 "check.cog"
     

#line 2007 "check.cog"
     

#line 2007 "check.cog"
     ++

#line 2007 "check.cog"
       argCursor;


#line 2009 "check.cog"
     

#line 2009 "check.cog"
     auto specializationArg = 

#line 2009 "check.cog"
                                                            

#line 2009 "check.cog"
                                         

#line 2009 "check.cog"
                             createObject<

#line 2009 "check.cog"
                                          SpecializationArg> ();


#line 2010 "check.cog"
                      DEREF(

#line 2010 "check.cog"
     specializationArg).param = 

#line 2010 "check.cog"
                                                   

#line 2010 "check.cog"
                                           DEREF(

#line 2010 "check.cog"
                               paramDeclRef).getDecl();


#line 2011 "check.cog"
                      DEREF(

#line 2011 "check.cog"
     specializationArg).value = 

#line 2011 "check.cog"
                                               

#line 2011 "check.cog"
                               getGenericArgVal(

#line 2011 "check.cog"
                                                context, 

#line 2011 "check.cog"
                                                            DEREF(

#line 2011 "check.cog"
                                                         arg).exp);


#line 2013 "check.cog"
                                

#line 2013 "check.cog"
                                

#line 2013 "check.cog"
                         DEREF(

#line 2013 "check.cog"
                    DEREF(

#line 2013 "check.cog"
     specializations).args).append(

#line 2013 "check.cog"
                                 specializationArg);
}
}
}


#line 2017 "check.cog"
   

#line 2017 "check.cog"
   auto innerDeclRef = 

#line 2017 "check.cog"
                                

#line 2017 "check.cog"
                      DeclRefVal(

#line 2017 "check.cog"
                                 innerDecl, 

#line 2017 "check.cog"
                                            specializations);


#line 2018 "check.cog"
   return 

#line 2018 "check.cog"
                          

#line 2018 "check.cog"
          createDeclRefExp(

#line 2019 "check.cog"
    context, 

#line 2020 "check.cog"
    innerDeclRef, 

#line 2021 "check.cog"
          DEREF(

#line 2021 "check.cog"
    appExp).loc, 

#line 2022 "check.cog"
                   DEREF(

#line 2022 "check.cog"
    overloadContext).baseExp);
}
else
{


#line 2026 "check.cog"
           

#line 2026 "check.cog"
           

#line 2026 "check.cog"
   diagnose(

#line 2026 "check.cog"
                   

#line 2026 "check.cog"
            getSink(

#line 2026 "check.cog"
                    context), 

#line 2026 "check.cog"
                              loc, 

#line 2026 "check.cog"
                                   kDiagnostic_unimplemented, 

#line 2026 "check.cog"
                                                              "overload candidate flavor");
}
}
}


#line 2030 "check.cog"
 

#line 2032 "check.cog"
        Exp completeOverload(

#line 2031 "check.cog"
                                            

#line 2031 "check.cog"
                      OverloadResolveContext

#line 2031 "check.cog"
                                            * overloadContext)
{


#line 2034 "check.cog"
     

#line 2034 "check.cog"
     auto context = 

#line 2034 "check.cog"
                                  DEREF(

#line 2034 "check.cog"
                   overloadContext).checkContext;


#line 2035 "check.cog"
     

#line 2035 "check.cog"
     auto appExp = 

#line 2035 "check.cog"
                                 DEREF(

#line 2035 "check.cog"
                  overloadContext).appExp;


#line 2037 "check.cog"
     

#line 2037 "check.cog"
     auto count = 

#line 2037 "check.cog"
                                                    

#line 2037 "check.cog"
                                           DEREF(

#line 2037 "check.cog"
                                DEREF(

#line 2037 "check.cog"
                 overloadContext).candidates).getCount();


#line 2039 "check.cog"
     

#line 2039 "check.cog"
     

#line 2039 "check.cog"
                        

#line 2039 "check.cog"
                    Name

#line 2039 "check.cog"
                        * baseName = 

#line 2039 "check.cog"
                            nullptr;


#line 2040 "check.cog"
     if(auto declRefExp = 

#line 2040 "check.cog"
                                       

#line 2040 "check.cog"
                           

#line 2040 "check.cog"
                         as<

#line 2040 "check.cog"
                            DeclRefExp> (

#line 2040 "check.cog"
                                              DEREF(

#line 2040 "check.cog"
                                        appExp).base))
{


#line 2042 "check.cog"
         baseName = 

#line 2042 "check.cog"
                                                DEREF(

#line 2042 "check.cog"
                                              

#line 2042 "check.cog"
                                      DEREF(

#line 2042 "check.cog"
                              DEREF(

#line 2042 "check.cog"
                    declRefExp).declRef).getDecl()).name;
}
else
{


#line 2044 "check.cog"
          if(auto nameExp = 

#line 2044 "check.cog"
                                      

#line 2044 "check.cog"
                             

#line 2044 "check.cog"
                           as<

#line 2044 "check.cog"
                              NameExp> (

#line 2044 "check.cog"
                                             DEREF(

#line 2044 "check.cog"
                                       appExp).base))
{


#line 2046 "check.cog"
         baseName = 

#line 2046 "check.cog"
                           DEREF(

#line 2046 "check.cog"
                    nameExp).name;
}
else
{


#line 2048 "check.cog"
          if(auto overloadedExpr = 

#line 2048 "check.cog"
                                                    

#line 2048 "check.cog"
                                    

#line 2048 "check.cog"
                                  as<

#line 2048 "check.cog"
                                     OverloadedExpr> (

#line 2048 "check.cog"
                                                           DEREF(

#line 2048 "check.cog"
                                                     appExp).base))
{


#line 2050 "check.cog"
         baseName = 

#line 2050 "check.cog"
                                                             DEREF(

#line 2050 "check.cog"
                                                        DEREF(

#line 2050 "check.cog"
                                                     

#line 2050 "check.cog"
                                               DEREF(

#line 2050 "check.cog"
                                  DEREF(

#line 2050 "check.cog"
                    overloadedExpr).lookupResult).items[

#line 2050 "check.cog"
                                                      0]).decl).name;
}
}
}


#line 2053 "check.cog"
     if(

#line 2053 "check.cog"
              

#line 2053 "check.cog"
        count 

#line 2053 "check.cog"
              == 

#line 2053 "check.cog"
                 1)
{


#line 2057 "check.cog"
         

#line 2057 "check.cog"
         auto candidate = 

#line 2057 "check.cog"
                         

#line 2057 "check.cog"
                         &

#line 2057 "check.cog"
                                                    

#line 2057 "check.cog"
                                         DEREF(

#line 2057 "check.cog"
                          overloadContext).candidates[

#line 2057 "check.cog"
                                                     0];


#line 2058 "check.cog"
         if(

#line 2058 "check.cog"
                            

#line 2058 "check.cog"
                     DEREF(

#line 2058 "check.cog"
            candidate).state 

#line 2058 "check.cog"
                            == 

#line 2058 "check.cog"
                               kOverloadCandidateState_Applicable)
{


#line 2060 "check.cog"
    return 

#line 2060 "check.cog"
                                    

#line 2060 "check.cog"
           completeOverloadCandidate(

#line 2060 "check.cog"
                                     overloadContext, 

#line 2060 "check.cog"
                                                      candidate);
}
else
{


#line 2066 "check.cog"
                            DEREF(

#line 2066 "check.cog"
             overloadContext).mode = 

#line 2066 "check.cog"
                                    kOverloadResolveMode_forReal;


#line 2067 "check.cog"
                                   

#line 2067 "check.cog"
                                   

#line 2067 "check.cog"
             checkOverloadCandidate(

#line 2068 "check.cog"
                 overloadContext, 

#line 2069 "check.cog"
                 

#line 2069 "check.cog"
                 *

#line 2069 "check.cog"
                  candidate);


#line 2070 "check.cog"
             return 

#line 2070 "check.cog"
                                  

#line 2070 "check.cog"
                    createErrorExp(

#line 2070 "check.cog"
                                   context, 

#line 2070 "check.cog"
                                                  DEREF(

#line 2070 "check.cog"
                                            appExp).loc);
}
}
else
{


#line 2073 "check.cog"
          if(

#line 2073 "check.cog"
                   

#line 2073 "check.cog"
             count 

#line 2073 "check.cog"
                   == 

#line 2073 "check.cog"
                      0)
{


#line 2076 "check.cog"
                 

#line 2076 "check.cog"
                 

#line 2076 "check.cog"
         diagnose(

#line 2076 "check.cog"
                         

#line 2076 "check.cog"
                  getSink(

#line 2076 "check.cog"
                          context), 

#line 2076 "check.cog"
                                          DEREF(

#line 2076 "check.cog"
                                    appExp).loc, 

#line 2076 "check.cog"
                                                kDiagnostic_noOverloadCandidatesFound, 

#line 2076 "check.cog"
                                                                                       baseName);


#line 2078 "check.cog"
         if(auto overloadedExpr = 

#line 2078 "check.cog"
                                                   

#line 2078 "check.cog"
                                   

#line 2078 "check.cog"
                                 as<

#line 2078 "check.cog"
                                    OverloadedExpr> (

#line 2078 "check.cog"
                                                          DEREF(

#line 2078 "check.cog"
                                                    appExp).base))
{


#line 2080 "check.cog"
             for(auto item : 

#line 2080 "check.cog"
                                            DEREF(

#line 2080 "check.cog"
                              overloadedExpr).lookupResult)
{
{


#line 2082 "check.cog"
                         

#line 2082 "check.cog"
                         

#line 2082 "check.cog"
                 diagnose(

#line 2082 "check.cog"
                                 

#line 2082 "check.cog"
                          getSink(

#line 2082 "check.cog"
                                  context), 

#line 2082 "check.cog"
                                                     DEREF(

#line 2082 "check.cog"
                                                DEREF(

#line 2082 "check.cog"
                                            item).decl).loc, 

#line 2082 "check.cog"
                                                           kDiagnostic_candidate, 

#line 2082 "check.cog"
                                                                                            

#line 2082 "check.cog"
                                                                                  DeclRefVal(

#line 2082 "check.cog"
                                                                                                 DEREF(

#line 2082 "check.cog"
                                                                                             item).decl));
}
}
}


#line 2086 "check.cog"
         return 

#line 2086 "check.cog"
                              

#line 2086 "check.cog"
                createErrorExp(

#line 2086 "check.cog"
                               context, 

#line 2086 "check.cog"
                                              DEREF(

#line 2086 "check.cog"
                                        appExp).loc);
}
else
{


#line 2091 "check.cog"
         if(

#line 2091 "check.cog"
                                                

#line 2091 "check.cog"
                                         DEREF(

#line 2091 "check.cog"
                                      

#line 2091 "check.cog"
                           DEREF(

#line 2091 "check.cog"
            overloadContext).candidates[

#line 2091 "check.cog"
                                       0]).state 

#line 2091 "check.cog"
                                                == 

#line 2091 "check.cog"
                                                   kOverloadCandidateState_Applicable)
{


#line 2094 "check.cog"
                     

#line 2094 "check.cog"
                     

#line 2094 "check.cog"
             diagnose(

#line 2094 "check.cog"
                             

#line 2094 "check.cog"
                      getSink(

#line 2094 "check.cog"
                              context), 

#line 2094 "check.cog"
                                              DEREF(

#line 2094 "check.cog"
                                        appExp).loc, 

#line 2094 "check.cog"
                                                    kDiagnostic_ambiguousCallToOverload, 

#line 2094 "check.cog"
                                                                                         baseName, 

#line 2094 "check.cog"
                                                                                                              

#line 2094 "check.cog"
                                                                                                   ArgTypeList(

#line 2094 "check.cog"
                                                                                                                     DEREF(

#line 2094 "check.cog"
                                                                                                               appExp).args));


#line 2096 "check.cog"
             for(auto cc : 

#line 2096 "check.cog"
                                           DEREF(

#line 2096 "check.cog"
                            overloadContext).candidates)
{
{


#line 2098 "check.cog"
                         

#line 2098 "check.cog"
                         

#line 2098 "check.cog"
                 diagnose(

#line 2098 "check.cog"
                                 

#line 2098 "check.cog"
                          getSink(

#line 2098 "check.cog"
                                  context), 

#line 2098 "check.cog"
                                                                DEREF(

#line 2098 "check.cog"
                                                              

#line 2098 "check.cog"
                                                      DEREF(

#line 2098 "check.cog"
                                              DEREF(

#line 2098 "check.cog"
                                            cc).declRef).getDecl()).loc, 

#line 2098 "check.cog"
                                                                      kDiagnostic_candidate, 

#line 2098 "check.cog"
                                                                                               DEREF(

#line 2098 "check.cog"
                                                                                             cc).declRef);
}
}


#line 2101 "check.cog"
             return 

#line 2101 "check.cog"
                                  

#line 2101 "check.cog"
                    createErrorExp(

#line 2101 "check.cog"
                                   context, 

#line 2101 "check.cog"
                                                  DEREF(

#line 2101 "check.cog"
                                            appExp).loc);
}
else
{


#line 2106 "check.cog"
                     

#line 2106 "check.cog"
                     

#line 2106 "check.cog"
             diagnose(

#line 2106 "check.cog"
                             

#line 2106 "check.cog"
                      getSink(

#line 2106 "check.cog"
                              context), 

#line 2106 "check.cog"
                                              DEREF(

#line 2106 "check.cog"
                                        appExp).loc, 

#line 2106 "check.cog"
                                                    kDiagnostic_noApplicableOverloadForCall, 

#line 2106 "check.cog"
                                                                                             baseName, 

#line 2106 "check.cog"
                                                                                                                  

#line 2106 "check.cog"
                                                                                                       ArgTypeList(

#line 2106 "check.cog"
                                                                                                                         DEREF(

#line 2106 "check.cog"
                                                                                                                   appExp).args));


#line 2108 "check.cog"
             for(auto cc : 

#line 2108 "check.cog"
                                          DEREF(

#line 2108 "check.cog"
                           overloadContext).candidates)
{
{


#line 2110 "check.cog"
                         

#line 2110 "check.cog"
                         

#line 2110 "check.cog"
                 diagnose(

#line 2110 "check.cog"
                                 

#line 2110 "check.cog"
                          getSink(

#line 2110 "check.cog"
                                  context), 

#line 2110 "check.cog"
                                                                DEREF(

#line 2110 "check.cog"
                                                              

#line 2110 "check.cog"
                                                      DEREF(

#line 2110 "check.cog"
                                              DEREF(

#line 2110 "check.cog"
                                            cc).declRef).getDecl()).loc, 

#line 2110 "check.cog"
                                                                      kDiagnostic_candidate, 

#line 2110 "check.cog"
                                                                                               DEREF(

#line 2110 "check.cog"
                                                                                             cc).declRef);
}
}


#line 2113 "check.cog"
             return 

#line 2113 "check.cog"
                                  

#line 2113 "check.cog"
                    createErrorExp(

#line 2113 "check.cog"
                                   context, 

#line 2113 "check.cog"
                                                  DEREF(

#line 2113 "check.cog"
                                            appExp).loc);
}
}
}
}


#line 2118 "check.cog"
 

#line 2120 "check.cog"
        Bool isError(

#line 2119 "check.cog"
        Type type)
{


#line 2122 "check.cog"
     return 

#line 2122 "check.cog"
                                

#line 2122 "check.cog"
                         

#line 2122 "check.cog"
              

#line 2122 "check.cog"
            as<

#line 2122 "check.cog"
               ErrorType> (

#line 2122 "check.cog"
                          type) 

#line 2122 "check.cog"
                                != 

#line 2122 "check.cog"
                                   nullptr;
}


#line 2125 "check.cog"
 

#line 2128 "check.cog"
        Bool isError(

#line 2126 "check.cog"
                       

#line 2126 "check.cog"
           CheckContext

#line 2126 "check.cog"
                       * context, 

#line 2127 "check.cog"
       Exp exp)
{


#line 2130 "check.cog"
     return 

#line 2130 "check.cog"
                              

#line 2130 "check.cog"
                        

#line 2130 "check.cog"
              

#line 2130 "check.cog"
            as<

#line 2130 "check.cog"
               ErrorExp> (

#line 2130 "check.cog"
                         exp) 

#line 2130 "check.cog"
                              || 

#line 2130 "check.cog"
                                        

#line 2130 "check.cog"
                                 isError(

#line 2130 "check.cog"
                                            DEREF(

#line 2130 "check.cog"
                                         exp).type);
}


#line 2133 "check.cog"
 void addTypeOverloadCandidates(

#line 2134 "check.cog"
                                 

#line 2134 "check.cog"
           OverloadResolveContext

#line 2134 "check.cog"
                                 * context, 

#line 2135 "check.cog"
           Exp typeExp, 

#line 2136 "check.cog"
        Type type)
{


#line 2138 "check.cog"
     if(auto declRefType = 

#line 2138 "check.cog"
                                         

#line 2138 "check.cog"
                            

#line 2138 "check.cog"
                          as<

#line 2138 "check.cog"
                             DeclRefType> (

#line 2138 "check.cog"
                                          type))
{


#line 2140 "check.cog"
         if(auto aggTypeDeclRef = 

#line 2140 "check.cog"
                                                

#line 2140 "check.cog"
                                   

#line 2140 "check.cog"
                                 as<

#line 2140 "check.cog"
                                    AggTypeDecl> (

#line 2140 "check.cog"
                                                            DEREF(

#line 2140 "check.cog"
                                                 declRefType).declRef))
{


#line 2144 "check.cog"
             for(auto memberDeclRef : 

#line 2144 "check.cog"
                                               

#line 2144 "check.cog"
                                       getDecls(

#line 2144 "check.cog"
                                                aggTypeDeclRef))
{
{


#line 2146 "check.cog"
                 if(auto initializerDeclRef = 

#line 2146 "check.cog"
                                                                

#line 2146 "check.cog"
                                               

#line 2146 "check.cog"
                                             as<

#line 2146 "check.cog"
                                                InitializerDecl> (

#line 2146 "check.cog"
                                                                 memberDeclRef))
{


#line 2148 "check.cog"
                                                    

#line 2148 "check.cog"
                                                    

#line 2148 "check.cog"
                     addInitializerOverloadCandidate(

#line 2148 "check.cog"
                                                     context, 

#line 2148 "check.cog"
                                                              type, 

#line 2148 "check.cog"
                                                                    initializerDeclRef);
}
}
}
}
}
}


#line 2156 "check.cog"
 

#line 2162 "check.cog"
 

#line 2169 "check.cog"
 

#line 2173 "check.cog"
        Bool doInferenceForVals(

#line 2170 "check.cog"
                                  

#line 2170 "check.cog"
           GenericInferenceContext

#line 2170 "check.cog"
                                  * context, 

#line 2171 "check.cog"
          Val argVal, 

#line 2172 "check.cog"
            Val paramVal)
{


#line 2175 "check.cog"
     if(auto argType = 

#line 2175 "check.cog"
                              

#line 2175 "check.cog"
                        

#line 2175 "check.cog"
                      as<

#line 2175 "check.cog"
                         Type> (

#line 2175 "check.cog"
                               argVal))
{


#line 2177 "check.cog"
         if(auto paramType = 

#line 2177 "check.cog"
                                    

#line 2177 "check.cog"
                              

#line 2177 "check.cog"
                            as<

#line 2177 "check.cog"
                               Type> (

#line 2177 "check.cog"
                                     paramVal))
{


#line 2179 "check.cog"
             return 

#line 2179 "check.cog"
                                       

#line 2179 "check.cog"
                    doInferenceForTypes(

#line 2179 "check.cog"
                                        context, 

#line 2179 "check.cog"
                                                 argType, 

#line 2179 "check.cog"
                                                          paramType);
}
}


#line 2184 "check.cog"
     return 

#line 2184 "check.cog"
            false;
}


#line 2187 "check.cog"
 

#line 2191 "check.cog"
        Bool doInferenceForSpecializations(

#line 2188 "check.cog"
                                  

#line 2188 "check.cog"
           GenericInferenceContext

#line 2188 "check.cog"
                                  * context, 

#line 2189 "check.cog"
              Specializations argSpec, 

#line 2190 "check.cog"
                Specializations paramSpec)
{


#line 2194 "check.cog"
     if(

#line 2194 "check.cog"
                 

#line 2194 "check.cog"
        

#line 2194 "check.cog"
        !

#line 2194 "check.cog"
         argSpec 

#line 2194 "check.cog"
                 || 

#line 2194 "check.cog"
                    

#line 2194 "check.cog"
                    !

#line 2194 "check.cog"
                     paramSpec)
{


#line 2196 "check.cog"
      return 

#line 2196 "check.cog"
                     

#line 2196 "check.cog"
             argSpec 

#line 2196 "check.cog"
                     == 

#line 2196 "check.cog"
                        paramSpec;
}


#line 2200 "check.cog"
     if(

#line 2200 "check.cog"
        

#line 2200 "check.cog"
        !

#line 2200 "check.cog"
                               

#line 2200 "check.cog"
         doInferenceForDeclRefs(

#line 2201 "check.cog"
         context, 

#line 2202 "check.cog"
                DEREF(

#line 2202 "check.cog"
         argSpec).genericDeclRef, 

#line 2203 "check.cog"
                  DEREF(

#line 2203 "check.cog"
         paramSpec).genericDeclRef))
{


#line 2205 "check.cog"
         return 

#line 2205 "check.cog"
                false;
}


#line 2209 "check.cog"
     

#line 2209 "check.cog"
     auto aa = 

#line 2209 "check.cog"
                                

#line 2209 "check.cog"
                          DEREF(

#line 2209 "check.cog"
                     DEREF(

#line 2209 "check.cog"
              argSpec).args).begin();


#line 2210 "check.cog"
  

#line 2210 "check.cog"
  auto ae = 

#line 2210 "check.cog"
                           

#line 2210 "check.cog"
                       DEREF(

#line 2210 "check.cog"
                  DEREF(

#line 2210 "check.cog"
           argSpec).args).end();


#line 2212 "check.cog"
     

#line 2212 "check.cog"
     auto pp = 

#line 2212 "check.cog"
                                  

#line 2212 "check.cog"
                            DEREF(

#line 2212 "check.cog"
                       DEREF(

#line 2212 "check.cog"
              paramSpec).args).begin();


#line 2213 "check.cog"
     while(

#line 2213 "check.cog"
              

#line 2213 "check.cog"
           aa 

#line 2213 "check.cog"
              != 

#line 2213 "check.cog"
                 ae)
{
{


#line 2215 "check.cog"
         if(

#line 2215 "check.cog"
            

#line 2215 "check.cog"
            !

#line 2215 "check.cog"
                               

#line 2215 "check.cog"
             doInferenceForVals(

#line 2215 "check.cog"
                                context, 

#line 2215 "check.cog"
                                              DEREF(

#line 2215 "check.cog"
                                         (

#line 2215 "check.cog"
                                          

#line 2215 "check.cog"
                                          *

#line 2215 "check.cog"
                                           aa)).value, 

#line 2215 "check.cog"
                                                           DEREF(

#line 2215 "check.cog"
                                                      (

#line 2215 "check.cog"
                                                       

#line 2215 "check.cog"
                                                       *

#line 2215 "check.cog"
                                                        pp)).value))
{


#line 2216 "check.cog"
             return 

#line 2216 "check.cog"
                    false;
}


#line 2218 "check.cog"
   

#line 2218 "check.cog"
   

#line 2218 "check.cog"
   ++

#line 2218 "check.cog"
     aa;


#line 2219 "check.cog"
   

#line 2219 "check.cog"
   

#line 2219 "check.cog"
   ++

#line 2219 "check.cog"
     pp;
}
}


#line 2222 "check.cog"
     return 

#line 2222 "check.cog"
            true;
}


#line 2225 "check.cog"
 

#line 2229 "check.cog"
        Bool doInferenceForDeclRefs(

#line 2226 "check.cog"
                                    

#line 2226 "check.cog"
             GenericInferenceContext

#line 2226 "check.cog"
                                    * context, 

#line 2227 "check.cog"
                  DeclRefVal argDeclRef, 

#line 2228 "check.cog"
                    DeclRefVal paramDeclRef)
{


#line 2232 "check.cog"
     if(

#line 2233 "check.cog"
         

#line 2232 "check.cog"
                            

#line 2232 "check.cog"
                    DEREF(

#line 2232 "check.cog"
        paramDeclRef).getDecl() 

#line 2233 "check.cog"
         != 

#line 2233 "check.cog"
                              

#line 2233 "check.cog"
                      DEREF(

#line 2233 "check.cog"
            argDeclRef).getDecl())
{


#line 2235 "check.cog"
         return 

#line 2235 "check.cog"
                false;
}


#line 2240 "check.cog"
     return 

#line 2240 "check.cog"
                                         

#line 2240 "check.cog"
            doInferenceForSpecializations(

#line 2241 "check.cog"
         context, 

#line 2242 "check.cog"
                   DEREF(

#line 2242 "check.cog"
         argDeclRef).specializations, 

#line 2243 "check.cog"
                     DEREF(

#line 2243 "check.cog"
         paramDeclRef).specializations);
}


#line 2246 "check.cog"
 

#line 2249 "check.cog"
                        

#line 2249 "check.cog"
     GenericInferenceArg

#line 2249 "check.cog"
                        * findGenericInferenceArg(

#line 2247 "check.cog"
                                  

#line 2247 "check.cog"
           GenericInferenceContext

#line 2247 "check.cog"
                                  * context, 

#line 2248 "check.cog"
                              

#line 2248 "check.cog"
                DeclRefValImpl<

#line 2248 "check.cog"
                               GenericParamDecl>  paramDeclRef)
{


#line 2251 "check.cog"
  {


#line 2251 "check.cog"
      

#line 2251 "check.cog"
      

#line 2251 "check.cog"
               Int ii = 

#line 2251 "check.cog"
                     0;
for(;

#line 2251 "check.cog"
                           

#line 2251 "check.cog"
                        ii 

#line 2251 "check.cog"
                           < 

#line 2251 "check.cog"
                                    DEREF(

#line 2251 "check.cog"
                             context).argCount;

#line 2251 "check.cog"
                                               

#line 2251 "check.cog"
                                               ++

#line 2251 "check.cog"
                                                 ii)
{
{


#line 2253 "check.cog"
   if(

#line 2253 "check.cog"
                   

#line 2253 "check.cog"
      isSameDeclRef(

#line 2253 "check.cog"
                                    DEREF(

#line 2253 "check.cog"
                                

#line 2253 "check.cog"
                           DEREF(

#line 2253 "check.cog"
                    context).args[

#line 2253 "check.cog"
                                 ii]).paramDeclRef, 

#line 2253 "check.cog"
                                                   paramDeclRef))
{


#line 2254 "check.cog"
    return 

#line 2254 "check.cog"
           

#line 2254 "check.cog"
           &

#line 2254 "check.cog"
                        

#line 2254 "check.cog"
                   DEREF(

#line 2254 "check.cog"
            context).args[

#line 2254 "check.cog"
                         ii];
}
}
}}


#line 2256 "check.cog"
  return 

#line 2256 "check.cog"
         nullptr;
}


#line 2259 "check.cog"
 

#line 2263 "check.cog"
        Bool doInferenceForTypes(

#line 2260 "check.cog"
                                     

#line 2260 "check.cog"
              GenericInferenceContext

#line 2260 "check.cog"
                                     * context, 

#line 2261 "check.cog"
              Type argType, 

#line 2262 "check.cog"
                Type paramType)
{


#line 2266 "check.cog"
     if(

#line 2266 "check.cog"
                  

#line 2266 "check.cog"
        isSameType(

#line 2266 "check.cog"
                   argType, 

#line 2266 "check.cog"
                            paramType))
{


#line 2267 "check.cog"
         return 

#line 2267 "check.cog"
                true;
}


#line 2269 "check.cog"
     if(auto paramDeclRefType = 

#line 2269 "check.cog"
                                              

#line 2269 "check.cog"
                                 

#line 2269 "check.cog"
                               as<

#line 2269 "check.cog"
                                  DeclRefType> (

#line 2269 "check.cog"
                                               paramType))
{


#line 2271 "check.cog"
         if(auto genericParamDeclRef = 

#line 2271 "check.cog"
                                                          

#line 2271 "check.cog"
                                        

#line 2271 "check.cog"
                                      as<

#line 2271 "check.cog"
                                         GenericParamDecl> (

#line 2271 "check.cog"
                                                                           DEREF(

#line 2271 "check.cog"
                                                           paramDeclRefType).declRef))
{


#line 2279 "check.cog"
    

#line 2279 "check.cog"
    auto genericInferenceArg = 

#line 2279 "check.cog"
                                                     

#line 2279 "check.cog"
                              findGenericInferenceArg(

#line 2279 "check.cog"
                                                      context, 

#line 2279 "check.cog"
                                                               genericParamDeclRef);


#line 2280 "check.cog"
    if(

#line 2280 "check.cog"
       genericInferenceArg)
{


#line 2283 "check.cog"
                        DEREF(

#line 2283 "check.cog"
     genericInferenceArg).val = 

#line 2283 "check.cog"
                               argType;


#line 2284 "check.cog"
     return 

#line 2284 "check.cog"
            true;
}
}


#line 2290 "check.cog"
         if(auto argDeclRefType = 

#line 2290 "check.cog"
                                                

#line 2290 "check.cog"
                                   

#line 2290 "check.cog"
                                 as<

#line 2290 "check.cog"
                                    DeclRefType> (

#line 2290 "check.cog"
                                                 argType))
{


#line 2292 "check.cog"
             return 

#line 2292 "check.cog"
                                          

#line 2292 "check.cog"
                    doInferenceForDeclRefs(

#line 2293 "check.cog"
                 context, 

#line 2294 "check.cog"
                               DEREF(

#line 2294 "check.cog"
                 argDeclRefType).declRef, 

#line 2295 "check.cog"
                                 DEREF(

#line 2295 "check.cog"
                 paramDeclRefType).declRef);
}
}


#line 2300 "check.cog"
     return 

#line 2300 "check.cog"
            false;
}


#line 2304 "check.cog"
 

#line 2308 "check.cog"
        Bool doInferenceForArgAndParam(

#line 2305 "check.cog"
                                     

#line 2305 "check.cog"
              GenericInferenceContext

#line 2305 "check.cog"
                                     * context, 

#line 2306 "check.cog"
              Exp argExpr, 

#line 2307 "check.cog"
                                 

#line 2307 "check.cog"
                   DeclRefValImpl<

#line 2307 "check.cog"
                                  ParamDecl>  paramDeclRef)
{


#line 2310 "check.cog"
     return 

#line 2310 "check.cog"
                               

#line 2310 "check.cog"
            doInferenceForTypes(

#line 2311 "check.cog"
         context, 

#line 2312 "check.cog"
                DEREF(

#line 2312 "check.cog"
         argExpr).type, 

#line 2313 "check.cog"
                

#line 2313 "check.cog"
         getType(

#line 2313 "check.cog"
                 paramDeclRef));
}


#line 2316 "check.cog"
 

#line 2320 "check.cog"
        Specializations inferGenericArgsForApp(

#line 2317 "check.cog"
                          

#line 2317 "check.cog"
              CheckContext

#line 2317 "check.cog"
                          * context, 

#line 2318 "check.cog"
                                   

#line 2318 "check.cog"
                     DeclRefValImpl<

#line 2318 "check.cog"
                                    GenericDecl>  genericDeclRef, 

#line 2319 "check.cog"
              AppExpBase appExpr)
{


#line 2329 "check.cog"
     

#line 2329 "check.cog"
     auto innerDeclRef = 

#line 2329 "check.cog"
                                

#line 2329 "check.cog"
                        getInner(

#line 2329 "check.cog"
                                 genericDeclRef);


#line 2330 "check.cog"
     

#line 2330 "check.cog"
     auto innerFuncDeclRef = 

#line 2330 "check.cog"
                                            

#line 2330 "check.cog"
                              

#line 2330 "check.cog"
                            as<

#line 2330 "check.cog"
                               FuncDeclBase> (

#line 2330 "check.cog"
                                             innerDeclRef);


#line 2331 "check.cog"
     if(

#line 2331 "check.cog"
        

#line 2331 "check.cog"
        !

#line 2331 "check.cog"
         innerFuncDeclRef)
{


#line 2334 "check.cog"
         return 

#line 2334 "check.cog"
                nullptr;
}


#line 2338 "check.cog"
     

#line 2338 "check.cog"
     

#line 2338 "check.cog"
                    

#line 2338 "check.cog"
               Array<

#line 2338 "check.cog"
                     GenericInferenceArg>  args;


#line 2339 "check.cog"
     for(auto member : 

#line 2339 "check.cog"
                                

#line 2339 "check.cog"
                        getDecls(

#line 2339 "check.cog"
                                 genericDeclRef))
{
{


#line 2341 "check.cog"
         if(auto genericParamDeclRef = 

#line 2341 "check.cog"
                                                          

#line 2341 "check.cog"
                                        

#line 2341 "check.cog"
                                      as<

#line 2341 "check.cog"
                                         GenericParamDecl> (

#line 2341 "check.cog"
                                                           member))
{


#line 2343 "check.cog"
             

#line 2343 "check.cog"
             

#line 2343 "check.cog"
                      GenericInferenceArg arg;


#line 2344 "check.cog"
                DEREF(

#line 2344 "check.cog"
             arg).paramDeclRef = 

#line 2344 "check.cog"
                                genericParamDeclRef;


#line 2346 "check.cog"
                        

#line 2346 "check.cog"
                        

#line 2346 "check.cog"
                 DEREF(

#line 2346 "check.cog"
             args).append(

#line 2346 "check.cog"
                         arg);
}
else
{
}
}
}


#line 2354 "check.cog"
     

#line 2354 "check.cog"
     

#line 2354 "check.cog"
                            GenericInferenceContext inferenceContext;


#line 2355 "check.cog"
                     DEREF(

#line 2355 "check.cog"
     inferenceContext).checkContext = 

#line 2355 "check.cog"
                                     context;


#line 2356 "check.cog"
                     DEREF(

#line 2356 "check.cog"
     inferenceContext).args = 

#line 2356 "check.cog"
                             

#line 2356 "check.cog"
                             &

#line 2356 "check.cog"
                                  

#line 2356 "check.cog"
                              args[

#line 2356 "check.cog"
                                   0];


#line 2357 "check.cog"
                  DEREF(

#line 2357 "check.cog"
  inferenceContext).argCount = 

#line 2357 "check.cog"
                                           

#line 2357 "check.cog"
                                  DEREF(

#line 2357 "check.cog"
                              args).getCount();


#line 2359 "check.cog"
     

#line 2359 "check.cog"
     auto aa = 

#line 2359 "check.cog"
                                

#line 2359 "check.cog"
                          DEREF(

#line 2359 "check.cog"
                     DEREF(

#line 2359 "check.cog"
              appExpr).args).begin();


#line 2360 "check.cog"
     

#line 2360 "check.cog"
     auto ae = 

#line 2360 "check.cog"
                              

#line 2360 "check.cog"
                          DEREF(

#line 2360 "check.cog"
                     DEREF(

#line 2360 "check.cog"
              appExpr).args).end();


#line 2361 "check.cog"
     for(auto member : 

#line 2361 "check.cog"
                               

#line 2361 "check.cog"
                       getDecls(

#line 2361 "check.cog"
                                innerFuncDeclRef))
{
{


#line 2363 "check.cog"
         

#line 2363 "check.cog"
         auto paramDeclRef = 

#line 2363 "check.cog"
                                         

#line 2363 "check.cog"
                              

#line 2363 "check.cog"
                            as<

#line 2363 "check.cog"
                               ParamDecl> (

#line 2363 "check.cog"
                                          member);


#line 2364 "check.cog"
         if(

#line 2364 "check.cog"
            

#line 2364 "check.cog"
            !

#line 2364 "check.cog"
             paramDeclRef)
{


#line 2365 "check.cog"
             continue;
}


#line 2367 "check.cog"
         if(

#line 2367 "check.cog"
            

#line 2367 "check.cog"
            !

#line 2367 "check.cog"
             (

#line 2367 "check.cog"
                 

#line 2367 "check.cog"
              aa 

#line 2367 "check.cog"
                 != 

#line 2367 "check.cog"
                    ae))
{


#line 2370 "check.cog"
             return 

#line 2370 "check.cog"
                    nullptr;
}


#line 2373 "check.cog"
         

#line 2373 "check.cog"
         auto arg = 

#line 2373 "check.cog"
                   

#line 2373 "check.cog"
                   *

#line 2373 "check.cog"
                    aa;


#line 2374 "check.cog"
         

#line 2374 "check.cog"
         

#line 2374 "check.cog"
         ++

#line 2374 "check.cog"
           aa;


#line 2378 "check.cog"
         if(

#line 2378 "check.cog"
            

#line 2378 "check.cog"
            !

#line 2378 "check.cog"
                                      

#line 2378 "check.cog"
             doInferenceForArgAndParam(

#line 2379 "check.cog"
             

#line 2379 "check.cog"
             &

#line 2379 "check.cog"
              inferenceContext, 

#line 2380 "check.cog"
                DEREF(

#line 2380 "check.cog"
             arg).exp, 

#line 2381 "check.cog"
             paramDeclRef))
{


#line 2383 "check.cog"
             return 

#line 2383 "check.cog"
                    nullptr;
}
}
}


#line 2386 "check.cog"
     if(

#line 2386 "check.cog"
           

#line 2386 "check.cog"
        aa 

#line 2386 "check.cog"
           != 

#line 2386 "check.cog"
              ae)
{


#line 2389 "check.cog"
         return 

#line 2389 "check.cog"
                nullptr;
}


#line 2394 "check.cog"
     for(auto arg : 

#line 2394 "check.cog"
                    args)
{
{


#line 2396 "check.cog"
         if(

#line 2396 "check.cog"
            

#line 2396 "check.cog"
            !

#line 2396 "check.cog"
                DEREF(

#line 2396 "check.cog"
             arg).val)
{


#line 2397 "check.cog"
             return 

#line 2397 "check.cog"
                    nullptr;
}
}
}


#line 2401 "check.cog"
  

#line 2401 "check.cog"
  auto spec = 

#line 2401 "check.cog"
                                          

#line 2401 "check.cog"
                         

#line 2401 "check.cog"
             createObject<

#line 2401 "check.cog"
                          Specializations> ();


#line 2402 "check.cog"
      DEREF(

#line 2402 "check.cog"
  spec).genericDeclRef = 

#line 2402 "check.cog"
                        genericDeclRef;


#line 2404 "check.cog"
  for(auto arg : 

#line 2404 "check.cog"
                 args)
{
{


#line 2406 "check.cog"
   

#line 2406 "check.cog"
   auto specArg = 

#line 2406 "check.cog"
                                                

#line 2406 "check.cog"
                             

#line 2406 "check.cog"
                 createObject<

#line 2406 "check.cog"
                              SpecializationArg> ();


#line 2407 "check.cog"
          DEREF(

#line 2407 "check.cog"
   specArg).param = 

#line 2407 "check.cog"
                                           

#line 2407 "check.cog"
                                   DEREF(

#line 2407 "check.cog"
                      DEREF(

#line 2407 "check.cog"
                   arg).paramDeclRef).getDecl();


#line 2408 "check.cog"
          DEREF(

#line 2408 "check.cog"
   specArg).value = 

#line 2408 "check.cog"
                      DEREF(

#line 2408 "check.cog"
                   arg).val;


#line 2410 "check.cog"
                   

#line 2410 "check.cog"
                   

#line 2410 "check.cog"
            DEREF(

#line 2410 "check.cog"
       DEREF(

#line 2410 "check.cog"
   spec).args).append(

#line 2410 "check.cog"
                    specArg);
}
}


#line 2413 "check.cog"
  return 

#line 2413 "check.cog"
         spec;
}


#line 2416 "check.cog"
 void addGenericOverloadCandidate(

#line 2417 "check.cog"
                                    

#line 2417 "check.cog"
              OverloadResolveContext

#line 2417 "check.cog"
                                    * context, 

#line 2418 "check.cog"
                                   

#line 2418 "check.cog"
                     DeclRefValImpl<

#line 2418 "check.cog"
                                    GenericDecl>  genericDeclRef)
{


#line 2420 "check.cog"
            

#line 2420 "check.cog"
            

#line 2420 "check.cog"
  ensureDecl(

#line 2420 "check.cog"
                    DEREF(

#line 2420 "check.cog"
             context).checkContext, 

#line 2420 "check.cog"
                                                         

#line 2420 "check.cog"
                                                 DEREF(

#line 2420 "check.cog"
                                   genericDeclRef).getDecl());


#line 2430 "check.cog"
     

#line 2430 "check.cog"
     auto innerDeclRef = 

#line 2430 "check.cog"
                                

#line 2430 "check.cog"
                        getInner(

#line 2430 "check.cog"
                                 genericDeclRef);


#line 2431 "check.cog"
     

#line 2431 "check.cog"
     auto specializations = 

#line 2431 "check.cog"
                                                 

#line 2431 "check.cog"
                           inferGenericArgsForApp(

#line 2432 "check.cog"
                DEREF(

#line 2432 "check.cog"
         context).checkContext, 

#line 2433 "check.cog"
         genericDeclRef, 

#line 2434 "check.cog"
                DEREF(

#line 2434 "check.cog"
         context).appExp);


#line 2435 "check.cog"
     if(

#line 2435 "check.cog"
        specializations)
{


#line 2437 "check.cog"
                     DEREF(

#line 2437 "check.cog"
         innerDeclRef).specializations = 

#line 2437 "check.cog"
                                        specializations;
}


#line 2444 "check.cog"
                                 

#line 2444 "check.cog"
                                 

#line 2444 "check.cog"
     addDeclRefOverloadCandidates(

#line 2444 "check.cog"
                                  context, 

#line 2444 "check.cog"
                                           innerDeclRef);
}


#line 2447 "check.cog"
 void addDeclRefOverloadCandidates(

#line 2448 "check.cog"
                                    

#line 2448 "check.cog"
              OverloadResolveContext

#line 2448 "check.cog"
                                    * context, 

#line 2449 "check.cog"
          DeclRefVal val)
{


#line 2451 "check.cog"
     if(auto funcDeclRef = 

#line 2451 "check.cog"
                                          

#line 2451 "check.cog"
                            

#line 2451 "check.cog"
                          as<

#line 2451 "check.cog"
                             FuncDeclBase> (

#line 2451 "check.cog"
                                           val))
{


#line 2453 "check.cog"
                                 

#line 2453 "check.cog"
                                 

#line 2453 "check.cog"
         addFuncOverloadCandidate(

#line 2453 "check.cog"
                                  context, 

#line 2453 "check.cog"
                                           funcDeclRef);
}
else
{


#line 2455 "check.cog"
          if(auto genericDeclRef = 

#line 2455 "check.cog"
                                                 

#line 2455 "check.cog"
                                    

#line 2455 "check.cog"
                                  as<

#line 2455 "check.cog"
                                     GenericDecl> (

#line 2455 "check.cog"
                                                  val))
{


#line 2457 "check.cog"
                                    

#line 2457 "check.cog"
                                    

#line 2457 "check.cog"
         addGenericOverloadCandidate(

#line 2457 "check.cog"
                                     context, 

#line 2457 "check.cog"
                                              genericDeclRef);
}
else
{
}
}
}


#line 2467 "check.cog"
 

#line 2470 "check.cog"
     Val specializeVal(

#line 2468 "check.cog"
       Val val, 

#line 2469 "check.cog"
                   Specializations specializations)
{


#line 2472 "check.cog"
  if(auto type = 

#line 2472 "check.cog"
                        

#line 2472 "check.cog"
                  

#line 2472 "check.cog"
                as<

#line 2472 "check.cog"
                   Type> (

#line 2472 "check.cog"
                         val))
{


#line 2474 "check.cog"
   return 

#line 2474 "check.cog"
                        

#line 2474 "check.cog"
          specializeType(

#line 2474 "check.cog"
                         type, 

#line 2474 "check.cog"
                               specializations);
}


#line 2477 "check.cog"
           

#line 2477 "check.cog"
           

#line 2477 "check.cog"
  cogAssert(

#line 2477 "check.cog"
            

#line 2477 "check.cog"
            !

#line 2477 "check.cog"
             "unimplemented");


#line 2478 "check.cog"
  return 

#line 2478 "check.cog"
         nullptr;
}


#line 2481 "check.cog"
 

#line 2484 "check.cog"
     Val findSpecialization(

#line 2482 "check.cog"
                   Specializations specializations, 

#line 2483 "check.cog"
           Decl decl)
{


#line 2486 "check.cog"
  for(auto arg : 

#line 2486 "check.cog"
                                DEREF(

#line 2486 "check.cog"
                 specializations).args)
{
{


#line 2488 "check.cog"
   if(

#line 2488 "check.cog"
           

#line 2488 "check.cog"
      decl 

#line 2488 "check.cog"
           == 

#line 2488 "check.cog"
                 DEREF(

#line 2488 "check.cog"
              arg).param)
{


#line 2490 "check.cog"
    return 

#line 2490 "check.cog"
              DEREF(

#line 2490 "check.cog"
           arg).value;
}
}
}


#line 2494 "check.cog"
  return 

#line 2494 "check.cog"
         nullptr;
}


#line 2497 "check.cog"
 

#line 2500 "check.cog"
     DeclRefVal specializeDeclRef(

#line 2498 "check.cog"
           DeclRefVal declRef, 

#line 2499 "check.cog"
                   Specializations specializations)
{


#line 2502 "check.cog"
  

#line 2502 "check.cog"
  auto oldDecl = 

#line 2502 "check.cog"
                               

#line 2502 "check.cog"
                       DEREF(

#line 2502 "check.cog"
                declRef).getDecl();


#line 2503 "check.cog"
  

#line 2503 "check.cog"
  auto oldSpecializations = 

#line 2503 "check.cog"
                                                     

#line 2503 "check.cog"
                                  DEREF(

#line 2503 "check.cog"
                           declRef).getSpecializations();


#line 2506 "check.cog"
  if(auto genericTypeParamDecl = 

#line 2506 "check.cog"
                                                    

#line 2506 "check.cog"
                                  

#line 2506 "check.cog"
                                as<

#line 2506 "check.cog"
                                   GenericParamDecl> (

#line 2506 "check.cog"
                                                     oldDecl))
{


#line 2509 "check.cog"
   if(auto newVal = 

#line 2509 "check.cog"
                                     

#line 2509 "check.cog"
                   findSpecialization(

#line 2509 "check.cog"
                                      specializations, 

#line 2509 "check.cog"
                                                       genericTypeParamDecl))
{


#line 2511 "check.cog"
    if(auto typeDeclRef = 

#line 2511 "check.cog"
                                        

#line 2511 "check.cog"
                           

#line 2511 "check.cog"
                         as<

#line 2511 "check.cog"
                            DeclRefType> (

#line 2511 "check.cog"
                                         newVal))
{


#line 2512 "check.cog"
     return 

#line 2512 "check.cog"
                       DEREF(

#line 2512 "check.cog"
            typeDeclRef).declRef;
}
}


#line 2515 "check.cog"
            

#line 2515 "check.cog"
            

#line 2515 "check.cog"
   cogAssert(

#line 2515 "check.cog"
             

#line 2515 "check.cog"
             !

#line 2515 "check.cog"
              "unimplemented");
}


#line 2518 "check.cog"
  if(

#line 2518 "check.cog"
     

#line 2518 "check.cog"
     !

#line 2518 "check.cog"
      oldSpecializations)
{


#line 2519 "check.cog"
   return 

#line 2519 "check.cog"
          declRef;
}


#line 2523 "check.cog"
  

#line 2523 "check.cog"
  auto newSpec = 

#line 2523 "check.cog"
                                             

#line 2523 "check.cog"
                            

#line 2523 "check.cog"
                createObject<

#line 2523 "check.cog"
                             Specializations> ();


#line 2524 "check.cog"
         DEREF(

#line 2524 "check.cog"
  newSpec).genericDeclRef = 

#line 2524 "check.cog"
                                          

#line 2524 "check.cog"
                             

#line 2524 "check.cog"
                           as<

#line 2524 "check.cog"
                              GenericDecl> (

#line 2524 "check.cog"
                                                            

#line 2524 "check.cog"
                                           specializeDeclRef(

#line 2525 "check.cog"
                     DEREF(

#line 2525 "check.cog"
   oldSpecializations).genericDeclRef, 

#line 2526 "check.cog"
   specializations));


#line 2528 "check.cog"
  for(auto arg : 

#line 2528 "check.cog"
                                   DEREF(

#line 2528 "check.cog"
                 oldSpecializations).args)
{
{


#line 2532 "check.cog"
   

#line 2532 "check.cog"
   auto newSpecArg = 

#line 2532 "check.cog"
                                                   

#line 2532 "check.cog"
                                

#line 2532 "check.cog"
                    createObject<

#line 2532 "check.cog"
                                 SpecializationArg> ();


#line 2533 "check.cog"
             DEREF(

#line 2533 "check.cog"
   newSpecArg).param = 

#line 2533 "check.cog"
                         DEREF(

#line 2533 "check.cog"
                      arg).param;


#line 2534 "check.cog"
             DEREF(

#line 2534 "check.cog"
   newSpecArg).value = 

#line 2534 "check.cog"
                                   

#line 2534 "check.cog"
                      specializeVal(

#line 2534 "check.cog"
                                       DEREF(

#line 2534 "check.cog"
                                    arg).value, 

#line 2534 "check.cog"
                                               specializations);


#line 2536 "check.cog"
                      

#line 2536 "check.cog"
                      

#line 2536 "check.cog"
               DEREF(

#line 2536 "check.cog"
          DEREF(

#line 2536 "check.cog"
   newSpec).args).append(

#line 2536 "check.cog"
                       newSpecArg);
}
}


#line 2539 "check.cog"
  return 

#line 2539 "check.cog"
                   

#line 2539 "check.cog"
         DeclRefVal(

#line 2539 "check.cog"
                    oldDecl, 

#line 2539 "check.cog"
                             newSpec);
}


#line 2542 "check.cog"
 

#line 2545 "check.cog"
     Type specializeType(

#line 2543 "check.cog"
        Type type, 

#line 2544 "check.cog"
                   Specializations specializations)
{


#line 2547 "check.cog"
  if(

#line 2547 "check.cog"
     

#line 2547 "check.cog"
     !

#line 2547 "check.cog"
      specializations)
{


#line 2548 "check.cog"
   return 

#line 2548 "check.cog"
          type;
}


#line 2550 "check.cog"
  if(auto declRefType = 

#line 2550 "check.cog"
                                      

#line 2550 "check.cog"
                         

#line 2550 "check.cog"
                       as<

#line 2550 "check.cog"
                          DeclRefType> (

#line 2550 "check.cog"
                                       type))
{


#line 2553 "check.cog"
   

#line 2553 "check.cog"
   auto specDeclRef = 

#line 2553 "check.cog"
                                      

#line 2553 "check.cog"
                     specializeDeclRef(

#line 2553 "check.cog"
                                                  DEREF(

#line 2553 "check.cog"
                                       declRefType).declRef, 

#line 2553 "check.cog"
                                                            specializations);


#line 2555 "check.cog"
   return 

#line 2555 "check.cog"
                           

#line 2555 "check.cog"
          createDeclRefType(

#line 2555 "check.cog"
                            specDeclRef);
}


#line 2558 "check.cog"
  if(auto errorType = 

#line 2558 "check.cog"
                                  

#line 2558 "check.cog"
                       

#line 2558 "check.cog"
                     as<

#line 2558 "check.cog"
                        ErrorType> (

#line 2558 "check.cog"
                                   type))
{


#line 2559 "check.cog"
   return 

#line 2559 "check.cog"
          errorType;
}


#line 2561 "check.cog"
           

#line 2561 "check.cog"
           

#line 2561 "check.cog"
  cogAssert(

#line 2561 "check.cog"
            

#line 2561 "check.cog"
            !

#line 2561 "check.cog"
             "unimplemented");


#line 2562 "check.cog"
  return 

#line 2562 "check.cog"
         nullptr;
}


#line 166 "syntax.cog"
 

#line 2567 "check.cog"
 void ensureDecl(

#line 2568 "check.cog"
                       

#line 2568 "check.cog"
           CheckContext

#line 2568 "check.cog"
                       * context, 

#line 2569 "check.cog"
        Decl decl, 

#line 2570 "check.cog"
         DeclCheckState state)
{


#line 2572 "check.cog"
  if(

#line 2572 "check.cog"
                     

#line 2572 "check.cog"
         DEREF(

#line 2572 "check.cog"
     decl).checkState 

#line 2572 "check.cog"
                     >= 

#line 2572 "check.cog"
                        state)
{


#line 2573 "check.cog"
   return;
}


#line 2575 "check.cog"
           

#line 2575 "check.cog"
           

#line 2575 "check.cog"
  checkDecl(

#line 2575 "check.cog"
            context, 

#line 2575 "check.cog"
                     decl);
}


#line 2578 "check.cog"
 void ensureDecl(

#line 2579 "check.cog"
                       

#line 2579 "check.cog"
           CheckContext

#line 2579 "check.cog"
                       * context, 

#line 2580 "check.cog"
        Decl decl)
{


#line 2582 "check.cog"
            

#line 2582 "check.cog"
            

#line 2582 "check.cog"
  ensureDecl(

#line 2582 "check.cog"
             context, 

#line 2582 "check.cog"
                      decl, 

#line 2582 "check.cog"
                            kDeclCheckState_CheckedHead);
}


#line 3 "diagnostic.cog"
 

#line 5 "diagnostic.cog"
 

#line 13 "diagnostic.cog"
 

#line 44 "diagnostic.cog"
 

#line 48 "diagnostic.cog"
  ArgTypeList::ArgTypeList()
{


#line 50 "diagnostic.cog"
       DEREF(

#line 50 "diagnostic.cog"
   this).args = 

#line 50 "diagnostic.cog"
                         

#line 50 "diagnostic.cog"
                    

#line 50 "diagnostic.cog"
               Array<

#line 50 "diagnostic.cog"
                     Arg> ();
}


#line 53 "diagnostic.cog"
  ArgTypeList::ArgTypeList(

#line 53 "diagnostic.cog"
                  

#line 53 "diagnostic.cog"
             Array<

#line 53 "diagnostic.cog"
                   Arg>  args)
{


#line 55 "diagnostic.cog"
       DEREF(

#line 55 "diagnostic.cog"
   this).args = 

#line 55 "diagnostic.cog"
               args;
}


#line 59 "diagnostic.cog"
 

#line 14 "token.cog"
 

#line 70 "diagnostic.cog"
 

#line 72 "diagnostic.cog"
  DiagnosticArg::DiagnosticArg(

#line 72 "diagnostic.cog"
            Int val)
{


#line 74 "diagnostic.cog"
       DEREF(

#line 74 "diagnostic.cog"
   this).flavor = 

#line 74 "diagnostic.cog"
                 kFlavor_Int;


#line 75 "diagnostic.cog"
       DEREF(

#line 75 "diagnostic.cog"
   this).intVal = 

#line 75 "diagnostic.cog"
                 val;
}


#line 78 "diagnostic.cog"
  DiagnosticArg::DiagnosticArg(

#line 78 "diagnostic.cog"
            TokenCode val)
{


#line 80 "diagnostic.cog"
       DEREF(

#line 80 "diagnostic.cog"
   this).flavor = 

#line 80 "diagnostic.cog"
                 kFlavor_TokenCode;


#line 81 "diagnostic.cog"
       DEREF(

#line 81 "diagnostic.cog"
   this).tokenCodeVal = 

#line 81 "diagnostic.cog"
                       val;
}


#line 84 "diagnostic.cog"
  DiagnosticArg::DiagnosticArg(

#line 84 "diagnostic.cog"
               

#line 84 "diagnostic.cog"
            Ptr<

#line 84 "diagnostic.cog"
                Name>  val)
{


#line 86 "diagnostic.cog"
       DEREF(

#line 86 "diagnostic.cog"
   this).flavor = 

#line 86 "diagnostic.cog"
                 kFlavor_Name;


#line 87 "diagnostic.cog"
       DEREF(

#line 87 "diagnostic.cog"
   this).nameVal = 

#line 87 "diagnostic.cog"
                  val;
}


#line 90 "diagnostic.cog"
  DiagnosticArg::DiagnosticArg(

#line 90 "diagnostic.cog"
            StringSpan val)
{


#line 92 "diagnostic.cog"
       DEREF(

#line 92 "diagnostic.cog"
   this).flavor = 

#line 92 "diagnostic.cog"
                 kFlavor_StringSpan;


#line 93 "diagnostic.cog"
       DEREF(

#line 93 "diagnostic.cog"
   this).stringSpanVal = 

#line 93 "diagnostic.cog"
                        val;
}


#line 98 "diagnostic.cog"
  DiagnosticArg::DiagnosticArg(

#line 98 "diagnostic.cog"
                    

#line 98 "diagnostic.cog"
            ConstPtr<

#line 98 "diagnostic.cog"
                     Char>  val)
{


#line 100 "diagnostic.cog"
       DEREF(

#line 100 "diagnostic.cog"
   this).flavor = 

#line 100 "diagnostic.cog"
                 kFlavor_StringSpan;


#line 101 "diagnostic.cog"
       DEREF(

#line 101 "diagnostic.cog"
   this).stringSpanVal = 

#line 101 "diagnostic.cog"
                                            

#line 101 "diagnostic.cog"
                        TerminatedStringSpan(

#line 101 "diagnostic.cog"
                                             val);
}


#line 104 "diagnostic.cog"
  DiagnosticArg::DiagnosticArg(

#line 104 "diagnostic.cog"
            Type val)
{


#line 106 "diagnostic.cog"
       DEREF(

#line 106 "diagnostic.cog"
   this).flavor = 

#line 106 "diagnostic.cog"
                 kFlavor_Type;


#line 107 "diagnostic.cog"
       DEREF(

#line 107 "diagnostic.cog"
   this).typeVal = 

#line 107 "diagnostic.cog"
                  val;
}


#line 110 "diagnostic.cog"
  DiagnosticArg::DiagnosticArg(

#line 110 "diagnostic.cog"
            DeclRefVal val)
{


#line 112 "diagnostic.cog"
       DEREF(

#line 112 "diagnostic.cog"
   this).flavor = 

#line 112 "diagnostic.cog"
                 kFlavor_DeclRef;


#line 113 "diagnostic.cog"
       DEREF(

#line 113 "diagnostic.cog"
   this).declRefVal = 

#line 113 "diagnostic.cog"
                     val;
}


#line 116 "diagnostic.cog"
  DiagnosticArg::DiagnosticArg(

#line 116 "diagnostic.cog"
                    

#line 116 "diagnostic.cog"
            ConstRef<

#line 116 "diagnostic.cog"
                     ArgTypeList>  val)
{


#line 118 "diagnostic.cog"
       DEREF(

#line 118 "diagnostic.cog"
   this).flavor = 

#line 118 "diagnostic.cog"
                 kFlavor_ArgTypeList;


#line 119 "diagnostic.cog"
       DEREF(

#line 119 "diagnostic.cog"
   this).argTypeListVal = 

#line 119 "diagnostic.cog"
                         val;
}


#line 135 "diagnostic.cog"
 void diagnose(

#line 136 "diagnostic.cog"
           

#line 136 "diagnostic.cog"
        Ptr<

#line 136 "diagnostic.cog"
            DiagnosticSink>  sink, 

#line 137 "diagnostic.cog"
       SourceLoc loc, 

#line 138 "diagnostic.cog"
      DiagnosticID id)
{


#line 140 "diagnostic.cog"
              

#line 140 "diagnostic.cog"
              

#line 140 "diagnostic.cog"
  diagnoseImpl(

#line 140 "diagnostic.cog"
               sink, 

#line 140 "diagnostic.cog"
                     loc, 

#line 140 "diagnostic.cog"
                          id, 

#line 140 "diagnostic.cog"
                              0, 

#line 140 "diagnostic.cog"
                                 0);
}


#line 143 "diagnostic.cog"
 void diagnose(

#line 144 "diagnostic.cog"
           

#line 144 "diagnostic.cog"
        Ptr<

#line 144 "diagnostic.cog"
            DiagnosticSink>  sink, 

#line 145 "diagnostic.cog"
       SourceLoc loc, 

#line 146 "diagnostic.cog"
      DiagnosticID id, 

#line 147 "diagnostic.cog"
        DiagnosticArg arg0)
{


#line 149 "diagnostic.cog"
  

#line 149 "diagnostic.cog"
  

#line 149 "diagnostic.cog"
                           

#line 149 "diagnostic.cog"
             FixedSizeArray<

#line 149 "diagnostic.cog"
                            1, 

#line 149 "diagnostic.cog"
                                  

#line 149 "diagnostic.cog"
                               Ptr<

#line 149 "diagnostic.cog"
                                   DiagnosticArg> >  args;


#line 150 "diagnostic.cog"
      

#line 150 "diagnostic.cog"
  args[

#line 150 "diagnostic.cog"
       0] = 

#line 150 "diagnostic.cog"
            

#line 150 "diagnostic.cog"
            &

#line 150 "diagnostic.cog"
             arg0;


#line 151 "diagnostic.cog"
              

#line 151 "diagnostic.cog"
              

#line 151 "diagnostic.cog"
  diagnoseImpl(

#line 151 "diagnostic.cog"
               sink, 

#line 151 "diagnostic.cog"
                     loc, 

#line 151 "diagnostic.cog"
                          id, 

#line 151 "diagnostic.cog"
                              1, 

#line 151 "diagnostic.cog"
                                 args);
}


#line 154 "diagnostic.cog"
 void diagnose(

#line 155 "diagnostic.cog"
           

#line 155 "diagnostic.cog"
        Ptr<

#line 155 "diagnostic.cog"
            DiagnosticSink>  sink, 

#line 156 "diagnostic.cog"
       SourceLoc loc, 

#line 157 "diagnostic.cog"
      DiagnosticID id, 

#line 158 "diagnostic.cog"
        DiagnosticArg arg0, 

#line 159 "diagnostic.cog"
        DiagnosticArg arg1)
{


#line 161 "diagnostic.cog"
  

#line 161 "diagnostic.cog"
  

#line 161 "diagnostic.cog"
                           

#line 161 "diagnostic.cog"
             FixedSizeArray<

#line 161 "diagnostic.cog"
                            2, 

#line 161 "diagnostic.cog"
                                  

#line 161 "diagnostic.cog"
                               Ptr<

#line 161 "diagnostic.cog"
                                   DiagnosticArg> >  args;


#line 162 "diagnostic.cog"
      

#line 162 "diagnostic.cog"
  args[

#line 162 "diagnostic.cog"
       0] = 

#line 162 "diagnostic.cog"
            

#line 162 "diagnostic.cog"
            &

#line 162 "diagnostic.cog"
             arg0;


#line 163 "diagnostic.cog"
      

#line 163 "diagnostic.cog"
  args[

#line 163 "diagnostic.cog"
       1] = 

#line 163 "diagnostic.cog"
            

#line 163 "diagnostic.cog"
            &

#line 163 "diagnostic.cog"
             arg1;


#line 164 "diagnostic.cog"
              

#line 164 "diagnostic.cog"
              

#line 164 "diagnostic.cog"
  diagnoseImpl(

#line 164 "diagnostic.cog"
               sink, 

#line 164 "diagnostic.cog"
                     loc, 

#line 164 "diagnostic.cog"
                          id, 

#line 164 "diagnostic.cog"
                              2, 

#line 164 "diagnostic.cog"
                                 args);
}


#line 232 "diagnostic.cog"
 void printVal(

#line 233 "diagnostic.cog"
              

#line 233 "diagnostic.cog"
          FILE

#line 233 "diagnostic.cog"
              * stream, 

#line 234 "diagnostic.cog"
       Val val)
{


#line 236 "diagnostic.cog"
  if(auto type = 

#line 236 "diagnostic.cog"
                        

#line 236 "diagnostic.cog"
                  

#line 236 "diagnostic.cog"
                as<

#line 236 "diagnostic.cog"
                   Type> (

#line 236 "diagnostic.cog"
                         val))
{


#line 238 "diagnostic.cog"
            

#line 238 "diagnostic.cog"
            

#line 238 "diagnostic.cog"
   printType(

#line 238 "diagnostic.cog"
             stream, 

#line 238 "diagnostic.cog"
                     type);
}
else
{


#line 242 "diagnostic.cog"
          

#line 242 "diagnostic.cog"
          

#line 242 "diagnostic.cog"
   fprintf(

#line 242 "diagnostic.cog"
           stream, 

#line 242 "diagnostic.cog"
                   "<val>");
}
}


#line 246 "diagnostic.cog"
 void printDeclRef(

#line 247 "diagnostic.cog"
              

#line 247 "diagnostic.cog"
          FILE

#line 247 "diagnostic.cog"
              * stream, 

#line 248 "diagnostic.cog"
           DeclRefVal declRef)
{


#line 250 "diagnostic.cog"
         

#line 250 "diagnostic.cog"
         

#line 250 "diagnostic.cog"
  fprintf(

#line 250 "diagnostic.cog"
          stream, 

#line 250 "diagnostic.cog"
                  "%s", 

#line 250 "diagnostic.cog"
                                                       DEREF(

#line 250 "diagnostic.cog"
                               

#line 250 "diagnostic.cog"
                        getText(

#line 250 "diagnostic.cog"
                                                 DEREF(

#line 250 "diagnostic.cog"
                                               

#line 250 "diagnostic.cog"
                                       DEREF(

#line 250 "diagnostic.cog"
                                declRef).getDecl()).name)).begin);


#line 252 "diagnostic.cog"
  if(auto spec = 

#line 252 "diagnostic.cog"
                                          

#line 252 "diagnostic.cog"
                       DEREF(

#line 252 "diagnostic.cog"
                declRef).getSpecializations())
{


#line 254 "diagnostic.cog"
   if(

#line 254 "diagnostic.cog"
                               

#line 254 "diagnostic.cog"
                       DEREF(

#line 254 "diagnostic.cog"
                     

#line 254 "diagnostic.cog"
             DEREF(

#line 254 "diagnostic.cog"
      declRef).getDecl()).parent 

#line 254 "diagnostic.cog"
                               == 

#line 254 "diagnostic.cog"
                                                             

#line 254 "diagnostic.cog"
                                                     DEREF(

#line 254 "diagnostic.cog"
                                      DEREF(

#line 254 "diagnostic.cog"
                                  spec).genericDeclRef).getDecl())
{


#line 256 "diagnostic.cog"
           

#line 256 "diagnostic.cog"
           

#line 256 "diagnostic.cog"
    fprintf(

#line 256 "diagnostic.cog"
            stream, 

#line 256 "diagnostic.cog"
                    "<");


#line 257 "diagnostic.cog"
    

#line 257 "diagnostic.cog"
    auto first = 

#line 257 "diagnostic.cog"
                true;


#line 258 "diagnostic.cog"
    for(auto arg : 

#line 258 "diagnostic.cog"
                      DEREF(

#line 258 "diagnostic.cog"
                  spec).args)
{
{


#line 260 "diagnostic.cog"
     if(

#line 260 "diagnostic.cog"
        

#line 260 "diagnostic.cog"
        !

#line 260 "diagnostic.cog"
         first)
{


#line 260 "diagnostic.cog"
                       

#line 260 "diagnostic.cog"
                       

#line 260 "diagnostic.cog"
                fprintf(

#line 260 "diagnostic.cog"
                        stream, 

#line 260 "diagnostic.cog"
                                ",");
}


#line 262 "diagnostic.cog"
             

#line 262 "diagnostic.cog"
             

#line 262 "diagnostic.cog"
     printVal(

#line 262 "diagnostic.cog"
              stream, 

#line 262 "diagnostic.cog"
                         DEREF(

#line 262 "diagnostic.cog"
                      arg).value);


#line 264 "diagnostic.cog"
     first = 

#line 264 "diagnostic.cog"
             false;
}
}


#line 266 "diagnostic.cog"
           

#line 266 "diagnostic.cog"
           

#line 266 "diagnostic.cog"
    fprintf(

#line 266 "diagnostic.cog"
            stream, 

#line 266 "diagnostic.cog"
                    ">");
}
}
}


#line 271 "diagnostic.cog"
 void printType(

#line 272 "diagnostic.cog"
              

#line 272 "diagnostic.cog"
          FILE

#line 272 "diagnostic.cog"
              * stream, 

#line 273 "diagnostic.cog"
        Type type)
{


#line 275 "diagnostic.cog"
  if(auto declRefType = 

#line 275 "diagnostic.cog"
                                      

#line 275 "diagnostic.cog"
                         

#line 275 "diagnostic.cog"
                       as<

#line 275 "diagnostic.cog"
                          DeclRefType> (

#line 275 "diagnostic.cog"
                                       type))
{


#line 277 "diagnostic.cog"
               

#line 277 "diagnostic.cog"
               

#line 277 "diagnostic.cog"
   printDeclRef(

#line 277 "diagnostic.cog"
                stream, 

#line 277 "diagnostic.cog"
                                   DEREF(

#line 277 "diagnostic.cog"
                        declRefType).declRef);
}
else
{


#line 279 "diagnostic.cog"
       if(auto typeType = 

#line 279 "diagnostic.cog"
                                     

#line 279 "diagnostic.cog"
                           

#line 279 "diagnostic.cog"
                         as<

#line 279 "diagnostic.cog"
                            TypeType> (

#line 279 "diagnostic.cog"
                                      type))
{


#line 281 "diagnostic.cog"
          

#line 281 "diagnostic.cog"
          

#line 281 "diagnostic.cog"
   fprintf(

#line 281 "diagnostic.cog"
           stream, 

#line 281 "diagnostic.cog"
                   "typeof(");


#line 282 "diagnostic.cog"
            

#line 282 "diagnostic.cog"
            

#line 282 "diagnostic.cog"
   printType(

#line 282 "diagnostic.cog"
             stream, 

#line 282 "diagnostic.cog"
                             DEREF(

#line 282 "diagnostic.cog"
                     typeType).type);


#line 283 "diagnostic.cog"
          

#line 283 "diagnostic.cog"
          

#line 283 "diagnostic.cog"
   fprintf(

#line 283 "diagnostic.cog"
           stream, 

#line 283 "diagnostic.cog"
                   ")");
}
else
{


#line 285 "diagnostic.cog"
       if(auto funcType = 

#line 285 "diagnostic.cog"
                                     

#line 285 "diagnostic.cog"
                           

#line 285 "diagnostic.cog"
                         as<

#line 285 "diagnostic.cog"
                            FuncType> (

#line 285 "diagnostic.cog"
                                      type))
{


#line 287 "diagnostic.cog"
          

#line 287 "diagnostic.cog"
          

#line 287 "diagnostic.cog"
   fprintf(

#line 287 "diagnostic.cog"
           stream, 

#line 287 "diagnostic.cog"
                   "FUNC_TYPE");
}
else
{


#line 289 "diagnostic.cog"
       if(auto errorType = 

#line 289 "diagnostic.cog"
                                       

#line 289 "diagnostic.cog"
                            

#line 289 "diagnostic.cog"
                          as<

#line 289 "diagnostic.cog"
                             ErrorType> (

#line 289 "diagnostic.cog"
                                        type))
{


#line 291 "diagnostic.cog"
          

#line 291 "diagnostic.cog"
          

#line 291 "diagnostic.cog"
   fprintf(

#line 291 "diagnostic.cog"
           stream, 

#line 291 "diagnostic.cog"
                   "<error>");
}
else
{


#line 293 "diagnostic.cog"
       if(auto overloadGroupType = 

#line 293 "diagnostic.cog"
                                                       

#line 293 "diagnostic.cog"
                                    

#line 293 "diagnostic.cog"
                                  as<

#line 293 "diagnostic.cog"
                                     OverloadGroupType> (

#line 293 "diagnostic.cog"
                                                        type))
{


#line 295 "diagnostic.cog"
          

#line 295 "diagnostic.cog"
          

#line 295 "diagnostic.cog"
   fprintf(

#line 295 "diagnostic.cog"
           stream, 

#line 295 "diagnostic.cog"
                   "<overload group>");
}
else
{


#line 297 "diagnostic.cog"
       if(

#line 297 "diagnostic.cog"
          

#line 297 "diagnostic.cog"
          !

#line 297 "diagnostic.cog"
           type)
{


#line 299 "diagnostic.cog"
          

#line 299 "diagnostic.cog"
          

#line 299 "diagnostic.cog"
   fprintf(

#line 299 "diagnostic.cog"
           stream, 

#line 299 "diagnostic.cog"
                   "NULL_TYPE");
}
else
{


#line 303 "diagnostic.cog"
          

#line 303 "diagnostic.cog"
          

#line 303 "diagnostic.cog"
   fprintf(

#line 303 "diagnostic.cog"
           stream, 

#line 303 "diagnostic.cog"
                   "UNKNOWN_TYPE(%s)", 

#line 303 "diagnostic.cog"
                                                       DEREF(

#line 303 "diagnostic.cog"
                                           DEREF(

#line 303 "diagnostic.cog"
                                       type).directClass).name);
}
}
}
}
}
}
}


#line 307 "diagnostic.cog"
 void printDiagnosticArg(

#line 308 "diagnostic.cog"
               

#line 308 "diagnostic.cog"
       ConstPtr<

#line 308 "diagnostic.cog"
                DiagnosticArg>  arg)
{


#line 310 "diagnostic.cog"
  switch(

#line 310 "diagnostic.cog"
            DEREF(

#line 310 "diagnostic.cog"
         arg).flavor)
{
case 

#line 312 "diagnostic.cog"
       kFlavor_Int:
{


#line 313 "diagnostic.cog"
          

#line 313 "diagnostic.cog"
          

#line 313 "diagnostic.cog"
   fprintf(

#line 313 "diagnostic.cog"
           stderr, 

#line 313 "diagnostic.cog"
                   "%ld", 

#line 313 "diagnostic.cog"
                             DEREF(

#line 313 "diagnostic.cog"
                          arg).intVal);
}
{


#line 314 "diagnostic.cog"
   break;
}
case 

#line 316 "diagnostic.cog"
       kFlavor_TokenCode:
{


#line 318 "diagnostic.cog"
          

#line 318 "diagnostic.cog"
          

#line 318 "diagnostic.cog"
   fprintf(

#line 318 "diagnostic.cog"
           stderr, 

#line 318 "diagnostic.cog"
                   "TOKEN: %d", 

#line 318 "diagnostic.cog"
                                   DEREF(

#line 318 "diagnostic.cog"
                                arg).tokenCodeVal);
}
{


#line 319 "diagnostic.cog"
   break;
}
case 

#line 321 "diagnostic.cog"
       kFlavor_Name:
{
{


#line 323 "diagnostic.cog"
    

#line 323 "diagnostic.cog"
    auto text = 

#line 323 "diagnostic.cog"
                      

#line 323 "diagnostic.cog"
               getText(

#line 323 "diagnostic.cog"
                          DEREF(

#line 323 "diagnostic.cog"
                       arg).nameVal);


#line 324 "diagnostic.cog"
          

#line 324 "diagnostic.cog"
          

#line 324 "diagnostic.cog"
    fwrite(

#line 324 "diagnostic.cog"
               DEREF(

#line 324 "diagnostic.cog"
           text).begin, 

#line 324 "diagnostic.cog"
                       1, 

#line 324 "diagnostic.cog"
                                  

#line 324 "diagnostic.cog"
                              DEREF(

#line 324 "diagnostic.cog"
                          text).end 

#line 324 "diagnostic.cog"
                                  - 

#line 324 "diagnostic.cog"
                                       DEREF(

#line 324 "diagnostic.cog"
                                   text).begin, 

#line 324 "diagnostic.cog"
                                               stderr);
}
}
{


#line 326 "diagnostic.cog"
   break;
}
case 

#line 328 "diagnostic.cog"
       kFlavor_StringSpan:
{
{


#line 330 "diagnostic.cog"
    

#line 330 "diagnostic.cog"
    auto text = 

#line 330 "diagnostic.cog"
                  DEREF(

#line 330 "diagnostic.cog"
               arg).stringSpanVal;


#line 331 "diagnostic.cog"
          

#line 331 "diagnostic.cog"
          

#line 331 "diagnostic.cog"
    fwrite(

#line 331 "diagnostic.cog"
               DEREF(

#line 331 "diagnostic.cog"
           text).begin, 

#line 331 "diagnostic.cog"
                       1, 

#line 331 "diagnostic.cog"
                                  

#line 331 "diagnostic.cog"
                              DEREF(

#line 331 "diagnostic.cog"
                          text).end 

#line 331 "diagnostic.cog"
                                  - 

#line 331 "diagnostic.cog"
                                       DEREF(

#line 331 "diagnostic.cog"
                                   text).begin, 

#line 331 "diagnostic.cog"
                                               stderr);
}
}
{


#line 333 "diagnostic.cog"
   break;
}
case 

#line 335 "diagnostic.cog"
       kFlavor_Type:
{
{


#line 337 "diagnostic.cog"
             

#line 337 "diagnostic.cog"
             

#line 337 "diagnostic.cog"
    printType(

#line 337 "diagnostic.cog"
              stderr, 

#line 337 "diagnostic.cog"
                         DEREF(

#line 337 "diagnostic.cog"
                      arg).typeVal);
}
}
{


#line 339 "diagnostic.cog"
   break;
}
case 

#line 341 "diagnostic.cog"
       kFlavor_ArgTypeList:
{
{


#line 343 "diagnostic.cog"
    

#line 343 "diagnostic.cog"
    auto first = 

#line 343 "diagnostic.cog"
                true;


#line 344 "diagnostic.cog"
    for(auto aa : 

#line 344 "diagnostic.cog"
                                    DEREF(

#line 344 "diagnostic.cog"
                     DEREF(

#line 344 "diagnostic.cog"
                  arg).argTypeListVal).args)
{
{


#line 346 "diagnostic.cog"
     if(

#line 346 "diagnostic.cog"
        

#line 346 "diagnostic.cog"
        !

#line 346 "diagnostic.cog"
         first)
{


#line 346 "diagnostic.cog"
                       

#line 346 "diagnostic.cog"
                       

#line 346 "diagnostic.cog"
                fprintf(

#line 346 "diagnostic.cog"
                        stderr, 

#line 346 "diagnostic.cog"
                                ", ");
}


#line 347 "diagnostic.cog"
              

#line 347 "diagnostic.cog"
              

#line 347 "diagnostic.cog"
     printType(

#line 347 "diagnostic.cog"
               stderr, 

#line 347 "diagnostic.cog"
                             DEREF(

#line 347 "diagnostic.cog"
                         DEREF(

#line 347 "diagnostic.cog"
                       aa).exp).type);


#line 348 "diagnostic.cog"
     first = 

#line 348 "diagnostic.cog"
             false;
}
}
}
}
{


#line 351 "diagnostic.cog"
   break;
}
case 

#line 353 "diagnostic.cog"
       kFlavor_DeclRef:
{
{


#line 355 "diagnostic.cog"
                

#line 355 "diagnostic.cog"
                

#line 355 "diagnostic.cog"
    printDeclRef(

#line 355 "diagnostic.cog"
                 stderr, 

#line 355 "diagnostic.cog"
                            DEREF(

#line 355 "diagnostic.cog"
                         arg).declRefVal);
}
}
{


#line 357 "diagnostic.cog"
   break;
}
default:
{


#line 360 "diagnostic.cog"
          

#line 360 "diagnostic.cog"
          

#line 360 "diagnostic.cog"
   fprintf(

#line 360 "diagnostic.cog"
           stderr, 

#line 360 "diagnostic.cog"
                   "UNIMPLEMENTD:%d", 

#line 360 "diagnostic.cog"
                                         DEREF(

#line 360 "diagnostic.cog"
                                      arg).flavor);
}
{


#line 362 "diagnostic.cog"
   break;
}
}
}


#line 366 "diagnostic.cog"
 void diagnoseImpl(

#line 367 "diagnostic.cog"
           

#line 367 "diagnostic.cog"
        Ptr<

#line 367 "diagnostic.cog"
            DiagnosticSink>  sink, 

#line 368 "diagnostic.cog"
       SourceLoc loc, 

#line 369 "diagnostic.cog"
      DiagnosticID id, 

#line 370 "diagnostic.cog"
            int argCount, 

#line 371 "diagnostic.cog"
           

#line 371 "diagnostic.cog"
        Ptr<

#line 371 "diagnostic.cog"
               

#line 371 "diagnostic.cog"
            Ptr<

#line 371 "diagnostic.cog"
                DiagnosticArg> >  args)
{


#line 375 "diagnostic.cog"
  

#line 375 "diagnostic.cog"
  auto expandedLoc = 

#line 375 "diagnostic.cog"
                             

#line 375 "diagnostic.cog"
                    expandLoc(

#line 375 "diagnostic.cog"
                                  DEREF(

#line 375 "diagnostic.cog"
                              sink).session, 

#line 375 "diagnostic.cog"
                                            loc);


#line 377 "diagnostic.cog"
  

#line 377 "diagnostic.cog"
  auto severity = 

#line 377 "diagnostic.cog"
                 kSeverity_Error;


#line 379 "diagnostic.cog"
         

#line 379 "diagnostic.cog"
         

#line 379 "diagnostic.cog"
  fprintf(

#line 379 "diagnostic.cog"
          stderr, 

#line 379 "diagnostic.cog"
                  "%s(%ld,%ld): %s: ", 

#line 380 "diagnostic.cog"
                    DEREF(

#line 380 "diagnostic.cog"
               DEREF(

#line 380 "diagnostic.cog"
    expandedLoc).file).begin, 

#line 381 "diagnostic.cog"
               DEREF(

#line 381 "diagnostic.cog"
    expandedLoc).line, 

#line 382 "diagnostic.cog"
               DEREF(

#line 382 "diagnostic.cog"
    expandedLoc).column, 

#line 383 "diagnostic.cog"
    "error");


#line 387 "diagnostic.cog"
         

#line 387 "diagnostic.cog"
         

#line 387 "diagnostic.cog"
  fprintf(

#line 387 "diagnostic.cog"
          stderr, 

#line 387 "diagnostic.cog"
                  "%d", 

#line 387 "diagnostic.cog"
                        id);


#line 389 "diagnostic.cog"
     {


#line 389 "diagnostic.cog"
         

#line 389 "diagnostic.cog"
         

#line 389 "diagnostic.cog"
                  int ii = 

#line 389 "diagnostic.cog"
                        0;
for(;

#line 389 "diagnostic.cog"
                              

#line 389 "diagnostic.cog"
                           ii 

#line 389 "diagnostic.cog"
                              < 

#line 389 "diagnostic.cog"
                                argCount;

#line 389 "diagnostic.cog"
                                            

#line 389 "diagnostic.cog"
                                          ii

#line 389 "diagnostic.cog"
                                            ++)
{
{


#line 391 "diagnostic.cog"
             

#line 391 "diagnostic.cog"
             

#line 391 "diagnostic.cog"
      fprintf(

#line 391 "diagnostic.cog"
              stderr, 

#line 391 "diagnostic.cog"
                      "[");


#line 392 "diagnostic.cog"
                        

#line 392 "diagnostic.cog"
                        

#line 392 "diagnostic.cog"
      printDiagnosticArg(

#line 392 "diagnostic.cog"
                             

#line 392 "diagnostic.cog"
                         args[

#line 392 "diagnostic.cog"
                              ii]);


#line 393 "diagnostic.cog"
             

#line 393 "diagnostic.cog"
             

#line 393 "diagnostic.cog"
      fprintf(

#line 393 "diagnostic.cog"
              stderr, 

#line 393 "diagnostic.cog"
                      "]");
}
}}


#line 396 "diagnostic.cog"
         

#line 396 "diagnostic.cog"
         

#line 396 "diagnostic.cog"
  fprintf(

#line 396 "diagnostic.cog"
          stderr, 

#line 396 "diagnostic.cog"
                  "\n");


#line 398 "diagnostic.cog"
     if(

#line 398 "diagnostic.cog"
                 

#line 398 "diagnostic.cog"
        severity 

#line 398 "diagnostic.cog"
                 >= 

#line 398 "diagnostic.cog"
                    kSeverity_Error)
{


#line 400 "diagnostic.cog"
                        

#line 400 "diagnostic.cog"
                        

#line 400 "diagnostic.cog"
             DEREF(

#line 400 "diagnostic.cog"
         sink).errorCount

#line 400 "diagnostic.cog"
                        ++;


#line 401 "diagnostic.cog"
         if(

#line 401 "diagnostic.cog"
                     

#line 401 "diagnostic.cog"
            severity 

#line 401 "diagnostic.cog"
                     >= 

#line 401 "diagnostic.cog"
                        kSeverity_Fatal)
{


#line 403 "diagnostic.cog"
                   

#line 403 "diagnostic.cog"
                   

#line 403 "diagnostic.cog"
          cogAssert(

#line 403 "diagnostic.cog"
                    

#line 403 "diagnostic.cog"
                    !

#line 403 "diagnostic.cog"
                     "fatal");


#line 404 "diagnostic.cog"
                 

#line 404 "diagnostic.cog"
                 

#line 404 "diagnostic.cog"
             exit(

#line 404 "diagnostic.cog"
                  1);
}
}
}


#line 3 "emit.cog"
 

#line 5 "emit.cog"
 

#line 12 "emit.cog"
 

#line 12 "emit.cog"
                                                      

#line 12 "emit.cog"
                                        DiagnosticSink

#line 12 "emit.cog"
                                                      * getSink(

#line 12 "emit.cog"
                                  

#line 12 "emit.cog"
                       EmitContext

#line 12 "emit.cog"
                                  * context)
{


#line 14 "emit.cog"
     return 

#line 14 "emit.cog"
            

#line 14 "emit.cog"
            &

#line 14 "emit.cog"
                            DEREF(

#line 14 "emit.cog"
                    DEREF(

#line 14 "emit.cog"
             context).session).sink;
}


#line 17 "emit.cog"
 

#line 24 "emit.cog"
 void emit(

#line 25 "emit.cog"
                      

#line 25 "emit.cog"
           EmitContext

#line 25 "emit.cog"
                      * context, 

#line 26 "emit.cog"
        StringSpan text)
{


#line 28 "emit.cog"
        

#line 28 "emit.cog"
        

#line 28 "emit.cog"
  fwrite(

#line 28 "emit.cog"
             DEREF(

#line 28 "emit.cog"
         text).begin, 

#line 28 "emit.cog"
                     1, 

#line 28 "emit.cog"
                                 

#line 28 "emit.cog"
                            DEREF(

#line 28 "emit.cog"
                        text).end 

#line 28 "emit.cog"
                                 - 

#line 28 "emit.cog"
                                       DEREF(

#line 28 "emit.cog"
                                   text).begin, 

#line 28 "emit.cog"
                                                      DEREF(

#line 28 "emit.cog"
                                               context).stream);
}


#line 31 "emit.cog"
 void emit(

#line 32 "emit.cog"
                      

#line 32 "emit.cog"
           EmitContext

#line 32 "emit.cog"
                      * context, 

#line 33 "emit.cog"
            

#line 33 "emit.cog"
        Char

#line 33 "emit.cog"
            * text)
{


#line 35 "emit.cog"
      

#line 35 "emit.cog"
      

#line 35 "emit.cog"
  emit(

#line 35 "emit.cog"
       context, 

#line 35 "emit.cog"
                                    

#line 35 "emit.cog"
                TerminatedStringSpan(

#line 35 "emit.cog"
                                     text));
}


#line 38 "emit.cog"
 void emit(

#line 39 "emit.cog"
                      

#line 39 "emit.cog"
           EmitContext

#line 39 "emit.cog"
                      * context, 

#line 40 "emit.cog"
            

#line 40 "emit.cog"
        Name

#line 40 "emit.cog"
            * name)
{


#line 42 "emit.cog"
      

#line 42 "emit.cog"
      

#line 42 "emit.cog"
  emit(

#line 42 "emit.cog"
       context, 

#line 42 "emit.cog"
                       

#line 42 "emit.cog"
                getText(

#line 42 "emit.cog"
                        name));
}


#line 45 "emit.cog"
 void emitType(

#line 46 "emit.cog"
                      

#line 46 "emit.cog"
           EmitContext

#line 46 "emit.cog"
                      * context, 

#line 47 "emit.cog"
        Exp type)
{


#line 49 "emit.cog"
     if(

#line 49 "emit.cog"
        

#line 49 "emit.cog"
        !

#line 49 "emit.cog"
         type)
{


#line 51 "emit.cog"
             

#line 51 "emit.cog"
             

#line 51 "emit.cog"
         emit(

#line 51 "emit.cog"
              context, 

#line 51 "emit.cog"
                       "NullType");


#line 52 "emit.cog"
         return;
}


#line 55 "emit.cog"
         

#line 55 "emit.cog"
         

#line 55 "emit.cog"
  emitExp(

#line 55 "emit.cog"
          context, 

#line 55 "emit.cog"
                   type);
}


#line 58 "emit.cog"
 void emitVal(

#line 59 "emit.cog"
                         

#line 59 "emit.cog"
              EmitContext

#line 59 "emit.cog"
                         * context, 

#line 60 "emit.cog"
          Val val)
{
{


#line 63 "emit.cog"
                  

#line 63 "emit.cog"
                  

#line 63 "emit.cog"
         cogAssert(

#line 63 "emit.cog"
                   

#line 63 "emit.cog"
                   !

#line 63 "emit.cog"
                    "unimplemented");


#line 64 "emit.cog"
             

#line 64 "emit.cog"
             

#line 64 "emit.cog"
         emit(

#line 64 "emit.cog"
              context, 

#line 64 "emit.cog"
                       "UnknownVal");
}
}


#line 68 "emit.cog"
 void emitGenericQuals(

#line 69 "emit.cog"
                      

#line 69 "emit.cog"
           EmitContext

#line 69 "emit.cog"
                      * context, 

#line 70 "emit.cog"
        Decl decl)
{


#line 72 "emit.cog"
  

#line 72 "emit.cog"
  auto pp = 

#line 72 "emit.cog"
               DEREF(

#line 72 "emit.cog"
           decl).parent;


#line 73 "emit.cog"
  while(

#line 73 "emit.cog"
         pp)
{
{


#line 75 "emit.cog"
   

#line 75 "emit.cog"
   auto genericParent = 

#line 75 "emit.cog"
                                      

#line 75 "emit.cog"
                         

#line 75 "emit.cog"
                       as<

#line 75 "emit.cog"
                          GenericDecl> (

#line 75 "emit.cog"
                                       pp);


#line 76 "emit.cog"
   if(

#line 76 "emit.cog"
       genericParent)
{


#line 78 "emit.cog"
        

#line 78 "emit.cog"
        

#line 78 "emit.cog"
    emit(

#line 78 "emit.cog"
         context, 

#line 78 "emit.cog"
                  "template<");


#line 79 "emit.cog"
    

#line 79 "emit.cog"
    auto first = 

#line 79 "emit.cog"
                true;


#line 80 "emit.cog"
    for(auto dd : 

#line 80 "emit.cog"
                                        

#line 80 "emit.cog"
                               DEREF(

#line 80 "emit.cog"
                  genericParent).getDecls())
{
{


#line 82 "emit.cog"
     

#line 82 "emit.cog"
     auto genericParamDecl = 

#line 82 "emit.cog"
                                                

#line 82 "emit.cog"
                              

#line 82 "emit.cog"
                            as<

#line 82 "emit.cog"
                               GenericParamDecl> (

#line 82 "emit.cog"
                                                 dd);


#line 83 "emit.cog"
     if(

#line 83 "emit.cog"
         

#line 83 "emit.cog"
         !

#line 83 "emit.cog"
          genericParamDecl)
{


#line 84 "emit.cog"
      continue;
}


#line 86 "emit.cog"
     if(

#line 86 "emit.cog"
         

#line 86 "emit.cog"
         !

#line 86 "emit.cog"
          first)
{


#line 86 "emit.cog"
                     

#line 86 "emit.cog"
                     

#line 86 "emit.cog"
                 emit(

#line 86 "emit.cog"
                      context, 

#line 86 "emit.cog"
                               ", ");
}


#line 88 "emit.cog"
         

#line 88 "emit.cog"
         

#line 88 "emit.cog"
     emit(

#line 88 "emit.cog"
          context, 

#line 88 "emit.cog"
                   "typename ");


#line 89 "emit.cog"
         

#line 89 "emit.cog"
         

#line 89 "emit.cog"
     emit(

#line 89 "emit.cog"
          context, 

#line 89 "emit.cog"
                                   DEREF(

#line 89 "emit.cog"
                   genericParamDecl).name);


#line 90 "emit.cog"
     first = 

#line 90 "emit.cog"
             false;
}
}


#line 92 "emit.cog"
        

#line 92 "emit.cog"
        

#line 92 "emit.cog"
    emit(

#line 92 "emit.cog"
         context, 

#line 92 "emit.cog"
                  " > ");
}


#line 95 "emit.cog"
   pp = 

#line 95 "emit.cog"
          DEREF(

#line 95 "emit.cog"
        pp).parent;
}
}
}


#line 99 "emit.cog"
 void emitDeclName(

#line 100 "emit.cog"
                      

#line 100 "emit.cog"
           EmitContext

#line 100 "emit.cog"
                      * context, 

#line 101 "emit.cog"
        Decl decl, 

#line 102 "emit.cog"
        DeclEmitMode mode, 

#line 103 "emit.cog"
                 Bool includeModule)
{


#line 105 "emit.cog"
  

#line 105 "emit.cog"
  auto parent = 

#line 105 "emit.cog"
                   DEREF(

#line 105 "emit.cog"
               decl).parent;


#line 107 "emit.cog"
  

#line 107 "emit.cog"
  auto genericParent = 

#line 107 "emit.cog"
                                     

#line 107 "emit.cog"
                        

#line 107 "emit.cog"
                      as<

#line 107 "emit.cog"
                         GenericDecl> (

#line 107 "emit.cog"
                                      parent);


#line 108 "emit.cog"
  if(

#line 108 "emit.cog"
      genericParent)
{


#line 110 "emit.cog"
   parent = 

#line 110 "emit.cog"
                         DEREF(

#line 110 "emit.cog"
            genericParent).parent;
}


#line 113 "emit.cog"
  

#line 113 "emit.cog"
  auto aggTypeDecl = 

#line 113 "emit.cog"
                                    

#line 113 "emit.cog"
                       

#line 113 "emit.cog"
                    as<

#line 113 "emit.cog"
                        AggTypeDecl> (

#line 113 "emit.cog"
                                     parent);


#line 114 "emit.cog"
  if(

#line 114 "emit.cog"
      aggTypeDecl)
{


#line 116 "emit.cog"
   if(

#line 116 "emit.cog"
            

#line 116 "emit.cog"
       mode 

#line 116 "emit.cog"
            == 

#line 116 "emit.cog"
               kDeclEmitMode_Full)
{


#line 118 "emit.cog"
                              

#line 118 "emit.cog"
                              

#line 118 "emit.cog"
    emitDeclNameAndGenericArgs(

#line 118 "emit.cog"
                               context, 

#line 118 "emit.cog"
                                        parent, 

#line 118 "emit.cog"
                                                mode);


#line 119 "emit.cog"
        

#line 119 "emit.cog"
        

#line 119 "emit.cog"
    emit(

#line 119 "emit.cog"
         context, 

#line 119 "emit.cog"
                  "::");
}
}
else
{


#line 122 "emit.cog"
       if(auto moduleDecl = 

#line 122 "emit.cog"
                                         

#line 122 "emit.cog"
                             

#line 122 "emit.cog"
                           as<

#line 122 "emit.cog"
                              ModuleDecl> (

#line 122 "emit.cog"
                                          parent))
{


#line 124 "emit.cog"
   if(

#line 124 "emit.cog"
      includeModule)
{


#line 126 "emit.cog"
                

#line 126 "emit.cog"
                

#line 126 "emit.cog"
    emitDeclName(

#line 126 "emit.cog"
                 context, 

#line 126 "emit.cog"
                          parent, 

#line 126 "emit.cog"
                                  mode);


#line 127 "emit.cog"
        

#line 127 "emit.cog"
        

#line 127 "emit.cog"
    emit(

#line 127 "emit.cog"
         context, 

#line 127 "emit.cog"
                  "::");
}
}
}


#line 131 "emit.cog"
  

#line 131 "emit.cog"
  auto name = 

#line 131 "emit.cog"
                 DEREF(

#line 131 "emit.cog"
             decl).name;


#line 132 "emit.cog"
  

#line 132 "emit.cog"
  auto text = 

#line 132 "emit.cog"
                          DEREF(

#line 132 "emit.cog"
                    

#line 132 "emit.cog"
             getText(

#line 132 "emit.cog"
                     name)).begin;


#line 133 "emit.cog"
  

#line 133 "emit.cog"
  auto c = 

#line 133 "emit.cog"
              

#line 133 "emit.cog"
          text[

#line 133 "emit.cog"
               0];


#line 134 "emit.cog"
  if(

#line 134 "emit.cog"
          

#line 134 "emit.cog"
      'a' 

#line 134 "emit.cog"
          <= 

#line 134 "emit.cog"
               

#line 134 "emit.cog"
             c 

#line 134 "emit.cog"
               && 

#line 134 "emit.cog"
                    

#line 134 "emit.cog"
                  c 

#line 134 "emit.cog"
                    <= 

#line 134 "emit.cog"
                       'z')
{
}
else
{


#line 135 "emit.cog"
       if(

#line 135 "emit.cog"
               

#line 135 "emit.cog"
           'A' 

#line 135 "emit.cog"
               <= 

#line 135 "emit.cog"
                    

#line 135 "emit.cog"
                  c 

#line 135 "emit.cog"
                    && 

#line 135 "emit.cog"
                         

#line 135 "emit.cog"
                       c 

#line 135 "emit.cog"
                         <= 

#line 135 "emit.cog"
                            'Z')
{
}
else
{


#line 136 "emit.cog"
       if(

#line 136 "emit.cog"
               

#line 136 "emit.cog"
           '_' 

#line 136 "emit.cog"
               == 

#line 136 "emit.cog"
                    

#line 136 "emit.cog"
                  c 

#line 136 "emit.cog"
                    || 

#line 136 "emit.cog"
                         

#line 136 "emit.cog"
                       0 

#line 136 "emit.cog"
                         == 

#line 136 "emit.cog"
                            c)
{
}
else
{


#line 139 "emit.cog"
       

#line 139 "emit.cog"
       

#line 139 "emit.cog"
   emit(

#line 139 "emit.cog"
        context, 

#line 139 "emit.cog"
                 "operator");
}
}
}


#line 141 "emit.cog"
      

#line 141 "emit.cog"
      

#line 141 "emit.cog"
  emit(

#line 141 "emit.cog"
       context, 

#line 141 "emit.cog"
                    DEREF(

#line 141 "emit.cog"
                decl).name);
}


#line 144 "emit.cog"
 void emitDeclName(

#line 145 "emit.cog"
                      

#line 145 "emit.cog"
           EmitContext

#line 145 "emit.cog"
                      * context, 

#line 146 "emit.cog"
        Decl decl, 

#line 147 "emit.cog"
        DeclEmitMode mode)
{


#line 149 "emit.cog"
              

#line 149 "emit.cog"
              

#line 149 "emit.cog"
  emitDeclName(

#line 149 "emit.cog"
               context, 

#line 149 "emit.cog"
                        decl, 

#line 149 "emit.cog"
                              mode, 

#line 149 "emit.cog"
                                    false);
}


#line 152 "emit.cog"
 void emitDeclNameAndGenericArgs(

#line 153 "emit.cog"
                      

#line 153 "emit.cog"
           EmitContext

#line 153 "emit.cog"
                      * context, 

#line 154 "emit.cog"
        Decl decl, 

#line 155 "emit.cog"
        DeclEmitMode mode)
{


#line 157 "emit.cog"
  

#line 157 "emit.cog"
  auto parent = 

#line 157 "emit.cog"
                   DEREF(

#line 157 "emit.cog"
               decl).parent;


#line 159 "emit.cog"
  

#line 159 "emit.cog"
  auto genericParent = 

#line 159 "emit.cog"
                                     

#line 159 "emit.cog"
                        

#line 159 "emit.cog"
                      as<

#line 159 "emit.cog"
                         GenericDecl> (

#line 159 "emit.cog"
                                      parent);


#line 161 "emit.cog"
              

#line 161 "emit.cog"
              

#line 161 "emit.cog"
  emitDeclName(

#line 161 "emit.cog"
               context, 

#line 161 "emit.cog"
                        decl, 

#line 161 "emit.cog"
                              mode);


#line 163 "emit.cog"
  if(auto classDecl = 

#line 163 "emit.cog"
                                  

#line 163 "emit.cog"
                       

#line 163 "emit.cog"
                     as<

#line 163 "emit.cog"
                        ClassDecl> (

#line 163 "emit.cog"
                                   decl))
{


#line 165 "emit.cog"
       

#line 165 "emit.cog"
       

#line 165 "emit.cog"
   emit(

#line 165 "emit.cog"
        context, 

#line 165 "emit.cog"
                 "Impl");
}


#line 168 "emit.cog"
  if(

#line 168 "emit.cog"
                    

#line 168 "emit.cog"
      genericParent 

#line 168 "emit.cog"
                    && 

#line 168 "emit.cog"
                       (

#line 168 "emit.cog"
                             

#line 168 "emit.cog"
                        mode 

#line 168 "emit.cog"
                             == 

#line 168 "emit.cog"
                                kDeclEmitMode_Full))
{


#line 170 "emit.cog"
       

#line 170 "emit.cog"
       

#line 170 "emit.cog"
   emit(

#line 170 "emit.cog"
        context, 

#line 170 "emit.cog"
                 "<");


#line 171 "emit.cog"
   

#line 171 "emit.cog"
   auto first = 

#line 171 "emit.cog"
               true;


#line 172 "emit.cog"
   for(auto dd : 

#line 172 "emit.cog"
                                       

#line 172 "emit.cog"
                              DEREF(

#line 172 "emit.cog"
                 genericParent).getDecls())
{
{


#line 174 "emit.cog"
    

#line 174 "emit.cog"
    auto genericParamDecl = 

#line 174 "emit.cog"
                                               

#line 174 "emit.cog"
                             

#line 174 "emit.cog"
                           as<

#line 174 "emit.cog"
                              GenericParamDecl> (

#line 174 "emit.cog"
                                                dd);


#line 175 "emit.cog"
    if(

#line 175 "emit.cog"
        

#line 175 "emit.cog"
        !

#line 175 "emit.cog"
         genericParamDecl)
{


#line 176 "emit.cog"
     continue;
}


#line 178 "emit.cog"
    if(

#line 178 "emit.cog"
        

#line 178 "emit.cog"
        !

#line 178 "emit.cog"
         first)
{


#line 178 "emit.cog"
                    

#line 178 "emit.cog"
                    

#line 178 "emit.cog"
                emit(

#line 178 "emit.cog"
                     context, 

#line 178 "emit.cog"
                              ", ");
}


#line 180 "emit.cog"
        

#line 180 "emit.cog"
        

#line 180 "emit.cog"
    emit(

#line 180 "emit.cog"
         context, 

#line 180 "emit.cog"
                                  DEREF(

#line 180 "emit.cog"
                  genericParamDecl).name);


#line 181 "emit.cog"
    first = 

#line 181 "emit.cog"
            false;
}
}


#line 183 "emit.cog"
       

#line 183 "emit.cog"
       

#line 183 "emit.cog"
   emit(

#line 183 "emit.cog"
        context, 

#line 183 "emit.cog"
                 " > ");
}
}


#line 187 "emit.cog"
 void emitDeclarator(

#line 188 "emit.cog"
                      

#line 188 "emit.cog"
           EmitContext

#line 188 "emit.cog"
                      * context, 

#line 189 "emit.cog"
        Exp type, 

#line 190 "emit.cog"
        Decl decl, 

#line 191 "emit.cog"
        DeclEmitMode mode)
{


#line 193 "emit.cog"
          

#line 193 "emit.cog"
          

#line 193 "emit.cog"
  emitType(

#line 193 "emit.cog"
           context, 

#line 193 "emit.cog"
                    type);


#line 194 "emit.cog"
      

#line 194 "emit.cog"
      

#line 194 "emit.cog"
  emit(

#line 194 "emit.cog"
       context, 

#line 194 "emit.cog"
                " ");


#line 196 "emit.cog"
              

#line 196 "emit.cog"
              

#line 196 "emit.cog"
  emitDeclName(

#line 196 "emit.cog"
               context, 

#line 196 "emit.cog"
                        decl, 

#line 196 "emit.cog"
                              mode);
}


#line 199 "emit.cog"
 void emitDeclarator(

#line 200 "emit.cog"
                      

#line 200 "emit.cog"
           EmitContext

#line 200 "emit.cog"
                      * context, 

#line 201 "emit.cog"
        TypeExp type, 

#line 202 "emit.cog"
        Decl decl, 

#line 203 "emit.cog"
        DeclEmitMode mode)
{


#line 205 "emit.cog"
                

#line 205 "emit.cog"
                

#line 205 "emit.cog"
  emitDeclarator(

#line 205 "emit.cog"
                 context, 

#line 205 "emit.cog"
                              DEREF(

#line 205 "emit.cog"
                          type).exp, 

#line 205 "emit.cog"
                                    decl, 

#line 205 "emit.cog"
                                          mode);
}


#line 210 "emit.cog"
 void emitBinaryExp(

#line 211 "emit.cog"
                         

#line 211 "emit.cog"
              EmitContext

#line 211 "emit.cog"
                         * context, 

#line 212 "emit.cog"
          AppExpBase exp, 

#line 213 "emit.cog"
             

#line 213 "emit.cog"
         Char

#line 213 "emit.cog"
             * op)
{


#line 215 "emit.cog"
            

#line 215 "emit.cog"
            

#line 215 "emit.cog"
     emitExp(

#line 215 "emit.cog"
             context, 

#line 215 "emit.cog"
                                 DEREF(

#line 215 "emit.cog"
                              

#line 215 "emit.cog"
                         DEREF(

#line 215 "emit.cog"
                      exp).args[

#line 215 "emit.cog"
                               0]).exp);


#line 216 "emit.cog"
         

#line 216 "emit.cog"
         

#line 216 "emit.cog"
     emit(

#line 216 "emit.cog"
          context, 

#line 216 "emit.cog"
                   " ");


#line 217 "emit.cog"
         

#line 217 "emit.cog"
         

#line 217 "emit.cog"
     emit(

#line 217 "emit.cog"
          context, 

#line 217 "emit.cog"
                   op);


#line 218 "emit.cog"
         

#line 218 "emit.cog"
         

#line 218 "emit.cog"
     emit(

#line 218 "emit.cog"
          context, 

#line 218 "emit.cog"
                   " ");


#line 219 "emit.cog"
            

#line 219 "emit.cog"
            

#line 219 "emit.cog"
     emitExp(

#line 219 "emit.cog"
             context, 

#line 219 "emit.cog"
                                 DEREF(

#line 219 "emit.cog"
                              

#line 219 "emit.cog"
                         DEREF(

#line 219 "emit.cog"
                      exp).args[

#line 219 "emit.cog"
                               1]).exp);
}


#line 222 "emit.cog"
 void emitStringVal(

#line 223 "emit.cog"
                         

#line 223 "emit.cog"
              EmitContext

#line 223 "emit.cog"
                         * context, 

#line 224 "emit.cog"
          StringSpan str)
{


#line 226 "emit.cog"
     

#line 226 "emit.cog"
     auto cursor = 

#line 226 "emit.cog"
                     DEREF(

#line 226 "emit.cog"
                  str).begin;


#line 227 "emit.cog"
     while(

#line 227 "emit.cog"
                  

#line 227 "emit.cog"
           cursor 

#line 227 "emit.cog"
                  != 

#line 227 "emit.cog"
                        DEREF(

#line 227 "emit.cog"
                     str).end)
{
{


#line 229 "emit.cog"
         switch(

#line 229 "emit.cog"
                

#line 229 "emit.cog"
                *

#line 229 "emit.cog"
                 cursor)
{
case 

#line 231 "emit.cog"
              '\n':
{


#line 231 "emit.cog"
                        

#line 231 "emit.cog"
                        

#line 231 "emit.cog"
                    emit(

#line 231 "emit.cog"
                         context, 

#line 231 "emit.cog"
                                  "\\n");
}
{


#line 231 "emit.cog"
                                          break;
}
case 

#line 232 "emit.cog"
        '\r':
{


#line 232 "emit.cog"
                  

#line 232 "emit.cog"
                  

#line 232 "emit.cog"
              emit(

#line 232 "emit.cog"
                   context, 

#line 232 "emit.cog"
                            "\\r");
}
{


#line 232 "emit.cog"
                                    break;
}
case 

#line 233 "emit.cog"
        '\\':
{


#line 233 "emit.cog"
                  

#line 233 "emit.cog"
                  

#line 233 "emit.cog"
              emit(

#line 233 "emit.cog"
                   context, 

#line 233 "emit.cog"
                            "\\\\");
}
{


#line 233 "emit.cog"
                                     break;
}
case 

#line 234 "emit.cog"
        '\t':
{


#line 234 "emit.cog"
                  

#line 234 "emit.cog"
                  

#line 234 "emit.cog"
              emit(

#line 234 "emit.cog"
                   context, 

#line 234 "emit.cog"
                            "\\t");
}
{


#line 234 "emit.cog"
                                    break;
}
case 

#line 235 "emit.cog"
        '\'':
{


#line 235 "emit.cog"
                  

#line 235 "emit.cog"
                  

#line 235 "emit.cog"
              emit(

#line 235 "emit.cog"
                   context, 

#line 235 "emit.cog"
                            "\\\'");
}
{


#line 235 "emit.cog"
                                     break;
}
case 

#line 236 "emit.cog"
        '\"':
{


#line 236 "emit.cog"
                  

#line 236 "emit.cog"
                  

#line 236 "emit.cog"
              emit(

#line 236 "emit.cog"
                   context, 

#line 236 "emit.cog"
                            "\\\"");
}
{


#line 236 "emit.cog"
                                     break;
}
default:
{
{


#line 240 "emit.cog"
     

#line 240 "emit.cog"
     

#line 240 "emit.cog"
                              

#line 240 "emit.cog"
                FixedSizeArray<

#line 240 "emit.cog"
                               2, 

#line 240 "emit.cog"
                                  Char>  text;


#line 241 "emit.cog"
         

#line 241 "emit.cog"
     text[

#line 241 "emit.cog"
          0] = 

#line 241 "emit.cog"
               

#line 241 "emit.cog"
               *

#line 241 "emit.cog"
                cursor;


#line 242 "emit.cog"
         

#line 242 "emit.cog"
     text[

#line 242 "emit.cog"
          1] = 

#line 242 "emit.cog"
               0;


#line 244 "emit.cog"
                     

#line 244 "emit.cog"
                     

#line 244 "emit.cog"
                 emit(

#line 244 "emit.cog"
                      context, 

#line 244 "emit.cog"
                               text);
}
}
{


#line 246 "emit.cog"
             break;
}
}


#line 248 "emit.cog"
               

#line 248 "emit.cog"
               

#line 248 "emit.cog"
         cursor

#line 248 "emit.cog"
               ++;
}
}
}


#line 252 "emit.cog"
 void emitStringVal(

#line 253 "emit.cog"
                         

#line 253 "emit.cog"
              EmitContext

#line 253 "emit.cog"
                         * context, 

#line 254 "emit.cog"
          String str)
{


#line 256 "emit.cog"
  

#line 256 "emit.cog"
  auto strSpan = 

#line 256 "emit.cog"
                          

#line 256 "emit.cog"
                   DEREF(

#line 256 "emit.cog"
                str).asSpan();


#line 257 "emit.cog"
               

#line 257 "emit.cog"
               

#line 257 "emit.cog"
  emitStringVal(

#line 257 "emit.cog"
                context, 

#line 257 "emit.cog"
                                   

#line 257 "emit.cog"
                         StringSpan(

#line 257 "emit.cog"
                                           DEREF(

#line 257 "emit.cog"
                                    strSpan).begin, 

#line 257 "emit.cog"
                                                          DEREF(

#line 257 "emit.cog"
                                                   strSpan).end));
}


#line 260 "emit.cog"
 void emitExp(

#line 261 "emit.cog"
                         

#line 261 "emit.cog"
              EmitContext

#line 261 "emit.cog"
                         * context, 

#line 262 "emit.cog"
       Exp exp)
{


#line 264 "emit.cog"
                   

#line 264 "emit.cog"
                   

#line 264 "emit.cog"
  emitLineDirective(

#line 264 "emit.cog"
                    context, 

#line 264 "emit.cog"
                             exp);


#line 266 "emit.cog"
  if(auto nameExp = 

#line 266 "emit.cog"
                               

#line 266 "emit.cog"
                      

#line 266 "emit.cog"
                    as<

#line 266 "emit.cog"
                       NameExp> (

#line 266 "emit.cog"
                                exp))
{


#line 268 "emit.cog"
       

#line 268 "emit.cog"
       

#line 268 "emit.cog"
   emit(

#line 268 "emit.cog"
        context, 

#line 268 "emit.cog"
                        DEREF(

#line 268 "emit.cog"
                 nameExp).name);
}
else
{


#line 270 "emit.cog"
       if(auto memberExpr = 

#line 270 "emit.cog"
                                         

#line 270 "emit.cog"
                              

#line 270 "emit.cog"
                            as<

#line 270 "emit.cog"
                               MemberExp> (

#line 270 "emit.cog"
                                          exp))
{


#line 272 "emit.cog"
       

#line 272 "emit.cog"
       

#line 272 "emit.cog"
   emit(

#line 272 "emit.cog"
        context, 

#line 272 "emit.cog"
                 "DEREF(");


#line 273 "emit.cog"
          

#line 273 "emit.cog"
          

#line 273 "emit.cog"
   emitExp(

#line 273 "emit.cog"
           context, 

#line 273 "emit.cog"
                              DEREF(

#line 273 "emit.cog"
                    memberExpr).base);


#line 274 "emit.cog"
       

#line 274 "emit.cog"
       

#line 274 "emit.cog"
   emit(

#line 274 "emit.cog"
        context, 

#line 274 "emit.cog"
                 ")");


#line 275 "emit.cog"
       

#line 275 "emit.cog"
       

#line 275 "emit.cog"
   emit(

#line 275 "emit.cog"
        context, 

#line 275 "emit.cog"
                 ".");


#line 276 "emit.cog"
       

#line 276 "emit.cog"
       

#line 276 "emit.cog"
   emit(

#line 276 "emit.cog"
        context, 

#line 276 "emit.cog"
                           DEREF(

#line 276 "emit.cog"
                 memberExpr).memberName);
}
else
{


#line 278 "emit.cog"
       if(auto parenExpr = 

#line 278 "emit.cog"
                                       

#line 278 "emit.cog"
                             

#line 278 "emit.cog"
                           as<

#line 278 "emit.cog"
                              ParenExp> (

#line 278 "emit.cog"
                                        exp))
{


#line 280 "emit.cog"
       

#line 280 "emit.cog"
       

#line 280 "emit.cog"
   emit(

#line 280 "emit.cog"
        context, 

#line 280 "emit.cog"
                 "(");


#line 281 "emit.cog"
          

#line 281 "emit.cog"
          

#line 281 "emit.cog"
   emitExp(

#line 281 "emit.cog"
           context, 

#line 281 "emit.cog"
                             DEREF(

#line 281 "emit.cog"
                    parenExpr).base);


#line 282 "emit.cog"
       

#line 282 "emit.cog"
       

#line 282 "emit.cog"
   emit(

#line 282 "emit.cog"
        context, 

#line 282 "emit.cog"
                 ")");
}
else
{


#line 284 "emit.cog"
       if(auto genericAppExp = 

#line 284 "emit.cog"
                                                

#line 284 "emit.cog"
                                 

#line 284 "emit.cog"
                               as<

#line 284 "emit.cog"
                                  GenericAppExp> (

#line 284 "emit.cog"
                                                 exp))
{


#line 286 "emit.cog"
          

#line 286 "emit.cog"
          

#line 286 "emit.cog"
   emitExp(

#line 286 "emit.cog"
           context, 

#line 286 "emit.cog"
                                 DEREF(

#line 286 "emit.cog"
                    genericAppExp).base);


#line 287 "emit.cog"
       

#line 287 "emit.cog"
       

#line 287 "emit.cog"
   emit(

#line 287 "emit.cog"
        context, 

#line 287 "emit.cog"
                 "<");


#line 288 "emit.cog"
   

#line 288 "emit.cog"
   auto first = 

#line 288 "emit.cog"
               true;


#line 289 "emit.cog"
   for(auto arg : 

#line 289 "emit.cog"
                               DEREF(

#line 289 "emit.cog"
                  genericAppExp).args)
{
{


#line 291 "emit.cog"
    if(

#line 291 "emit.cog"
        

#line 291 "emit.cog"
        !

#line 291 "emit.cog"
         first)
{


#line 291 "emit.cog"
                    

#line 291 "emit.cog"
                    

#line 291 "emit.cog"
                emit(

#line 291 "emit.cog"
                     context, 

#line 291 "emit.cog"
                              ", ");
}


#line 292 "emit.cog"
           

#line 292 "emit.cog"
           

#line 292 "emit.cog"
    emitExp(

#line 292 "emit.cog"
            context, 

#line 292 "emit.cog"
                        DEREF(

#line 292 "emit.cog"
                     arg).exp);


#line 293 "emit.cog"
    first = 

#line 293 "emit.cog"
            false;
}
}


#line 295 "emit.cog"
       

#line 295 "emit.cog"
       

#line 295 "emit.cog"
   emit(

#line 295 "emit.cog"
        context, 

#line 295 "emit.cog"
                 "> ");
}
else
{


#line 297 "emit.cog"
       if(auto infixExp = 

#line 297 "emit.cog"
                                      

#line 297 "emit.cog"
                            

#line 297 "emit.cog"
                          as<

#line 297 "emit.cog"
                             InfixExp> (

#line 297 "emit.cog"
                                       exp))
{


#line 299 "emit.cog"
          

#line 299 "emit.cog"
          

#line 299 "emit.cog"
   emitExp(

#line 299 "emit.cog"
           context, 

#line 299 "emit.cog"
                                    DEREF(

#line 299 "emit.cog"
                                 

#line 299 "emit.cog"
                            DEREF(

#line 299 "emit.cog"
                    infixExp).args[

#line 299 "emit.cog"
                                  0]).exp);


#line 300 "emit.cog"
       

#line 300 "emit.cog"
       

#line 300 "emit.cog"
   emit(

#line 300 "emit.cog"
        context, 

#line 300 "emit.cog"
                 " ");


#line 301 "emit.cog"
          

#line 301 "emit.cog"
          

#line 301 "emit.cog"
   emitExp(

#line 301 "emit.cog"
           context, 

#line 301 "emit.cog"
                            DEREF(

#line 301 "emit.cog"
                    infixExp).base);


#line 302 "emit.cog"
       

#line 302 "emit.cog"
       

#line 302 "emit.cog"
   emit(

#line 302 "emit.cog"
        context, 

#line 302 "emit.cog"
                 " ");


#line 303 "emit.cog"
          

#line 303 "emit.cog"
          

#line 303 "emit.cog"
   emitExp(

#line 303 "emit.cog"
           context, 

#line 303 "emit.cog"
                                    DEREF(

#line 303 "emit.cog"
                                 

#line 303 "emit.cog"
                            DEREF(

#line 303 "emit.cog"
                    infixExp).args[

#line 303 "emit.cog"
                                  1]).exp);
}
else
{


#line 305 "emit.cog"
       if(auto prefixExp = 

#line 305 "emit.cog"
                                        

#line 305 "emit.cog"
                             

#line 305 "emit.cog"
                           as<

#line 305 "emit.cog"
                              PrefixExp> (

#line 305 "emit.cog"
                                         exp))
{


#line 307 "emit.cog"
          

#line 307 "emit.cog"
          

#line 307 "emit.cog"
   emitExp(

#line 307 "emit.cog"
           context, 

#line 307 "emit.cog"
                             DEREF(

#line 307 "emit.cog"
                    prefixExp).base);


#line 308 "emit.cog"
          

#line 308 "emit.cog"
          

#line 308 "emit.cog"
   emitExp(

#line 308 "emit.cog"
           context, 

#line 308 "emit.cog"
                                     DEREF(

#line 308 "emit.cog"
                                  

#line 308 "emit.cog"
                             DEREF(

#line 308 "emit.cog"
                    prefixExp).args[

#line 308 "emit.cog"
                                   0]).exp);
}
else
{


#line 310 "emit.cog"
       if(auto postfixExp = 

#line 310 "emit.cog"
                                          

#line 310 "emit.cog"
                              

#line 310 "emit.cog"
                            as<

#line 310 "emit.cog"
                               PostfixExp> (

#line 310 "emit.cog"
                                           exp))
{


#line 312 "emit.cog"
          

#line 312 "emit.cog"
          

#line 312 "emit.cog"
   emitExp(

#line 312 "emit.cog"
           context, 

#line 312 "emit.cog"
                                      DEREF(

#line 312 "emit.cog"
                                   

#line 312 "emit.cog"
                              DEREF(

#line 312 "emit.cog"
                    postfixExp).args[

#line 312 "emit.cog"
                                    0]).exp);


#line 313 "emit.cog"
          

#line 313 "emit.cog"
          

#line 313 "emit.cog"
   emitExp(

#line 313 "emit.cog"
           context, 

#line 313 "emit.cog"
                              DEREF(

#line 313 "emit.cog"
                    postfixExp).base);
}
else
{


#line 315 "emit.cog"
       if(auto indexExp = 

#line 315 "emit.cog"
                                      

#line 315 "emit.cog"
                            

#line 315 "emit.cog"
                          as<

#line 315 "emit.cog"
                             IndexExp> (

#line 315 "emit.cog"
                                       exp))
{


#line 317 "emit.cog"
          

#line 317 "emit.cog"
          

#line 317 "emit.cog"
   emitExp(

#line 317 "emit.cog"
           context, 

#line 317 "emit.cog"
                            DEREF(

#line 317 "emit.cog"
                    indexExp).base);


#line 318 "emit.cog"
       

#line 318 "emit.cog"
       

#line 318 "emit.cog"
   emit(

#line 318 "emit.cog"
        context, 

#line 318 "emit.cog"
                 "[");


#line 319 "emit.cog"
   

#line 319 "emit.cog"
   auto first = 

#line 319 "emit.cog"
               true;


#line 320 "emit.cog"
   for(auto arg : 

#line 320 "emit.cog"
                          DEREF(

#line 320 "emit.cog"
                  indexExp).args)
{
{


#line 322 "emit.cog"
    if(

#line 322 "emit.cog"
        

#line 322 "emit.cog"
        !

#line 322 "emit.cog"
         first)
{


#line 322 "emit.cog"
                    

#line 322 "emit.cog"
                    

#line 322 "emit.cog"
                emit(

#line 322 "emit.cog"
                     context, 

#line 322 "emit.cog"
                              ", ");
}


#line 323 "emit.cog"
           

#line 323 "emit.cog"
           

#line 323 "emit.cog"
    emitExp(

#line 323 "emit.cog"
            context, 

#line 323 "emit.cog"
                        DEREF(

#line 323 "emit.cog"
                     arg).exp);


#line 324 "emit.cog"
    first = 

#line 324 "emit.cog"
            false;
}
}


#line 326 "emit.cog"
       

#line 326 "emit.cog"
       

#line 326 "emit.cog"
   emit(

#line 326 "emit.cog"
        context, 

#line 326 "emit.cog"
                 "]");
}
else
{


#line 328 "emit.cog"
       if(auto appExp = 

#line 328 "emit.cog"
                                     

#line 328 "emit.cog"
                         

#line 328 "emit.cog"
                       as<

#line 328 "emit.cog"
                          AppExpBase> (

#line 328 "emit.cog"
                                      exp))
{


#line 330 "emit.cog"
                

#line 330 "emit.cog"
                

#line 330 "emit.cog"
         emitExp(

#line 330 "emit.cog"
                 context, 

#line 330 "emit.cog"
                                DEREF(

#line 330 "emit.cog"
                          appExp).base);


#line 331 "emit.cog"
             

#line 331 "emit.cog"
             

#line 331 "emit.cog"
         emit(

#line 331 "emit.cog"
              context, 

#line 331 "emit.cog"
                       "(");


#line 332 "emit.cog"
         

#line 332 "emit.cog"
         auto first = 

#line 332 "emit.cog"
                     true;


#line 333 "emit.cog"
         for(auto arg : 

#line 333 "emit.cog"
                              DEREF(

#line 333 "emit.cog"
                        appExp).args)
{
{


#line 335 "emit.cog"
             if(

#line 335 "emit.cog"
                

#line 335 "emit.cog"
                !

#line 335 "emit.cog"
                 first)
{


#line 335 "emit.cog"
                            

#line 335 "emit.cog"
                            

#line 335 "emit.cog"
                        emit(

#line 335 "emit.cog"
                             context, 

#line 335 "emit.cog"
                                      ", ");
}


#line 336 "emit.cog"
                    

#line 336 "emit.cog"
                    

#line 336 "emit.cog"
             emitExp(

#line 336 "emit.cog"
                     context, 

#line 336 "emit.cog"
                                 DEREF(

#line 336 "emit.cog"
                              arg).exp);


#line 337 "emit.cog"
             first = 

#line 337 "emit.cog"
                     false;
}
}


#line 339 "emit.cog"
             

#line 339 "emit.cog"
             

#line 339 "emit.cog"
         emit(

#line 339 "emit.cog"
              context, 

#line 339 "emit.cog"
                       ")");
}
else
{


#line 341 "emit.cog"
          if(auto assignExp = 

#line 341 "emit.cog"
                                          

#line 341 "emit.cog"
                               

#line 341 "emit.cog"
                             as<

#line 341 "emit.cog"
                                AssignExp> (

#line 341 "emit.cog"
                                           exp))
{


#line 343 "emit.cog"
                

#line 343 "emit.cog"
                

#line 343 "emit.cog"
         emitExp(

#line 343 "emit.cog"
                 context, 

#line 343 "emit.cog"
                                   DEREF(

#line 343 "emit.cog"
                          assignExp).left);


#line 344 "emit.cog"
             

#line 344 "emit.cog"
             

#line 344 "emit.cog"
         emit(

#line 344 "emit.cog"
              context, 

#line 344 "emit.cog"
                       " = ");


#line 345 "emit.cog"
                

#line 345 "emit.cog"
                

#line 345 "emit.cog"
         emitExp(

#line 345 "emit.cog"
                 context, 

#line 345 "emit.cog"
                                   DEREF(

#line 345 "emit.cog"
                          assignExp).right);
}
else
{


#line 347 "emit.cog"
          if(auto intLitExp = 

#line 347 "emit.cog"
                                          

#line 347 "emit.cog"
                               

#line 347 "emit.cog"
                             as<

#line 347 "emit.cog"
                                IntLitExp> (

#line 347 "emit.cog"
                                           exp))
{


#line 350 "emit.cog"
   

#line 350 "emit.cog"
   

#line 350 "emit.cog"
                              

#line 350 "emit.cog"
                FixedSizeArray<

#line 350 "emit.cog"
                               16, 

#line 350 "emit.cog"
                                  Char>  buffer;


#line 351 "emit.cog"
                

#line 351 "emit.cog"
                

#line 351 "emit.cog"
         sprintf(

#line 351 "emit.cog"
                 buffer, 

#line 351 "emit.cog"
                         "%lld", 

#line 351 "emit.cog"
                                          DEREF(

#line 351 "emit.cog"
                                 intLitExp).val);


#line 352 "emit.cog"
             

#line 352 "emit.cog"
             

#line 352 "emit.cog"
         emit(

#line 352 "emit.cog"
              context, 

#line 352 "emit.cog"
                       buffer);
}
else
{


#line 354 "emit.cog"
          if(auto strLitExp = 

#line 354 "emit.cog"
                                             

#line 354 "emit.cog"
                               

#line 354 "emit.cog"
                             as<

#line 354 "emit.cog"
                                StringLitExp> (

#line 354 "emit.cog"
                                              exp))
{


#line 356 "emit.cog"
             

#line 356 "emit.cog"
             

#line 356 "emit.cog"
         emit(

#line 356 "emit.cog"
              context, 

#line 356 "emit.cog"
                       "\"");


#line 357 "emit.cog"
                      

#line 357 "emit.cog"
                      

#line 357 "emit.cog"
         emitStringVal(

#line 357 "emit.cog"
                       context, 

#line 357 "emit.cog"
                                         DEREF(

#line 357 "emit.cog"
                                strLitExp).val);


#line 358 "emit.cog"
             

#line 358 "emit.cog"
             

#line 358 "emit.cog"
         emit(

#line 358 "emit.cog"
              context, 

#line 358 "emit.cog"
                       "\"");
}
else
{


#line 360 "emit.cog"
          if(auto charLitExp = 

#line 360 "emit.cog"
                                                 

#line 360 "emit.cog"
                                

#line 360 "emit.cog"
                              as<

#line 360 "emit.cog"
                                 CharacterLitExp> (

#line 360 "emit.cog"
                                                  exp))
{


#line 362 "emit.cog"
             

#line 362 "emit.cog"
             

#line 362 "emit.cog"
         emit(

#line 362 "emit.cog"
              context, 

#line 362 "emit.cog"
                       "\'");


#line 363 "emit.cog"
                      

#line 363 "emit.cog"
                      

#line 363 "emit.cog"
         emitStringVal(

#line 363 "emit.cog"
                       context, 

#line 363 "emit.cog"
                                          DEREF(

#line 363 "emit.cog"
                                charLitExp).val);


#line 364 "emit.cog"
             

#line 364 "emit.cog"
             

#line 364 "emit.cog"
         emit(

#line 364 "emit.cog"
              context, 

#line 364 "emit.cog"
                       "\'");
}
else
{


#line 366 "emit.cog"
          if(auto thisExpr = 

#line 366 "emit.cog"
                                        

#line 366 "emit.cog"
                              

#line 366 "emit.cog"
                            as<

#line 366 "emit.cog"
                               ThisExpr> (

#line 366 "emit.cog"
                                         exp))
{


#line 368 "emit.cog"
             

#line 368 "emit.cog"
             

#line 368 "emit.cog"
         emit(

#line 368 "emit.cog"
              context, 

#line 368 "emit.cog"
                       "this");
}
else
{


#line 370 "emit.cog"
          if(auto nullLitExpr = 

#line 370 "emit.cog"
                                              

#line 370 "emit.cog"
                                 

#line 370 "emit.cog"
                               as<

#line 370 "emit.cog"
                                  NullLitExpr> (

#line 370 "emit.cog"
                                               exp))
{


#line 372 "emit.cog"
             

#line 372 "emit.cog"
             

#line 372 "emit.cog"
         emit(

#line 372 "emit.cog"
              context, 

#line 372 "emit.cog"
                       "nullptr");
}
else
{


#line 374 "emit.cog"
          if(auto castExpr = 

#line 374 "emit.cog"
                                        

#line 374 "emit.cog"
                              

#line 374 "emit.cog"
                            as<

#line 374 "emit.cog"
                               CastExpr> (

#line 374 "emit.cog"
                                         exp))
{


#line 376 "emit.cog"
             

#line 376 "emit.cog"
             

#line 376 "emit.cog"
         emit(

#line 376 "emit.cog"
              context, 

#line 376 "emit.cog"
                       "cast<");


#line 377 "emit.cog"
           

#line 377 "emit.cog"
           

#line 377 "emit.cog"
   emitType(

#line 377 "emit.cog"
            context, 

#line 377 "emit.cog"
                                    DEREF(

#line 377 "emit.cog"
                             DEREF(

#line 377 "emit.cog"
                     castExpr).toType).exp);


#line 378 "emit.cog"
             

#line 378 "emit.cog"
             

#line 378 "emit.cog"
         emit(

#line 378 "emit.cog"
              context, 

#line 378 "emit.cog"
                       ">(");


#line 379 "emit.cog"
          

#line 379 "emit.cog"
          

#line 379 "emit.cog"
   emitExp(

#line 379 "emit.cog"
           context, 

#line 379 "emit.cog"
                            DEREF(

#line 379 "emit.cog"
                    castExpr).arg);


#line 380 "emit.cog"
             

#line 380 "emit.cog"
             

#line 380 "emit.cog"
         emit(

#line 380 "emit.cog"
              context, 

#line 380 "emit.cog"
                       ")");
}
else
{


#line 384 "emit.cog"
                 

#line 384 "emit.cog"
                 

#line 384 "emit.cog"
         diagnose(

#line 384 "emit.cog"
                         

#line 384 "emit.cog"
                  getSink(

#line 384 "emit.cog"
                          context), 

#line 384 "emit.cog"
                                       DEREF(

#line 384 "emit.cog"
                                    exp).loc, 

#line 384 "emit.cog"
                                             kDiagnostic_unimplemented, 

#line 384 "emit.cog"
                                                                                       DEREF(

#line 384 "emit.cog"
                                                                           DEREF(

#line 384 "emit.cog"
                                                                        exp).directClass).name);


#line 385 "emit.cog"
                  

#line 385 "emit.cog"
                  

#line 385 "emit.cog"
         cogAssert(

#line 385 "emit.cog"
                   

#line 385 "emit.cog"
                   !

#line 385 "emit.cog"
                    "unimplemented");
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}


#line 392 "emit.cog"
 void emitBlockStmt(

#line 393 "emit.cog"
                      

#line 393 "emit.cog"
           EmitContext

#line 393 "emit.cog"
                      * context, 

#line 394 "emit.cog"
        BlockStmt stmt)
{


#line 396 "emit.cog"
      

#line 396 "emit.cog"
      

#line 396 "emit.cog"
  emit(

#line 396 "emit.cog"
       context, 

#line 396 "emit.cog"
                "{\n");


#line 397 "emit.cog"
  for(auto stmt : 

#line 397 "emit.cog"
                               

#line 397 "emit.cog"
                      DEREF(

#line 397 "emit.cog"
                  stmt).getStmts())
{
{


#line 399 "emit.cog"
           

#line 399 "emit.cog"
           

#line 399 "emit.cog"
   emitStmt(

#line 399 "emit.cog"
            context, 

#line 399 "emit.cog"
                     stmt);
}
}


#line 401 "emit.cog"
      

#line 401 "emit.cog"
      

#line 401 "emit.cog"
  emit(

#line 401 "emit.cog"
       context, 

#line 401 "emit.cog"
                "}\n");
}


#line 404 "emit.cog"
 void emitBlockStmt(

#line 405 "emit.cog"
                         

#line 405 "emit.cog"
              EmitContext

#line 405 "emit.cog"
                         * context, 

#line 406 "emit.cog"
        Stmt stmt)
{


#line 408 "emit.cog"
     if(auto blockStmt = 

#line 408 "emit.cog"
                                     

#line 408 "emit.cog"
                          

#line 408 "emit.cog"
                        as<

#line 408 "emit.cog"
                           BlockStmt> (

#line 408 "emit.cog"
                                      stmt))
{


#line 410 "emit.cog"
                      

#line 410 "emit.cog"
                      

#line 410 "emit.cog"
         emitBlockStmt(

#line 410 "emit.cog"
                       context, 

#line 410 "emit.cog"
                                blockStmt);
}
else
{


#line 414 "emit.cog"
             

#line 414 "emit.cog"
             

#line 414 "emit.cog"
         emit(

#line 414 "emit.cog"
              context, 

#line 414 "emit.cog"
                       "{\n");


#line 415 "emit.cog"
                 

#line 415 "emit.cog"
                 

#line 415 "emit.cog"
         emitStmt(

#line 415 "emit.cog"
                  context, 

#line 415 "emit.cog"
                           stmt);


#line 416 "emit.cog"
             

#line 416 "emit.cog"
             

#line 416 "emit.cog"
         emit(

#line 416 "emit.cog"
              context, 

#line 416 "emit.cog"
                       "}\n");
}
}


#line 420 "emit.cog"
 void emit(

#line 421 "emit.cog"
                      

#line 421 "emit.cog"
           EmitContext

#line 421 "emit.cog"
                      * context, 

#line 422 "emit.cog"
         Int value)
{


#line 424 "emit.cog"
  

#line 424 "emit.cog"
  

#line 424 "emit.cog"
                             

#line 424 "emit.cog"
               FixedSizeArray<

#line 424 "emit.cog"
                              32, 

#line 424 "emit.cog"
                                 Char>  buffer;


#line 425 "emit.cog"
         

#line 425 "emit.cog"
         

#line 425 "emit.cog"
  sprintf(

#line 425 "emit.cog"
          buffer, 

#line 425 "emit.cog"
                  "%lld", 

#line 425 "emit.cog"
                               

#line 425 "emit.cog"
                          Int64(

#line 425 "emit.cog"
                                value));


#line 426 "emit.cog"
      

#line 426 "emit.cog"
      

#line 426 "emit.cog"
  emit(

#line 426 "emit.cog"
       context, 

#line 426 "emit.cog"
                buffer);
}


#line 429 "emit.cog"
 void emitLineDirective(

#line 430 "emit.cog"
                      

#line 430 "emit.cog"
           EmitContext

#line 430 "emit.cog"
                      * context, 

#line 431 "emit.cog"
       Syntax syn)
{


#line 433 "emit.cog"
  if(

#line 433 "emit.cog"
                                   

#line 433 "emit.cog"
            DEREF(

#line 433 "emit.cog"
     context).suppressLineDirective 

#line 433 "emit.cog"
                                   > 

#line 433 "emit.cog"
                                     0)
{


#line 434 "emit.cog"
   return;
}


#line 436 "emit.cog"
  

#line 436 "emit.cog"
  auto loc = 

#line 436 "emit.cog"
               DEREF(

#line 436 "emit.cog"
            syn).loc;


#line 437 "emit.cog"
  if(

#line 437 "emit.cog"
     

#line 437 "emit.cog"
     !

#line 437 "emit.cog"
         DEREF(

#line 437 "emit.cog"
      loc).raw)
{


#line 438 "emit.cog"
   return;
}


#line 440 "emit.cog"
  

#line 440 "emit.cog"
  auto expandedLoc = 

#line 440 "emit.cog"
                             

#line 440 "emit.cog"
                    expandLoc(

#line 440 "emit.cog"
                                     DEREF(

#line 440 "emit.cog"
                              context).session, 

#line 440 "emit.cog"
                                               loc);


#line 444 "emit.cog"
      

#line 444 "emit.cog"
      

#line 444 "emit.cog"
  emit(

#line 444 "emit.cog"
       context, 

#line 444 "emit.cog"
                "\n\n#line ");


#line 445 "emit.cog"
      

#line 445 "emit.cog"
      

#line 445 "emit.cog"
  emit(

#line 445 "emit.cog"
       context, 

#line 445 "emit.cog"
                           DEREF(

#line 445 "emit.cog"
                expandedLoc).line);


#line 446 "emit.cog"
      

#line 446 "emit.cog"
      

#line 446 "emit.cog"
  emit(

#line 446 "emit.cog"
       context, 

#line 446 "emit.cog"
                " \"");


#line 447 "emit.cog"
      

#line 447 "emit.cog"
      

#line 447 "emit.cog"
  emit(

#line 447 "emit.cog"
       context, 

#line 447 "emit.cog"
                           DEREF(

#line 447 "emit.cog"
                expandedLoc).file);


#line 448 "emit.cog"
      

#line 448 "emit.cog"
      

#line 448 "emit.cog"
  emit(

#line 448 "emit.cog"
       context, 

#line 448 "emit.cog"
                "\"\n");


#line 451 "emit.cog"
  {


#line 451 "emit.cog"
      

#line 451 "emit.cog"
      

#line 451 "emit.cog"
               Int ii = 

#line 451 "emit.cog"
                     0;
for(;

#line 451 "emit.cog"
                           

#line 451 "emit.cog"
                        ii 

#line 451 "emit.cog"
                           < 

#line 451 "emit.cog"
                                        DEREF(

#line 451 "emit.cog"
                             expandedLoc).column;

#line 451 "emit.cog"
                                                 

#line 451 "emit.cog"
                                                 ++

#line 451 "emit.cog"
                                                   ii)
{
{


#line 453 "emit.cog"
       

#line 453 "emit.cog"
       

#line 453 "emit.cog"
   emit(

#line 453 "emit.cog"
        context, 

#line 453 "emit.cog"
                 " ");
}
}}
}


#line 457 "emit.cog"
 void emitStmt(

#line 458 "emit.cog"
                      

#line 458 "emit.cog"
           EmitContext

#line 458 "emit.cog"
                      * context, 

#line 459 "emit.cog"
        Stmt stmt)
{


#line 461 "emit.cog"
                   

#line 461 "emit.cog"
                   

#line 461 "emit.cog"
  emitLineDirective(

#line 461 "emit.cog"
                    context, 

#line 461 "emit.cog"
                             stmt);


#line 463 "emit.cog"
  if(auto blockStmt = 

#line 463 "emit.cog"
                                  

#line 463 "emit.cog"
                       

#line 463 "emit.cog"
                     as<

#line 463 "emit.cog"
                        BlockStmt> (

#line 463 "emit.cog"
                                   stmt))
{


#line 465 "emit.cog"
                

#line 465 "emit.cog"
                

#line 465 "emit.cog"
   emitBlockStmt(

#line 465 "emit.cog"
                 context, 

#line 465 "emit.cog"
                          blockStmt);
}
else
{


#line 467 "emit.cog"
          if(auto exp = 

#line 467 "emit.cog"
                              

#line 467 "emit.cog"
                         

#line 467 "emit.cog"
                       as<

#line 467 "emit.cog"
                          Exp> (

#line 467 "emit.cog"
                               stmt))
{


#line 469 "emit.cog"
                

#line 469 "emit.cog"
                

#line 469 "emit.cog"
         emitExp(

#line 469 "emit.cog"
                 context, 

#line 469 "emit.cog"
                          exp);


#line 470 "emit.cog"
             

#line 470 "emit.cog"
             

#line 470 "emit.cog"
         emit(

#line 470 "emit.cog"
              context, 

#line 470 "emit.cog"
                       ";\n");
}
else
{


#line 472 "emit.cog"
          if(auto whileStmt = 

#line 472 "emit.cog"
                                          

#line 472 "emit.cog"
                               

#line 472 "emit.cog"
                             as<

#line 472 "emit.cog"
                                WhileStmt> (

#line 472 "emit.cog"
                                           stmt))
{


#line 474 "emit.cog"
             

#line 474 "emit.cog"
             

#line 474 "emit.cog"
         emit(

#line 474 "emit.cog"
              context, 

#line 474 "emit.cog"
                       "while(");


#line 475 "emit.cog"
                

#line 475 "emit.cog"
                

#line 475 "emit.cog"
         emitExp(

#line 475 "emit.cog"
                 context, 

#line 475 "emit.cog"
                                   DEREF(

#line 475 "emit.cog"
                          whileStmt).condition);


#line 476 "emit.cog"
             

#line 476 "emit.cog"
             

#line 476 "emit.cog"
         emit(

#line 476 "emit.cog"
              context, 

#line 476 "emit.cog"
                       ")\n{\n");


#line 477 "emit.cog"
                 

#line 477 "emit.cog"
                 

#line 477 "emit.cog"
         emitStmt(

#line 477 "emit.cog"
                  context, 

#line 477 "emit.cog"
                                    DEREF(

#line 477 "emit.cog"
                           whileStmt).body);


#line 478 "emit.cog"
             

#line 478 "emit.cog"
             

#line 478 "emit.cog"
         emit(

#line 478 "emit.cog"
              context, 

#line 478 "emit.cog"
                       "}\n");
}
else
{


#line 480 "emit.cog"
       if(auto forEachStmt = 

#line 480 "emit.cog"
                                            

#line 480 "emit.cog"
                               

#line 480 "emit.cog"
                             as<

#line 480 "emit.cog"
                                ForEachStmt> (

#line 480 "emit.cog"
                                             stmt))
{


#line 482 "emit.cog"
       

#line 482 "emit.cog"
       

#line 482 "emit.cog"
   emit(

#line 482 "emit.cog"
        context, 

#line 482 "emit.cog"
                 "for(auto ");


#line 483 "emit.cog"
       

#line 483 "emit.cog"
       

#line 483 "emit.cog"
   emit(

#line 483 "emit.cog"
        context, 

#line 483 "emit.cog"
                            DEREF(

#line 483 "emit.cog"
                 forEachStmt).name);


#line 484 "emit.cog"
       

#line 484 "emit.cog"
       

#line 484 "emit.cog"
   emit(

#line 484 "emit.cog"
        context, 

#line 484 "emit.cog"
                 " : ");


#line 485 "emit.cog"
          

#line 485 "emit.cog"
          

#line 485 "emit.cog"
   emitExp(

#line 485 "emit.cog"
           context, 

#line 485 "emit.cog"
                               DEREF(

#line 485 "emit.cog"
                    forEachStmt).exp);


#line 486 "emit.cog"
       

#line 486 "emit.cog"
       

#line 486 "emit.cog"
   emit(

#line 486 "emit.cog"
        context, 

#line 486 "emit.cog"
                 ")\n{\n");


#line 487 "emit.cog"
           

#line 487 "emit.cog"
           

#line 487 "emit.cog"
   emitStmt(

#line 487 "emit.cog"
            context, 

#line 487 "emit.cog"
                                DEREF(

#line 487 "emit.cog"
                     forEachStmt).body);


#line 488 "emit.cog"
       

#line 488 "emit.cog"
       

#line 488 "emit.cog"
   emit(

#line 488 "emit.cog"
        context, 

#line 488 "emit.cog"
                 "}\n");
}
else
{


#line 490 "emit.cog"
       if(auto forStmt = 

#line 490 "emit.cog"
                                    

#line 490 "emit.cog"
                           

#line 490 "emit.cog"
                         as<

#line 490 "emit.cog"
                            ForStmt> (

#line 490 "emit.cog"
                                     stmt))
{


#line 492 "emit.cog"
       

#line 492 "emit.cog"
       

#line 492 "emit.cog"
   emit(

#line 492 "emit.cog"
        context, 

#line 492 "emit.cog"
                 "{\n");


#line 493 "emit.cog"
   if(

#line 493 "emit.cog"
              DEREF(

#line 493 "emit.cog"
       forStmt).init)
{


#line 495 "emit.cog"
            

#line 495 "emit.cog"
            

#line 495 "emit.cog"
    emitStmt(

#line 495 "emit.cog"
             context, 

#line 495 "emit.cog"
                             DEREF(

#line 495 "emit.cog"
                      forStmt).init);
}


#line 497 "emit.cog"
       

#line 497 "emit.cog"
       

#line 497 "emit.cog"
   emit(

#line 497 "emit.cog"
        context, 

#line 497 "emit.cog"
                 "for(;");


#line 498 "emit.cog"
   if(

#line 498 "emit.cog"
              DEREF(

#line 498 "emit.cog"
       forStmt).condition)
{


#line 500 "emit.cog"
           

#line 500 "emit.cog"
           

#line 500 "emit.cog"
    emitExp(

#line 500 "emit.cog"
            context, 

#line 500 "emit.cog"
                            DEREF(

#line 500 "emit.cog"
                     forStmt).condition);
}


#line 502 "emit.cog"
       

#line 502 "emit.cog"
       

#line 502 "emit.cog"
   emit(

#line 502 "emit.cog"
        context, 

#line 502 "emit.cog"
                 ";");


#line 503 "emit.cog"
   if(

#line 503 "emit.cog"
              DEREF(

#line 503 "emit.cog"
       forStmt).iter)
{


#line 505 "emit.cog"
           

#line 505 "emit.cog"
           

#line 505 "emit.cog"
    emitExp(

#line 505 "emit.cog"
            context, 

#line 505 "emit.cog"
                            DEREF(

#line 505 "emit.cog"
                     forStmt).iter);
}


#line 507 "emit.cog"
       

#line 507 "emit.cog"
       

#line 507 "emit.cog"
   emit(

#line 507 "emit.cog"
        context, 

#line 507 "emit.cog"
                 ")\n{\n");


#line 508 "emit.cog"
           

#line 508 "emit.cog"
           

#line 508 "emit.cog"
   emitStmt(

#line 508 "emit.cog"
            context, 

#line 508 "emit.cog"
                            DEREF(

#line 508 "emit.cog"
                     forStmt).body);


#line 509 "emit.cog"
       

#line 509 "emit.cog"
       

#line 509 "emit.cog"
   emit(

#line 509 "emit.cog"
        context, 

#line 509 "emit.cog"
                 "}}\n");
}
else
{


#line 511 "emit.cog"
       if(auto switchStmt = 

#line 511 "emit.cog"
                                          

#line 511 "emit.cog"
                              

#line 511 "emit.cog"
                            as<

#line 511 "emit.cog"
                               SwitchStmt> (

#line 511 "emit.cog"
                                           stmt))
{


#line 513 "emit.cog"
       

#line 513 "emit.cog"
       

#line 513 "emit.cog"
   emit(

#line 513 "emit.cog"
        context, 

#line 513 "emit.cog"
                 "switch(");


#line 514 "emit.cog"
          

#line 514 "emit.cog"
          

#line 514 "emit.cog"
   emitExp(

#line 514 "emit.cog"
           context, 

#line 514 "emit.cog"
                              DEREF(

#line 514 "emit.cog"
                    switchStmt).condition);


#line 515 "emit.cog"
       

#line 515 "emit.cog"
       

#line 515 "emit.cog"
   emit(

#line 515 "emit.cog"
        context, 

#line 515 "emit.cog"
                 ")\n{\n");


#line 516 "emit.cog"
   for(auto cc : 

#line 516 "emit.cog"
                           DEREF(

#line 516 "emit.cog"
                 switchStmt).cases)
{
{


#line 518 "emit.cog"
    for(auto aa : 

#line 518 "emit.cog"
                    DEREF(

#line 518 "emit.cog"
                  cc).values)
{
{


#line 520 "emit.cog"
     if(

#line 520 "emit.cog"
           DEREF(

#line 520 "emit.cog"
         aa).exp)
{


#line 522 "emit.cog"
          

#line 522 "emit.cog"
          

#line 522 "emit.cog"
      emit(

#line 522 "emit.cog"
           context, 

#line 522 "emit.cog"
                    "case ");


#line 523 "emit.cog"
             

#line 523 "emit.cog"
             

#line 523 "emit.cog"
      emitExp(

#line 523 "emit.cog"
              context, 

#line 523 "emit.cog"
                         DEREF(

#line 523 "emit.cog"
                       aa).exp);
}
else
{


#line 527 "emit.cog"
          

#line 527 "emit.cog"
          

#line 527 "emit.cog"
      emit(

#line 527 "emit.cog"
           context, 

#line 527 "emit.cog"
                    "default");
}


#line 529 "emit.cog"
         

#line 529 "emit.cog"
         

#line 529 "emit.cog"
     emit(

#line 529 "emit.cog"
          context, 

#line 529 "emit.cog"
                   ":\n");
}
}


#line 531 "emit.cog"
        

#line 531 "emit.cog"
        

#line 531 "emit.cog"
    emit(

#line 531 "emit.cog"
         context, 

#line 531 "emit.cog"
                  "{\n");


#line 532 "emit.cog"
            

#line 532 "emit.cog"
            

#line 532 "emit.cog"
    emitStmt(

#line 532 "emit.cog"
             context, 

#line 532 "emit.cog"
                        DEREF(

#line 532 "emit.cog"
                      cc).body);


#line 533 "emit.cog"
        

#line 533 "emit.cog"
        

#line 533 "emit.cog"
    emit(

#line 533 "emit.cog"
         context, 

#line 533 "emit.cog"
                  "}\n");
}
}


#line 535 "emit.cog"
       

#line 535 "emit.cog"
       

#line 535 "emit.cog"
   emit(

#line 535 "emit.cog"
        context, 

#line 535 "emit.cog"
                 "}\n");
}
else
{


#line 537 "emit.cog"
       if(auto ifStmt = 

#line 537 "emit.cog"
                                 

#line 537 "emit.cog"
                         

#line 537 "emit.cog"
                       as<

#line 537 "emit.cog"
                          IfStmt> (

#line 537 "emit.cog"
                                  stmt))
{


#line 539 "emit.cog"
             

#line 539 "emit.cog"
             

#line 539 "emit.cog"
         emit(

#line 539 "emit.cog"
              context, 

#line 539 "emit.cog"
                       "if(");


#line 540 "emit.cog"
                

#line 540 "emit.cog"
                

#line 540 "emit.cog"
         emitExp(

#line 540 "emit.cog"
                 context, 

#line 540 "emit.cog"
                                DEREF(

#line 540 "emit.cog"
                          ifStmt).condition);


#line 541 "emit.cog"
             

#line 541 "emit.cog"
             

#line 541 "emit.cog"
         emit(

#line 541 "emit.cog"
              context, 

#line 541 "emit.cog"
                       ")\n");


#line 542 "emit.cog"
                      

#line 542 "emit.cog"
                      

#line 542 "emit.cog"
         emitBlockStmt(

#line 542 "emit.cog"
                       context, 

#line 542 "emit.cog"
                                      DEREF(

#line 542 "emit.cog"
                                ifStmt).thenStmt);


#line 543 "emit.cog"
         if(auto elseStmt = 

#line 543 "emit.cog"
                                 DEREF(

#line 543 "emit.cog"
                           ifStmt).elseStmt)
{


#line 545 "emit.cog"
                 

#line 545 "emit.cog"
                 

#line 545 "emit.cog"
             emit(

#line 545 "emit.cog"
                  context, 

#line 545 "emit.cog"
                           "else\n");


#line 546 "emit.cog"
                          

#line 546 "emit.cog"
                          

#line 546 "emit.cog"
             emitBlockStmt(

#line 546 "emit.cog"
                           context, 

#line 546 "emit.cog"
                                    elseStmt);
}
}
else
{


#line 549 "emit.cog"
       if(auto ifLetStmt = 

#line 549 "emit.cog"
                                       

#line 549 "emit.cog"
                            

#line 549 "emit.cog"
                          as<

#line 549 "emit.cog"
                             IfLetStmt> (

#line 549 "emit.cog"
                                        stmt))
{


#line 551 "emit.cog"
             

#line 551 "emit.cog"
             

#line 551 "emit.cog"
         emit(

#line 551 "emit.cog"
              context, 

#line 551 "emit.cog"
                       "if(auto ");


#line 552 "emit.cog"
             

#line 552 "emit.cog"
             

#line 552 "emit.cog"
         emit(

#line 552 "emit.cog"
              context, 

#line 552 "emit.cog"
                                DEREF(

#line 552 "emit.cog"
                       ifLetStmt).name);


#line 553 "emit.cog"
             

#line 553 "emit.cog"
             

#line 553 "emit.cog"
         emit(

#line 553 "emit.cog"
              context, 

#line 553 "emit.cog"
                       " = ");


#line 554 "emit.cog"
                

#line 554 "emit.cog"
                

#line 554 "emit.cog"
         emitExp(

#line 554 "emit.cog"
                 context, 

#line 554 "emit.cog"
                                   DEREF(

#line 554 "emit.cog"
                          ifLetStmt).init);


#line 555 "emit.cog"
             

#line 555 "emit.cog"
             

#line 555 "emit.cog"
         emit(

#line 555 "emit.cog"
              context, 

#line 555 "emit.cog"
                       ")\n");


#line 556 "emit.cog"
                      

#line 556 "emit.cog"
                      

#line 556 "emit.cog"
         emitBlockStmt(

#line 556 "emit.cog"
                       context, 

#line 556 "emit.cog"
                                         DEREF(

#line 556 "emit.cog"
                                ifLetStmt).thenStmt);


#line 557 "emit.cog"
         if(auto elseStmt = 

#line 557 "emit.cog"
                                    DEREF(

#line 557 "emit.cog"
                           ifLetStmt).elseStmt)
{


#line 559 "emit.cog"
                 

#line 559 "emit.cog"
                 

#line 559 "emit.cog"
             emit(

#line 559 "emit.cog"
                  context, 

#line 559 "emit.cog"
                           "else\n");


#line 560 "emit.cog"
                          

#line 560 "emit.cog"
                          

#line 560 "emit.cog"
             emitBlockStmt(

#line 560 "emit.cog"
                           context, 

#line 560 "emit.cog"
                                    elseStmt);
}
}
else
{


#line 563 "emit.cog"
          if(auto returnStmt = 

#line 563 "emit.cog"
                                            

#line 563 "emit.cog"
                                

#line 563 "emit.cog"
                              as<

#line 563 "emit.cog"
                                 ReturnStmt> (

#line 563 "emit.cog"
                                             stmt))
{


#line 565 "emit.cog"
             

#line 565 "emit.cog"
             

#line 565 "emit.cog"
         emit(

#line 565 "emit.cog"
              context, 

#line 565 "emit.cog"
                       "return");


#line 566 "emit.cog"
         if(auto value = 

#line 566 "emit.cog"
                                  DEREF(

#line 566 "emit.cog"
                        returnStmt).value)
{


#line 568 "emit.cog"
                 

#line 568 "emit.cog"
                 

#line 568 "emit.cog"
             emit(

#line 568 "emit.cog"
                  context, 

#line 568 "emit.cog"
                           " ");


#line 569 "emit.cog"
                    

#line 569 "emit.cog"
                    

#line 569 "emit.cog"
             emitExp(

#line 569 "emit.cog"
                     context, 

#line 569 "emit.cog"
                              value);
}


#line 571 "emit.cog"
             

#line 571 "emit.cog"
             

#line 571 "emit.cog"
         emit(

#line 571 "emit.cog"
              context, 

#line 571 "emit.cog"
                       ";\n");
}
else
{


#line 573 "emit.cog"
          if(auto breakStmt = 

#line 573 "emit.cog"
                                          

#line 573 "emit.cog"
                               

#line 573 "emit.cog"
                             as<

#line 573 "emit.cog"
                                BreakStmt> (

#line 573 "emit.cog"
                                           stmt))
{


#line 575 "emit.cog"
             

#line 575 "emit.cog"
             

#line 575 "emit.cog"
         emit(

#line 575 "emit.cog"
              context, 

#line 575 "emit.cog"
                       "break;\n");
}
else
{


#line 577 "emit.cog"
          if(auto continueStmt = 

#line 577 "emit.cog"
                                                

#line 577 "emit.cog"
                                  

#line 577 "emit.cog"
                                as<

#line 577 "emit.cog"
                                   ContinueStmt> (

#line 577 "emit.cog"
                                                 stmt))
{


#line 579 "emit.cog"
             

#line 579 "emit.cog"
             

#line 579 "emit.cog"
         emit(

#line 579 "emit.cog"
              context, 

#line 579 "emit.cog"
                       "continue;\n");
}
else
{


#line 581 "emit.cog"
       if(auto decl = 

#line 581 "emit.cog"
                             

#line 581 "emit.cog"
                       

#line 581 "emit.cog"
                     as<

#line 581 "emit.cog"
                        Decl> (

#line 581 "emit.cog"
                              stmt))
{


#line 583 "emit.cog"
           

#line 583 "emit.cog"
           

#line 583 "emit.cog"
   emitDecl(

#line 583 "emit.cog"
            context, 

#line 583 "emit.cog"
                     decl, 

#line 583 "emit.cog"
                           kDeclEmitMode_Full);
}
else
{


#line 587 "emit.cog"
                 

#line 587 "emit.cog"
                 

#line 587 "emit.cog"
         diagnose(

#line 587 "emit.cog"
                         

#line 587 "emit.cog"
                  getSink(

#line 587 "emit.cog"
                          context), 

#line 587 "emit.cog"
                                        DEREF(

#line 587 "emit.cog"
                                    stmt).loc, 

#line 587 "emit.cog"
                                              kDiagnostic_unimplemented, 

#line 587 "emit.cog"
                                                                                         DEREF(

#line 587 "emit.cog"
                                                                             DEREF(

#line 587 "emit.cog"
                                                                         stmt).directClass).name);


#line 588 "emit.cog"
                  

#line 588 "emit.cog"
                  

#line 588 "emit.cog"
         cogAssert(

#line 588 "emit.cog"
                   

#line 588 "emit.cog"
                   !

#line 588 "emit.cog"
                    "unimplemented");
}
}
}
}
}
}
}
}
}
}
}
}
}


#line 594 "emit.cog"
 void emitClassDecl(

#line 595 "emit.cog"
                      

#line 595 "emit.cog"
           EmitContext

#line 595 "emit.cog"
                      * context, 

#line 596 "emit.cog"
              ClassDecl aggDecl, 

#line 597 "emit.cog"
        DeclEmitMode mode)
{


#line 600 "emit.cog"
  if(

#line 600 "emit.cog"
           

#line 600 "emit.cog"
      mode 

#line 600 "emit.cog"
           == 

#line 600 "emit.cog"
              kDeclEmitMode_Full)
{


#line 602 "emit.cog"
   for(auto dd : 

#line 602 "emit.cog"
                                 

#line 602 "emit.cog"
                        DEREF(

#line 602 "emit.cog"
                 aggDecl).getDecls())
{
{


#line 604 "emit.cog"
    if(auto varDecl = 

#line 604 "emit.cog"
                                 

#line 604 "emit.cog"
                        

#line 604 "emit.cog"
                      as<

#line 604 "emit.cog"
                         VarDecl> (

#line 604 "emit.cog"
                                  dd))
{


#line 605 "emit.cog"
     continue;
}


#line 607 "emit.cog"
            

#line 607 "emit.cog"
            

#line 607 "emit.cog"
    emitDecl(

#line 607 "emit.cog"
             context, 

#line 607 "emit.cog"
                      dd, 

#line 607 "emit.cog"
                          kDeclEmitMode_Full);
}
}


#line 610 "emit.cog"
   return;
}


#line 613 "emit.cog"
      

#line 613 "emit.cog"
      

#line 613 "emit.cog"
  emit(

#line 613 "emit.cog"
       context, 

#line 613 "emit.cog"
                "using ");


#line 614 "emit.cog"
         

#line 614 "emit.cog"
         

#line 614 "emit.cog"
     emit(

#line 614 "emit.cog"
          context, 

#line 614 "emit.cog"
                          DEREF(

#line 614 "emit.cog"
                   aggDecl).name);


#line 615 "emit.cog"
         

#line 615 "emit.cog"
         

#line 615 "emit.cog"
     emit(

#line 615 "emit.cog"
          context, 

#line 615 "emit.cog"
                   " = struct ");


#line 616 "emit.cog"
         

#line 616 "emit.cog"
         

#line 616 "emit.cog"
     emit(

#line 616 "emit.cog"
          context, 

#line 616 "emit.cog"
                          DEREF(

#line 616 "emit.cog"
                   aggDecl).name);


#line 617 "emit.cog"
         

#line 617 "emit.cog"
         

#line 617 "emit.cog"
     emit(

#line 617 "emit.cog"
          context, 

#line 617 "emit.cog"
                   "Impl* ");


#line 618 "emit.cog"
         

#line 618 "emit.cog"
         

#line 618 "emit.cog"
     emit(

#line 618 "emit.cog"
          context, 

#line 618 "emit.cog"
                   ";\n");


#line 620 "emit.cog"
      

#line 620 "emit.cog"
      

#line 620 "emit.cog"
  emit(

#line 620 "emit.cog"
       context, 

#line 620 "emit.cog"
                "struct ");


#line 621 "emit.cog"
         

#line 621 "emit.cog"
         

#line 621 "emit.cog"
     emit(

#line 621 "emit.cog"
          context, 

#line 621 "emit.cog"
                          DEREF(

#line 621 "emit.cog"
                   aggDecl).name);


#line 622 "emit.cog"
      

#line 622 "emit.cog"
      

#line 622 "emit.cog"
  emit(

#line 622 "emit.cog"
       context, 

#line 622 "emit.cog"
                "Impl");


#line 624 "emit.cog"
  if(

#line 624 "emit.cog"
           

#line 624 "emit.cog"
      mode 

#line 624 "emit.cog"
           <= 

#line 624 "emit.cog"
              kDeclEmitMode_MinimalForward)
{


#line 626 "emit.cog"
       

#line 626 "emit.cog"
       

#line 626 "emit.cog"
   emit(

#line 626 "emit.cog"
        context, 

#line 626 "emit.cog"
                 ";\n");


#line 627 "emit.cog"
   return;
}


#line 630 "emit.cog"
     if(auto base = 

#line 630 "emit.cog"
                               DEREF(

#line 630 "emit.cog"
                          DEREF(

#line 630 "emit.cog"
                   aggDecl).base).exp)
{


#line 632 "emit.cog"
       

#line 632 "emit.cog"
       

#line 632 "emit.cog"
   emit(

#line 632 "emit.cog"
        context, 

#line 632 "emit.cog"
                 " : ");


#line 633 "emit.cog"
           

#line 633 "emit.cog"
           

#line 633 "emit.cog"
   emitType(

#line 633 "emit.cog"
            context, 

#line 633 "emit.cog"
                     base);


#line 634 "emit.cog"
       

#line 634 "emit.cog"
       

#line 634 "emit.cog"
   emit(

#line 634 "emit.cog"
        context, 

#line 634 "emit.cog"
                 "Impl");
}
else
{


#line 638 "emit.cog"
       

#line 638 "emit.cog"
       

#line 638 "emit.cog"
   emit(

#line 638 "emit.cog"
        context, 

#line 638 "emit.cog"
                 " : cog::ObjectImpl");
}


#line 641 "emit.cog"
      

#line 641 "emit.cog"
      

#line 641 "emit.cog"
  emit(

#line 641 "emit.cog"
       context, 

#line 641 "emit.cog"
                "\n{\n");


#line 643 "emit.cog"
      

#line 643 "emit.cog"
      

#line 643 "emit.cog"
  emit(

#line 643 "emit.cog"
       context, 

#line 643 "emit.cog"
                "typedef cog::Class StaticClass;\n");


#line 644 "emit.cog"
      

#line 644 "emit.cog"
      

#line 644 "emit.cog"
  emit(

#line 644 "emit.cog"
       context, 

#line 644 "emit.cog"
                "static StaticClass staticClass;\n");


#line 647 "emit.cog"
              

#line 647 "emit.cog"
              

#line 647 "emit.cog"
     emitDecls(

#line 647 "emit.cog"
               context, 

#line 647 "emit.cog"
                        aggDecl, 

#line 647 "emit.cog"
                                 kDeclEmitMode_Forward);


#line 648 "emit.cog"
      

#line 648 "emit.cog"
      

#line 648 "emit.cog"
  emit(

#line 648 "emit.cog"
       context, 

#line 648 "emit.cog"
                "};\n");


#line 650 "emit.cog"
      

#line 650 "emit.cog"
      

#line 650 "emit.cog"
  emit(

#line 650 "emit.cog"
       context, 

#line 650 "emit.cog"
                "} namespace cog {\n");


#line 652 "emit.cog"
      

#line 652 "emit.cog"
      

#line 652 "emit.cog"
  emit(

#line 652 "emit.cog"
       context, 

#line 652 "emit.cog"
                "template<> struct ObjectClassImpl<");


#line 653 "emit.cog"
              

#line 653 "emit.cog"
              

#line 653 "emit.cog"
  emitDeclName(

#line 653 "emit.cog"
               context, 

#line 653 "emit.cog"
                        aggDecl, 

#line 653 "emit.cog"
                                 kDeclEmitMode_Full, 

#line 653 "emit.cog"
                                                     true);


#line 654 "emit.cog"
      

#line 654 "emit.cog"
      

#line 654 "emit.cog"
  emit(

#line 654 "emit.cog"
       context, 

#line 654 "emit.cog"
                " > { typedef ");


#line 655 "emit.cog"
              

#line 655 "emit.cog"
              

#line 655 "emit.cog"
  emitDeclName(

#line 655 "emit.cog"
               context, 

#line 655 "emit.cog"
                        aggDecl, 

#line 655 "emit.cog"
                                 kDeclEmitMode_Full, 

#line 655 "emit.cog"
                                                     true);


#line 656 "emit.cog"
      

#line 656 "emit.cog"
      

#line 656 "emit.cog"
  emit(

#line 656 "emit.cog"
       context, 

#line 656 "emit.cog"
                "Impl Impl; };\n");


#line 658 "emit.cog"
      

#line 658 "emit.cog"
      

#line 658 "emit.cog"
  emit(

#line 658 "emit.cog"
       context, 

#line 658 "emit.cog"
                "} namespace ");


#line 659 "emit.cog"
      

#line 659 "emit.cog"
      

#line 659 "emit.cog"
  emit(

#line 659 "emit.cog"
       context, 

#line 659 "emit.cog"
                                          DEREF(

#line 659 "emit.cog"
                               DEREF(

#line 659 "emit.cog"
                       DEREF(

#line 659 "emit.cog"
                context).session).moduleDecl).name);


#line 660 "emit.cog"
      

#line 660 "emit.cog"
      

#line 660 "emit.cog"
  emit(

#line 660 "emit.cog"
       context, 

#line 660 "emit.cog"
                " {\n");
}


#line 664 "emit.cog"
 void emitStructDecl(

#line 665 "emit.cog"
                      

#line 665 "emit.cog"
           EmitContext

#line 665 "emit.cog"
                      * context, 

#line 666 "emit.cog"
              StructDecl aggDecl, 

#line 667 "emit.cog"
        DeclEmitMode mode)
{


#line 670 "emit.cog"
  if(

#line 670 "emit.cog"
           

#line 670 "emit.cog"
      mode 

#line 670 "emit.cog"
           == 

#line 670 "emit.cog"
              kDeclEmitMode_Full)
{


#line 672 "emit.cog"
   for(auto dd : 

#line 672 "emit.cog"
                                 

#line 672 "emit.cog"
                        DEREF(

#line 672 "emit.cog"
                 aggDecl).getDecls())
{
{


#line 674 "emit.cog"
    if(auto varDecl = 

#line 674 "emit.cog"
                                 

#line 674 "emit.cog"
                        

#line 674 "emit.cog"
                      as<

#line 674 "emit.cog"
                         VarDecl> (

#line 674 "emit.cog"
                                  dd))
{


#line 675 "emit.cog"
     continue;
}


#line 677 "emit.cog"
            

#line 677 "emit.cog"
            

#line 677 "emit.cog"
    emitDecl(

#line 677 "emit.cog"
             context, 

#line 677 "emit.cog"
                      dd, 

#line 677 "emit.cog"
                          kDeclEmitMode_Full);
}
}


#line 680 "emit.cog"
   return;
}


#line 683 "emit.cog"
      

#line 683 "emit.cog"
      

#line 683 "emit.cog"
  emit(

#line 683 "emit.cog"
       context, 

#line 683 "emit.cog"
                "struct ");


#line 684 "emit.cog"
         

#line 684 "emit.cog"
         

#line 684 "emit.cog"
     emit(

#line 684 "emit.cog"
          context, 

#line 684 "emit.cog"
                          DEREF(

#line 684 "emit.cog"
                   aggDecl).name);


#line 686 "emit.cog"
  if(

#line 686 "emit.cog"
           

#line 686 "emit.cog"
      mode 

#line 686 "emit.cog"
           <= 

#line 686 "emit.cog"
              kDeclEmitMode_MinimalForward)
{


#line 688 "emit.cog"
       

#line 688 "emit.cog"
       

#line 688 "emit.cog"
   emit(

#line 688 "emit.cog"
        context, 

#line 688 "emit.cog"
                 ";\n");


#line 689 "emit.cog"
   return;
}


#line 692 "emit.cog"
     if(auto base = 

#line 692 "emit.cog"
                               DEREF(

#line 692 "emit.cog"
                          DEREF(

#line 692 "emit.cog"
                   aggDecl).base).exp)
{


#line 694 "emit.cog"
       

#line 694 "emit.cog"
       

#line 694 "emit.cog"
   emit(

#line 694 "emit.cog"
        context, 

#line 694 "emit.cog"
                 " : ");


#line 695 "emit.cog"
           

#line 695 "emit.cog"
           

#line 695 "emit.cog"
   emitType(

#line 695 "emit.cog"
            context, 

#line 695 "emit.cog"
                     base);
}


#line 698 "emit.cog"
      

#line 698 "emit.cog"
      

#line 698 "emit.cog"
  emit(

#line 698 "emit.cog"
       context, 

#line 698 "emit.cog"
                "\n{\n");


#line 700 "emit.cog"
      

#line 700 "emit.cog"
      

#line 700 "emit.cog"
  emit(

#line 700 "emit.cog"
       context, 

#line 700 "emit.cog"
                "typedef cog::Class StaticClass;\n");


#line 701 "emit.cog"
      

#line 701 "emit.cog"
      

#line 701 "emit.cog"
  emit(

#line 701 "emit.cog"
       context, 

#line 701 "emit.cog"
                "static StaticClass staticClass;\n");


#line 704 "emit.cog"
              

#line 704 "emit.cog"
              

#line 704 "emit.cog"
     emitDecls(

#line 704 "emit.cog"
               context, 

#line 704 "emit.cog"
                        aggDecl, 

#line 704 "emit.cog"
                                 kDeclEmitMode_Forward);


#line 705 "emit.cog"
      

#line 705 "emit.cog"
      

#line 705 "emit.cog"
  emit(

#line 705 "emit.cog"
       context, 

#line 705 "emit.cog"
                "};\n");
}


#line 708 "emit.cog"
 void emitVarDecl(

#line 709 "emit.cog"
                      

#line 709 "emit.cog"
           EmitContext

#line 709 "emit.cog"
                      * context, 

#line 710 "emit.cog"
           VarDeclBase varDecl, 

#line 711 "emit.cog"
        DeclEmitMode mode)
{


#line 713 "emit.cog"
  if(

#line 713 "emit.cog"
           

#line 713 "emit.cog"
      mode 

#line 713 "emit.cog"
           == 

#line 713 "emit.cog"
              kDeclEmitMode_MinimalForward)
{


#line 714 "emit.cog"
   return;
}


#line 716 "emit.cog"
  if(auto type = 

#line 716 "emit.cog"
                             DEREF(

#line 716 "emit.cog"
                        DEREF(

#line 716 "emit.cog"
                 varDecl).type).exp)
{


#line 718 "emit.cog"
                 

#line 718 "emit.cog"
                 

#line 718 "emit.cog"
   emitDeclarator(

#line 718 "emit.cog"
                  context, 

#line 718 "emit.cog"
                           type, 

#line 718 "emit.cog"
                                 varDecl, 

#line 718 "emit.cog"
                                          mode);
}
else
{


#line 722 "emit.cog"
       

#line 722 "emit.cog"
       

#line 722 "emit.cog"
   emit(

#line 722 "emit.cog"
        context, 

#line 722 "emit.cog"
                 "auto ");


#line 723 "emit.cog"
               

#line 723 "emit.cog"
               

#line 723 "emit.cog"
   emitDeclName(

#line 723 "emit.cog"
                context, 

#line 723 "emit.cog"
                         varDecl, 

#line 723 "emit.cog"
                                  mode);
}


#line 725 "emit.cog"
     if(auto initExp = 

#line 725 "emit.cog"
                             DEREF(

#line 725 "emit.cog"
                      varDecl).init)
{


#line 727 "emit.cog"
             

#line 727 "emit.cog"
             

#line 727 "emit.cog"
         emit(

#line 727 "emit.cog"
              context, 

#line 727 "emit.cog"
                       " = ");


#line 728 "emit.cog"
                

#line 728 "emit.cog"
                

#line 728 "emit.cog"
         emitExp(

#line 728 "emit.cog"
                 context, 

#line 728 "emit.cog"
                          initExp);
}


#line 730 "emit.cog"
      

#line 730 "emit.cog"
      

#line 730 "emit.cog"
  emit(

#line 730 "emit.cog"
       context, 

#line 730 "emit.cog"
                ";\n");
}


#line 733 "emit.cog"
 void emitParamDecl(

#line 734 "emit.cog"
                      

#line 734 "emit.cog"
           EmitContext

#line 734 "emit.cog"
                      * context, 

#line 735 "emit.cog"
             ParamDecl paramDecl)
{


#line 737 "emit.cog"
                

#line 737 "emit.cog"
                

#line 737 "emit.cog"
  emitDeclarator(

#line 737 "emit.cog"
                 context, 

#line 737 "emit.cog"
                                   DEREF(

#line 737 "emit.cog"
                          paramDecl).type, 

#line 737 "emit.cog"
                                          paramDecl, 

#line 737 "emit.cog"
                                                     kDeclEmitMode_Full);
}


#line 740 "emit.cog"
 void emitFuncDecl(

#line 741 "emit.cog"
                      

#line 741 "emit.cog"
           EmitContext

#line 741 "emit.cog"
                      * context, 

#line 742 "emit.cog"
            FuncDecl funcDecl, 

#line 743 "emit.cog"
        DeclEmitMode mode)
{


#line 745 "emit.cog"
  if(

#line 745 "emit.cog"
           

#line 745 "emit.cog"
      mode 

#line 745 "emit.cog"
           == 

#line 745 "emit.cog"
              kDeclEmitMode_MinimalForward)
{


#line 746 "emit.cog"
   return;
}


#line 748 "emit.cog"
  if(

#line 748 "emit.cog"
           

#line 748 "emit.cog"
      mode 

#line 748 "emit.cog"
           == 

#line 748 "emit.cog"
              kDeclEmitMode_Full)
{


#line 750 "emit.cog"
   if(

#line 750 "emit.cog"
       

#line 750 "emit.cog"
       !

#line 750 "emit.cog"
                DEREF(

#line 750 "emit.cog"
        funcDecl).body)
{


#line 751 "emit.cog"
    return;
}


#line 753 "emit.cog"
                   

#line 753 "emit.cog"
                   

#line 753 "emit.cog"
   emitGenericQuals(

#line 753 "emit.cog"
                    context, 

#line 753 "emit.cog"
                             funcDecl);
}


#line 756 "emit.cog"
  if(auto resultType = 

#line 756 "emit.cog"
                                          DEREF(

#line 756 "emit.cog"
                               DEREF(

#line 756 "emit.cog"
                       funcDecl).resultType).exp)
{


#line 758 "emit.cog"
                 

#line 758 "emit.cog"
                 

#line 758 "emit.cog"
   emitDeclarator(

#line 758 "emit.cog"
                  context, 

#line 758 "emit.cog"
                           resultType, 

#line 758 "emit.cog"
                                       funcDecl, 

#line 758 "emit.cog"
                                                 mode);
}
else
{


#line 762 "emit.cog"
       

#line 762 "emit.cog"
       

#line 762 "emit.cog"
   emit(

#line 762 "emit.cog"
        context, 

#line 762 "emit.cog"
                 "void ");


#line 763 "emit.cog"
               

#line 763 "emit.cog"
               

#line 763 "emit.cog"
   emitDeclName(

#line 763 "emit.cog"
                context, 

#line 763 "emit.cog"
                         funcDecl, 

#line 763 "emit.cog"
                                   mode);
}


#line 766 "emit.cog"
      

#line 766 "emit.cog"
      

#line 766 "emit.cog"
  emit(

#line 766 "emit.cog"
       context, 

#line 766 "emit.cog"
                "(");


#line 768 "emit.cog"
  

#line 768 "emit.cog"
  auto first = 

#line 768 "emit.cog"
              true;


#line 769 "emit.cog"
  for(auto decl : 

#line 769 "emit.cog"
                                    

#line 769 "emit.cog"
                           DEREF(

#line 769 "emit.cog"
                   funcDecl).getDecls())
{
{


#line 771 "emit.cog"
   

#line 771 "emit.cog"
   auto param = 

#line 771 "emit.cog"
                            

#line 771 "emit.cog"
                 

#line 771 "emit.cog"
               as<

#line 771 "emit.cog"
                  ParamDecl> (

#line 771 "emit.cog"
                             decl);


#line 772 "emit.cog"
   if(

#line 772 "emit.cog"
      

#line 772 "emit.cog"
      !

#line 772 "emit.cog"
       param)
{


#line 772 "emit.cog"
              continue;
}


#line 774 "emit.cog"
   if(

#line 774 "emit.cog"
      

#line 774 "emit.cog"
      !

#line 774 "emit.cog"
       first)
{


#line 774 "emit.cog"
                  

#line 774 "emit.cog"
                  

#line 774 "emit.cog"
              emit(

#line 774 "emit.cog"
                   context, 

#line 774 "emit.cog"
                            ", ");
}


#line 775 "emit.cog"
                

#line 775 "emit.cog"
                

#line 775 "emit.cog"
   emitParamDecl(

#line 775 "emit.cog"
                 context, 

#line 775 "emit.cog"
                          param);


#line 776 "emit.cog"
   first = 

#line 776 "emit.cog"
           false;
}
}


#line 779 "emit.cog"
      

#line 779 "emit.cog"
      

#line 779 "emit.cog"
  emit(

#line 779 "emit.cog"
       context, 

#line 779 "emit.cog"
                ")");


#line 781 "emit.cog"
  

#line 781 "emit.cog"
  auto body = 

#line 781 "emit.cog"
                     DEREF(

#line 781 "emit.cog"
             funcDecl).body;


#line 782 "emit.cog"
  if(

#line 782 "emit.cog"
          

#line 782 "emit.cog"
     body 

#line 782 "emit.cog"
          && 

#line 782 "emit.cog"
                  

#line 782 "emit.cog"
             mode 

#line 782 "emit.cog"
                  == 

#line 782 "emit.cog"
                     kDeclEmitMode_Full)
{


#line 784 "emit.cog"
             

#line 784 "emit.cog"
             

#line 784 "emit.cog"
         emit(

#line 784 "emit.cog"
              context, 

#line 784 "emit.cog"
                       "\n");


#line 785 "emit.cog"
                

#line 785 "emit.cog"
                

#line 785 "emit.cog"
   emitBlockStmt(

#line 785 "emit.cog"
                 context, 

#line 785 "emit.cog"
                          body);
}
else
{


#line 789 "emit.cog"
       

#line 789 "emit.cog"
       

#line 789 "emit.cog"
   emit(

#line 789 "emit.cog"
        context, 

#line 789 "emit.cog"
                 ";\n");
}
}


#line 793 "emit.cog"
 void emitInitializerDecl(

#line 794 "emit.cog"
                         

#line 794 "emit.cog"
              EmitContext

#line 794 "emit.cog"
                         * context, 

#line 795 "emit.cog"
               InitializerDecl initDecl, 

#line 796 "emit.cog"
        DeclEmitMode mode)
{


#line 798 "emit.cog"
  if(

#line 798 "emit.cog"
           

#line 798 "emit.cog"
      mode 

#line 798 "emit.cog"
           == 

#line 798 "emit.cog"
              kDeclEmitMode_MinimalForward)
{


#line 799 "emit.cog"
   return;
}


#line 801 "emit.cog"
  if(

#line 801 "emit.cog"
           

#line 801 "emit.cog"
      mode 

#line 801 "emit.cog"
           == 

#line 801 "emit.cog"
              kDeclEmitMode_Full)
{


#line 803 "emit.cog"
   if(

#line 803 "emit.cog"
       

#line 803 "emit.cog"
       !

#line 803 "emit.cog"
                DEREF(

#line 803 "emit.cog"
        initDecl).body)
{


#line 804 "emit.cog"
    return;
}


#line 806 "emit.cog"
                   

#line 806 "emit.cog"
                   

#line 806 "emit.cog"
   emitGenericQuals(

#line 806 "emit.cog"
                    context, 

#line 806 "emit.cog"
                             initDecl);
}


#line 811 "emit.cog"
  if(

#line 811 "emit.cog"
           

#line 811 "emit.cog"
      mode 

#line 811 "emit.cog"
           == 

#line 811 "emit.cog"
              kDeclEmitMode_Full)
{


#line 813 "emit.cog"
                             

#line 813 "emit.cog"
                             

#line 813 "emit.cog"
   emitDeclNameAndGenericArgs(

#line 813 "emit.cog"
                              context, 

#line 813 "emit.cog"
                                                         

#line 813 "emit.cog"
                                               DEREF(

#line 813 "emit.cog"
                                       initDecl).getParent(), 

#line 813 "emit.cog"
                                                             mode);


#line 814 "emit.cog"
       

#line 814 "emit.cog"
       

#line 814 "emit.cog"
   emit(

#line 814 "emit.cog"
        context, 

#line 814 "emit.cog"
                 "::");
}


#line 816 "emit.cog"
         

#line 816 "emit.cog"
         

#line 816 "emit.cog"
     emit(

#line 816 "emit.cog"
          context, 

#line 816 "emit.cog"
                                       DEREF(

#line 816 "emit.cog"
                                     

#line 816 "emit.cog"
                           DEREF(

#line 816 "emit.cog"
                   initDecl).getParent()).name);


#line 818 "emit.cog"
     if(

#line 818 "emit.cog"
                     

#line 818 "emit.cog"
          

#line 818 "emit.cog"
        as<

#line 818 "emit.cog"
           ClassDecl> (

#line 818 "emit.cog"
                                        

#line 818 "emit.cog"
                              DEREF(

#line 818 "emit.cog"
                      initDecl).getParent()))
{


#line 820 "emit.cog"
          

#line 820 "emit.cog"
          

#line 820 "emit.cog"
      emit(

#line 820 "emit.cog"
           context, 

#line 820 "emit.cog"
                    "Impl");
}


#line 823 "emit.cog"
         

#line 823 "emit.cog"
         

#line 823 "emit.cog"
     emit(

#line 823 "emit.cog"
          context, 

#line 823 "emit.cog"
                   "(");


#line 825 "emit.cog"
     

#line 825 "emit.cog"
     auto first = 

#line 825 "emit.cog"
                 true;


#line 826 "emit.cog"
     for(auto decl : 

#line 826 "emit.cog"
                                       

#line 826 "emit.cog"
                              DEREF(

#line 826 "emit.cog"
                      initDecl).getDecls())
{
{


#line 828 "emit.cog"
         

#line 828 "emit.cog"
         auto param = 

#line 828 "emit.cog"
                                  

#line 828 "emit.cog"
                       

#line 828 "emit.cog"
                     as<

#line 828 "emit.cog"
                        ParamDecl> (

#line 828 "emit.cog"
                                   decl);


#line 829 "emit.cog"
         if(

#line 829 "emit.cog"
            

#line 829 "emit.cog"
            !

#line 829 "emit.cog"
             param)
{


#line 829 "emit.cog"
                    continue;
}


#line 831 "emit.cog"
         if(

#line 831 "emit.cog"
            

#line 831 "emit.cog"
            !

#line 831 "emit.cog"
             first)
{


#line 831 "emit.cog"
                        

#line 831 "emit.cog"
                        

#line 831 "emit.cog"
                    emit(

#line 831 "emit.cog"
                         context, 

#line 831 "emit.cog"
                                  ", ");
}


#line 832 "emit.cog"
                      

#line 832 "emit.cog"
                      

#line 832 "emit.cog"
         emitParamDecl(

#line 832 "emit.cog"
                       context, 

#line 832 "emit.cog"
                                param);


#line 833 "emit.cog"
         first = 

#line 833 "emit.cog"
                 false;
}
}


#line 836 "emit.cog"
         

#line 836 "emit.cog"
         

#line 836 "emit.cog"
     emit(

#line 836 "emit.cog"
          context, 

#line 836 "emit.cog"
                   ")");


#line 838 "emit.cog"
  

#line 838 "emit.cog"
  auto body = 

#line 838 "emit.cog"
                     DEREF(

#line 838 "emit.cog"
             initDecl).body;


#line 839 "emit.cog"
  if(

#line 839 "emit.cog"
           

#line 839 "emit.cog"
      body 

#line 839 "emit.cog"
           && 

#line 839 "emit.cog"
                   

#line 839 "emit.cog"
              mode 

#line 839 "emit.cog"
                   == 

#line 839 "emit.cog"
                      kDeclEmitMode_Full)
{


#line 841 "emit.cog"
       

#line 841 "emit.cog"
       

#line 841 "emit.cog"
   emit(

#line 841 "emit.cog"
        context, 

#line 841 "emit.cog"
                 "\n");


#line 842 "emit.cog"
                

#line 842 "emit.cog"
                

#line 842 "emit.cog"
   emitBlockStmt(

#line 842 "emit.cog"
                 context, 

#line 842 "emit.cog"
                          body);
}
else
{


#line 846 "emit.cog"
       

#line 846 "emit.cog"
       

#line 846 "emit.cog"
   emit(

#line 846 "emit.cog"
        context, 

#line 846 "emit.cog"
                 ";\n");
}
}


#line 850 "emit.cog"
 void emitSubscriptDecl(

#line 851 "emit.cog"
                      

#line 851 "emit.cog"
           EmitContext

#line 851 "emit.cog"
                      * context, 

#line 852 "emit.cog"
        SubscriptDecl decl, 

#line 853 "emit.cog"
        DeclEmitMode mode)
{


#line 855 "emit.cog"
  if(

#line 855 "emit.cog"
           

#line 855 "emit.cog"
      mode 

#line 855 "emit.cog"
           == 

#line 855 "emit.cog"
              kDeclEmitMode_MinimalForward)
{


#line 856 "emit.cog"
   return;
}


#line 858 "emit.cog"
  if(

#line 858 "emit.cog"
           

#line 858 "emit.cog"
      mode 

#line 858 "emit.cog"
           == 

#line 858 "emit.cog"
              kDeclEmitMode_Full)
{


#line 860 "emit.cog"
   if(

#line 860 "emit.cog"
       

#line 860 "emit.cog"
       !

#line 860 "emit.cog"
            DEREF(

#line 860 "emit.cog"
        decl).body)
{


#line 861 "emit.cog"
    return;
}


#line 863 "emit.cog"
                   

#line 863 "emit.cog"
                   

#line 863 "emit.cog"
   emitGenericQuals(

#line 863 "emit.cog"
                    context, 

#line 863 "emit.cog"
                             decl);
}


#line 866 "emit.cog"
  if(auto resultType = 

#line 866 "emit.cog"
                                      DEREF(

#line 866 "emit.cog"
                           DEREF(

#line 866 "emit.cog"
                       decl).resultType).exp)
{


#line 868 "emit.cog"
           

#line 868 "emit.cog"
           

#line 868 "emit.cog"
   emitType(

#line 868 "emit.cog"
            context, 

#line 868 "emit.cog"
                     resultType);


#line 869 "emit.cog"
       

#line 869 "emit.cog"
       

#line 869 "emit.cog"
   emit(

#line 869 "emit.cog"
        context, 

#line 869 "emit.cog"
                 " ");
}
else
{


#line 873 "emit.cog"
       

#line 873 "emit.cog"
       

#line 873 "emit.cog"
   emit(

#line 873 "emit.cog"
        context, 

#line 873 "emit.cog"
                 "void ");
}


#line 878 "emit.cog"
  if(

#line 878 "emit.cog"
           

#line 878 "emit.cog"
      mode 

#line 878 "emit.cog"
           == 

#line 878 "emit.cog"
              kDeclEmitMode_Full)
{


#line 880 "emit.cog"
                             

#line 880 "emit.cog"
                             

#line 880 "emit.cog"
   emitDeclNameAndGenericArgs(

#line 880 "emit.cog"
                              context, 

#line 880 "emit.cog"
                                                     

#line 880 "emit.cog"
                                           DEREF(

#line 880 "emit.cog"
                                       decl).getParent(), 

#line 880 "emit.cog"
                                                         mode);


#line 881 "emit.cog"
       

#line 881 "emit.cog"
       

#line 881 "emit.cog"
   emit(

#line 881 "emit.cog"
        context, 

#line 881 "emit.cog"
                 "::");
}


#line 884 "emit.cog"
      

#line 884 "emit.cog"
      

#line 884 "emit.cog"
  emit(

#line 884 "emit.cog"
       context, 

#line 884 "emit.cog"
                "operator[](");


#line 886 "emit.cog"
  

#line 886 "emit.cog"
  auto first = 

#line 886 "emit.cog"
              true;


#line 887 "emit.cog"
  for(auto decl : 

#line 887 "emit.cog"
                               

#line 887 "emit.cog"
                      DEREF(

#line 887 "emit.cog"
                  decl).getDecls())
{
{


#line 889 "emit.cog"
   

#line 889 "emit.cog"
   auto param = 

#line 889 "emit.cog"
                            

#line 889 "emit.cog"
                 

#line 889 "emit.cog"
               as<

#line 889 "emit.cog"
                  ParamDecl> (

#line 889 "emit.cog"
                             decl);


#line 890 "emit.cog"
   if(

#line 890 "emit.cog"
       

#line 890 "emit.cog"
       !

#line 890 "emit.cog"
        param)
{


#line 890 "emit.cog"
               continue;
}


#line 892 "emit.cog"
   if(

#line 892 "emit.cog"
       

#line 892 "emit.cog"
       !

#line 892 "emit.cog"
        first)
{


#line 892 "emit.cog"
                   

#line 892 "emit.cog"
                   

#line 892 "emit.cog"
               emit(

#line 892 "emit.cog"
                    context, 

#line 892 "emit.cog"
                             ", ");
}


#line 893 "emit.cog"
                

#line 893 "emit.cog"
                

#line 893 "emit.cog"
   emitParamDecl(

#line 893 "emit.cog"
                 context, 

#line 893 "emit.cog"
                          param);


#line 894 "emit.cog"
   first = 

#line 894 "emit.cog"
           false;
}
}


#line 897 "emit.cog"
      

#line 897 "emit.cog"
      

#line 897 "emit.cog"
  emit(

#line 897 "emit.cog"
       context, 

#line 897 "emit.cog"
                ")");


#line 899 "emit.cog"
  

#line 899 "emit.cog"
  auto body = 

#line 899 "emit.cog"
                 DEREF(

#line 899 "emit.cog"
             decl).body;


#line 900 "emit.cog"
  if(

#line 900 "emit.cog"
           

#line 900 "emit.cog"
      body 

#line 900 "emit.cog"
           && 

#line 900 "emit.cog"
                   

#line 900 "emit.cog"
              mode 

#line 900 "emit.cog"
                   == 

#line 900 "emit.cog"
                      kDeclEmitMode_Full)
{


#line 902 "emit.cog"
       

#line 902 "emit.cog"
       

#line 902 "emit.cog"
   emit(

#line 902 "emit.cog"
        context, 

#line 902 "emit.cog"
                 "\n");


#line 903 "emit.cog"
                

#line 903 "emit.cog"
                

#line 903 "emit.cog"
   emitBlockStmt(

#line 903 "emit.cog"
                 context, 

#line 903 "emit.cog"
                          body);
}
else
{


#line 907 "emit.cog"
       

#line 907 "emit.cog"
       

#line 907 "emit.cog"
   emit(

#line 907 "emit.cog"
        context, 

#line 907 "emit.cog"
                 ";\n");
}
}


#line 911 "emit.cog"
 void emitDecl(

#line 912 "emit.cog"
                      

#line 912 "emit.cog"
           EmitContext

#line 912 "emit.cog"
                      * context, 

#line 913 "emit.cog"
        Decl decl, 

#line 914 "emit.cog"
        DeclEmitMode mode)
{


#line 916 "emit.cog"
  

#line 916 "emit.cog"
  auto builtinAttr = 

#line 916 "emit.cog"
                                              

#line 916 "emit.cog"
                                 

#line 916 "emit.cog"
                        DEREF(

#line 916 "emit.cog"
                    decl).findAttr<

#line 916 "emit.cog"
                                  BuiltinAttr> ();


#line 917 "emit.cog"
     if(

#line 917 "emit.cog"
         builtinAttr)
{


#line 920 "emit.cog"
         return;
}


#line 923 "emit.cog"
                   

#line 923 "emit.cog"
                   

#line 923 "emit.cog"
  emitLineDirective(

#line 923 "emit.cog"
                    context, 

#line 923 "emit.cog"
                             decl);


#line 925 "emit.cog"
  if(auto classDecl = 

#line 925 "emit.cog"
                                  

#line 925 "emit.cog"
                       

#line 925 "emit.cog"
                     as<

#line 925 "emit.cog"
                        ClassDecl> (

#line 925 "emit.cog"
                                   decl))
{


#line 927 "emit.cog"
                

#line 927 "emit.cog"
                

#line 927 "emit.cog"
   emitClassDecl(

#line 927 "emit.cog"
                 context, 

#line 927 "emit.cog"
                          classDecl, 

#line 927 "emit.cog"
                                     mode);
}
else
{


#line 929 "emit.cog"
          if(auto structDecl = 

#line 929 "emit.cog"
                                            

#line 929 "emit.cog"
                                

#line 929 "emit.cog"
                              as<

#line 929 "emit.cog"
                                 StructDecl> (

#line 929 "emit.cog"
                                             decl))
{


#line 931 "emit.cog"
                 

#line 931 "emit.cog"
                 

#line 931 "emit.cog"
   emitStructDecl(

#line 931 "emit.cog"
                  context, 

#line 931 "emit.cog"
                           structDecl, 

#line 931 "emit.cog"
                                       mode);
}
else
{


#line 934 "emit.cog"
       if(auto tagDecl = 

#line 934 "emit.cog"
                                        

#line 934 "emit.cog"
                           

#line 934 "emit.cog"
                         as<

#line 934 "emit.cog"
                            EnumTagDecl> (

#line 934 "emit.cog"
                                         decl))
{


#line 936 "emit.cog"
       

#line 936 "emit.cog"
       

#line 936 "emit.cog"
   emit(

#line 936 "emit.cog"
        context, 

#line 936 "emit.cog"
                        DEREF(

#line 936 "emit.cog"
                 tagDecl).name);


#line 937 "emit.cog"
   if(

#line 937 "emit.cog"
              DEREF(

#line 937 "emit.cog"
       tagDecl).init)
{


#line 939 "emit.cog"
        

#line 939 "emit.cog"
        

#line 939 "emit.cog"
    emit(

#line 939 "emit.cog"
         context, 

#line 939 "emit.cog"
                  " = ");


#line 940 "emit.cog"
           

#line 940 "emit.cog"
           

#line 940 "emit.cog"
    emitExp(

#line 940 "emit.cog"
            context, 

#line 940 "emit.cog"
                            DEREF(

#line 940 "emit.cog"
                     tagDecl).init);
}


#line 942 "emit.cog"
       

#line 942 "emit.cog"
       

#line 942 "emit.cog"
   emit(

#line 942 "emit.cog"
        context, 

#line 942 "emit.cog"
                 ",\n");
}
else
{


#line 944 "emit.cog"
       if(auto varDecl = 

#line 944 "emit.cog"
                                       

#line 944 "emit.cog"
                          

#line 944 "emit.cog"
                        as<

#line 944 "emit.cog"
                           VarDeclBase> (

#line 944 "emit.cog"
                                        decl))
{


#line 946 "emit.cog"
              

#line 946 "emit.cog"
              

#line 946 "emit.cog"
   emitVarDecl(

#line 946 "emit.cog"
               context, 

#line 946 "emit.cog"
                        varDecl, 

#line 946 "emit.cog"
                                 mode);
}
else
{


#line 948 "emit.cog"
       if(auto funcDecl = 

#line 948 "emit.cog"
                                     

#line 948 "emit.cog"
                           

#line 948 "emit.cog"
                         as<

#line 948 "emit.cog"
                            FuncDecl> (

#line 948 "emit.cog"
                                      decl))
{


#line 950 "emit.cog"
               

#line 950 "emit.cog"
               

#line 950 "emit.cog"
   emitFuncDecl(

#line 950 "emit.cog"
                context, 

#line 950 "emit.cog"
                         funcDecl, 

#line 950 "emit.cog"
                                   mode);
}
else
{


#line 952 "emit.cog"
          if(auto initDecl = 

#line 952 "emit.cog"
                                               

#line 952 "emit.cog"
                              

#line 952 "emit.cog"
                            as<

#line 952 "emit.cog"
                               InitializerDecl> (

#line 952 "emit.cog"
                                                decl))
{


#line 954 "emit.cog"
                      

#line 954 "emit.cog"
                      

#line 954 "emit.cog"
   emitInitializerDecl(

#line 954 "emit.cog"
                       context, 

#line 954 "emit.cog"
                                initDecl, 

#line 954 "emit.cog"
                                          mode);
}
else
{


#line 956 "emit.cog"
       if(auto subscriptDecl = 

#line 956 "emit.cog"
                                                

#line 956 "emit.cog"
                                 

#line 956 "emit.cog"
                               as<

#line 956 "emit.cog"
                                  SubscriptDecl> (

#line 956 "emit.cog"
                                                 decl))
{


#line 958 "emit.cog"
                    

#line 958 "emit.cog"
                    

#line 958 "emit.cog"
   emitSubscriptDecl(

#line 958 "emit.cog"
                     context, 

#line 958 "emit.cog"
                              subscriptDecl, 

#line 958 "emit.cog"
                                             mode);
}
else
{


#line 960 "emit.cog"
       if(auto enumDecl = 

#line 960 "emit.cog"
                                      

#line 960 "emit.cog"
                            

#line 960 "emit.cog"
                          as<

#line 960 "emit.cog"
                             EnumDecl> (

#line 960 "emit.cog"
                                       decl))
{


#line 962 "emit.cog"
   if(

#line 962 "emit.cog"
            

#line 962 "emit.cog"
       mode 

#line 962 "emit.cog"
            >= 

#line 962 "emit.cog"
               kDeclEmitMode_Full)
{


#line 963 "emit.cog"
    return;
}


#line 965 "emit.cog"
       

#line 965 "emit.cog"
       

#line 965 "emit.cog"
   emit(

#line 965 "emit.cog"
        context, 

#line 965 "emit.cog"
                 "enum ");


#line 966 "emit.cog"
               

#line 966 "emit.cog"
               

#line 966 "emit.cog"
   emitDeclName(

#line 966 "emit.cog"
                context, 

#line 966 "emit.cog"
                         enumDecl, 

#line 966 "emit.cog"
                                   mode);


#line 967 "emit.cog"
       

#line 967 "emit.cog"
       

#line 967 "emit.cog"
   emit(

#line 967 "emit.cog"
        context, 

#line 967 "emit.cog"
                 " : int");


#line 969 "emit.cog"
   if(

#line 969 "emit.cog"
            

#line 969 "emit.cog"
       mode 

#line 969 "emit.cog"
            <= 

#line 969 "emit.cog"
               kDeclEmitMode_MinimalForward)
{


#line 971 "emit.cog"
        

#line 971 "emit.cog"
        

#line 971 "emit.cog"
    emit(

#line 971 "emit.cog"
         context, 

#line 971 "emit.cog"
                  ";\n");


#line 972 "emit.cog"
    return;
}


#line 975 "emit.cog"
       

#line 975 "emit.cog"
       

#line 975 "emit.cog"
   emit(

#line 975 "emit.cog"
        context, 

#line 975 "emit.cog"
                 "\n{\n");


#line 976 "emit.cog"
   for(auto dd : 

#line 976 "emit.cog"
                                  

#line 976 "emit.cog"
                         DEREF(

#line 976 "emit.cog"
                 enumDecl).getDecls())
{
{


#line 978 "emit.cog"
            

#line 978 "emit.cog"
            

#line 978 "emit.cog"
    emitDecl(

#line 978 "emit.cog"
             context, 

#line 978 "emit.cog"
                      dd, 

#line 978 "emit.cog"
                          kDeclEmitMode_Full);
}
}


#line 980 "emit.cog"
       

#line 980 "emit.cog"
       

#line 980 "emit.cog"
   emit(

#line 980 "emit.cog"
        context, 

#line 980 "emit.cog"
                 "};\n");
}
else
{


#line 982 "emit.cog"
       if(auto importDecl = 

#line 982 "emit.cog"
                                         

#line 982 "emit.cog"
                             

#line 982 "emit.cog"
                           as<

#line 982 "emit.cog"
                              ImportDecl> (

#line 982 "emit.cog"
                                          decl))
{
}
else
{


#line 984 "emit.cog"
       if(auto typeAliasDecl = 

#line 984 "emit.cog"
                                                

#line 984 "emit.cog"
                                 

#line 984 "emit.cog"
                               as<

#line 984 "emit.cog"
                                  TypeAliasDecl> (

#line 984 "emit.cog"
                                                 decl))
{


#line 986 "emit.cog"
       

#line 986 "emit.cog"
       

#line 986 "emit.cog"
   emit(

#line 986 "emit.cog"
        context, 

#line 986 "emit.cog"
                 "typedef ");


#line 987 "emit.cog"
                 

#line 987 "emit.cog"
                 

#line 987 "emit.cog"
   emitDeclarator(

#line 987 "emit.cog"
                  context, 

#line 987 "emit.cog"
                                        DEREF(

#line 987 "emit.cog"
                           typeAliasDecl).init, 

#line 987 "emit.cog"
                                               typeAliasDecl, 

#line 987 "emit.cog"
                                                              mode);


#line 988 "emit.cog"
       

#line 988 "emit.cog"
       

#line 988 "emit.cog"
   emit(

#line 988 "emit.cog"
        context, 

#line 988 "emit.cog"
                 ";\n");
}
else
{


#line 990 "emit.cog"
       if(auto genericDecl = 

#line 990 "emit.cog"
                                            

#line 990 "emit.cog"
                               

#line 990 "emit.cog"
                             as<

#line 990 "emit.cog"
                                GenericDecl> (

#line 990 "emit.cog"
                                             decl))
{


#line 995 "emit.cog"
   if(

#line 995 "emit.cog"
            

#line 995 "emit.cog"
       mode 

#line 995 "emit.cog"
            < 

#line 995 "emit.cog"
              kDeclEmitMode_Full)
{


#line 997 "emit.cog"
    

#line 997 "emit.cog"
    auto innerDecl = 

#line 997 "emit.cog"
                               DEREF(

#line 997 "emit.cog"
                    genericDecl).inner;


#line 1000 "emit.cog"
    if(

#line 1000 "emit.cog"
             

#line 1000 "emit.cog"
        mode 

#line 1000 "emit.cog"
             <= 

#line 1000 "emit.cog"
                kDeclEmitMode_MinimalForward)
{


#line 1002 "emit.cog"
     if(

#line 1002 "emit.cog"
                         

#line 1002 "emit.cog"
           

#line 1002 "emit.cog"
         as<

#line 1002 "emit.cog"
            FuncDeclBase> (

#line 1002 "emit.cog"
                          innerDecl))
{


#line 1003 "emit.cog"
      return;
}
}


#line 1006 "emit.cog"
        

#line 1006 "emit.cog"
        

#line 1006 "emit.cog"
    emit(

#line 1006 "emit.cog"
         context, 

#line 1006 "emit.cog"
                  "template<");


#line 1007 "emit.cog"
    

#line 1007 "emit.cog"
    auto first = 

#line 1007 "emit.cog"
                true;


#line 1008 "emit.cog"
    for(auto dd : 

#line 1008 "emit.cog"
                                      

#line 1008 "emit.cog"
                             DEREF(

#line 1008 "emit.cog"
                  genericDecl).getDecls())
{
{


#line 1010 "emit.cog"
     if(auto typeParam = 

#line 1010 "emit.cog"
                                             

#line 1010 "emit.cog"
                           

#line 1010 "emit.cog"
                         as<

#line 1010 "emit.cog"
                            GenericParamDecl> (

#line 1010 "emit.cog"
                                              dd))
{


#line 1012 "emit.cog"
      if(

#line 1012 "emit.cog"
          

#line 1012 "emit.cog"
          !

#line 1012 "emit.cog"
           first)
{


#line 1012 "emit.cog"
                      

#line 1012 "emit.cog"
                      

#line 1012 "emit.cog"
                  emit(

#line 1012 "emit.cog"
                       context, 

#line 1012 "emit.cog"
                                ", ");
}


#line 1013 "emit.cog"
          

#line 1013 "emit.cog"
          

#line 1013 "emit.cog"
      emit(

#line 1013 "emit.cog"
           context, 

#line 1013 "emit.cog"
                    "typename ");


#line 1014 "emit.cog"
          

#line 1014 "emit.cog"
          

#line 1014 "emit.cog"
      emit(

#line 1014 "emit.cog"
           context, 

#line 1014 "emit.cog"
                             DEREF(

#line 1014 "emit.cog"
                    typeParam).name);


#line 1015 "emit.cog"
      first = 

#line 1015 "emit.cog"
              false;
}
else
{
}
}
}


#line 1021 "emit.cog"
        

#line 1021 "emit.cog"
        

#line 1021 "emit.cog"
    emit(

#line 1021 "emit.cog"
         context, 

#line 1021 "emit.cog"
                  " >\n");
}


#line 1023 "emit.cog"
           

#line 1023 "emit.cog"
           

#line 1023 "emit.cog"
   emitDecl(

#line 1023 "emit.cog"
            context, 

#line 1023 "emit.cog"
                                DEREF(

#line 1023 "emit.cog"
                     genericDecl).inner, 

#line 1023 "emit.cog"
                                        mode);
}
else
{


#line 1027 "emit.cog"
            

#line 1027 "emit.cog"
            

#line 1027 "emit.cog"
   cogAssert(

#line 1027 "emit.cog"
             

#line 1027 "emit.cog"
             !

#line 1027 "emit.cog"
              "unimplemented");
}
}
}
}
}
}
}
}
}
}
}
}


#line 1032 "emit.cog"
 void emitDecls(

#line 1033 "emit.cog"
                      

#line 1033 "emit.cog"
           EmitContext

#line 1033 "emit.cog"
                      * context, 

#line 1034 "emit.cog"
                 ContainerDecl containerDecl, 

#line 1035 "emit.cog"
        DeclEmitMode mode)
{


#line 1037 "emit.cog"
  for(auto decl : 

#line 1037 "emit.cog"
                                        

#line 1037 "emit.cog"
                               DEREF(

#line 1037 "emit.cog"
                  containerDecl).getDecls())
{
{


#line 1039 "emit.cog"
           

#line 1039 "emit.cog"
           

#line 1039 "emit.cog"
   emitDecl(

#line 1039 "emit.cog"
            context, 

#line 1039 "emit.cog"
                     decl, 

#line 1039 "emit.cog"
                           mode);
}
}
}


#line 1043 "emit.cog"
 

#line 1049 "emit.cog"
 void addDecl(

#line 1050 "emit.cog"
                          

#line 1050 "emit.cog"
           DeclSortContext

#line 1050 "emit.cog"
                          * context, 

#line 1051 "emit.cog"
        Decl decl)
{


#line 1053 "emit.cog"
                            

#line 1053 "emit.cog"
                            

#line 1053 "emit.cog"
                     DEREF(

#line 1053 "emit.cog"
         DEREF(

#line 1053 "emit.cog"
  context).sortedDecls).append(

#line 1053 "emit.cog"
                             decl);
}


#line 1056 "emit.cog"
 

#line 1060 "emit.cog"
 void addDependencies(

#line 1061 "emit.cog"
                          

#line 1061 "emit.cog"
           DeclSortContext

#line 1061 "emit.cog"
                          * context, 

#line 1062 "emit.cog"
            

#line 1062 "emit.cog"
        Name

#line 1062 "emit.cog"
            * name)
{


#line 1064 "emit.cog"
           

#line 1064 "emit.cog"
           

#line 1064 "emit.cog"
  cogAssert(

#line 1064 "emit.cog"
            name);


#line 1073 "emit.cog"
  

#line 1073 "emit.cog"
  

#line 1073 "emit.cog"
                           

#line 1073 "emit.cog"
                      Array<

#line 1073 "emit.cog"
                            Decl>  matchingDecls;


#line 1074 "emit.cog"
  

#line 1074 "emit.cog"
  

#line 1074 "emit.cog"
                                

#line 1074 "emit.cog"
                           Array<

#line 1074 "emit.cog"
                                 Decl>  stillUnsortedDecls;


#line 1076 "emit.cog"
  for(auto dd : 

#line 1076 "emit.cog"
                       DEREF(

#line 1076 "emit.cog"
                context).unsortedDecls)
{
{


#line 1081 "emit.cog"
   if(auto classDecl = 

#line 1081 "emit.cog"
                                   

#line 1081 "emit.cog"
                        

#line 1081 "emit.cog"
                      as<

#line 1081 "emit.cog"
                         ClassDecl> (

#line 1081 "emit.cog"
                                    dd))
{


#line 1083 "emit.cog"
                             

#line 1083 "emit.cog"
                             

#line 1083 "emit.cog"
                      DEREF(

#line 1083 "emit.cog"
    stillUnsortedDecls).append(

#line 1083 "emit.cog"
                              dd);
}
else
{


#line 1085 "emit.cog"
        if(

#line 1085 "emit.cog"
                    

#line 1085 "emit.cog"
              DEREF(

#line 1085 "emit.cog"
            dd).name 

#line 1085 "emit.cog"
                    == 

#line 1085 "emit.cog"
                       name)
{


#line 1087 "emit.cog"
                        

#line 1087 "emit.cog"
                        

#line 1087 "emit.cog"
                 DEREF(

#line 1087 "emit.cog"
    matchingDecls).append(

#line 1087 "emit.cog"
                         dd);
}
else
{


#line 1091 "emit.cog"
                             

#line 1091 "emit.cog"
                             

#line 1091 "emit.cog"
                      DEREF(

#line 1091 "emit.cog"
    stillUnsortedDecls).append(

#line 1091 "emit.cog"
                              dd);
}
}
}
}


#line 1095 "emit.cog"
         DEREF(

#line 1095 "emit.cog"
  context).unsortedDecls = 

#line 1095 "emit.cog"
                          stillUnsortedDecls;


#line 1099 "emit.cog"
  for(auto dd : 

#line 1099 "emit.cog"
                matchingDecls)
{
{


#line 1101 "emit.cog"
                  

#line 1101 "emit.cog"
                  

#line 1101 "emit.cog"
   addDependencies(

#line 1101 "emit.cog"
                   context, 

#line 1101 "emit.cog"
                            dd);


#line 1102 "emit.cog"
          

#line 1102 "emit.cog"
          

#line 1102 "emit.cog"
   addDecl(

#line 1102 "emit.cog"
           context, 

#line 1102 "emit.cog"
                    dd);
}
}
}


#line 1106 "emit.cog"
 void addDependencies(

#line 1107 "emit.cog"
                          

#line 1107 "emit.cog"
           DeclSortContext

#line 1107 "emit.cog"
                          * context, 

#line 1108 "emit.cog"
       Exp exp)
{


#line 1110 "emit.cog"
  if(

#line 1110 "emit.cog"
      

#line 1110 "emit.cog"
      !

#line 1110 "emit.cog"
       exp)
{


#line 1110 "emit.cog"
            return;
}


#line 1113 "emit.cog"
  if(auto genericAppExpr = 

#line 1113 "emit.cog"
                                            

#line 1113 "emit.cog"
                             

#line 1113 "emit.cog"
                           as<

#line 1113 "emit.cog"
                              GenericAppExp> (

#line 1113 "emit.cog"
                                             exp))
{


#line 1115 "emit.cog"
   if(auto nameExpr = 

#line 1115 "emit.cog"
                                 

#line 1115 "emit.cog"
                        

#line 1115 "emit.cog"
                      as<

#line 1115 "emit.cog"
                         NameExp> (

#line 1115 "emit.cog"
                                                DEREF(

#line 1115 "emit.cog"
                                  genericAppExpr).base))
{


#line 1117 "emit.cog"
    if(

#line 1117 "emit.cog"
                                                    

#line 1117 "emit.cog"
              

#line 1117 "emit.cog"
        strcmp(

#line 1117 "emit.cog"
               "Ptr", 

#line 1117 "emit.cog"
                                            DEREF(

#line 1117 "emit.cog"
                             

#line 1117 "emit.cog"
                      getText(

#line 1117 "emit.cog"
                                      DEREF(

#line 1117 "emit.cog"
                              nameExpr).name)).begin) 

#line 1117 "emit.cog"
                                                    == 

#line 1117 "emit.cog"
                                                       0)
{


#line 1118 "emit.cog"
     return;
}


#line 1119 "emit.cog"
    if(

#line 1119 "emit.cog"
                                                         

#line 1119 "emit.cog"
              

#line 1119 "emit.cog"
        strcmp(

#line 1119 "emit.cog"
               "ConstPtr", 

#line 1119 "emit.cog"
                                                 DEREF(

#line 1119 "emit.cog"
                                  

#line 1119 "emit.cog"
                           getText(

#line 1119 "emit.cog"
                                           DEREF(

#line 1119 "emit.cog"
                                   nameExpr).name)).begin) 

#line 1119 "emit.cog"
                                                         == 

#line 1119 "emit.cog"
                                                            0)
{


#line 1120 "emit.cog"
     return;
}
}
}


#line 1124 "emit.cog"
  if(auto nameExp = 

#line 1124 "emit.cog"
                               

#line 1124 "emit.cog"
                      

#line 1124 "emit.cog"
                    as<

#line 1124 "emit.cog"
                       NameExp> (

#line 1124 "emit.cog"
                                exp))
{


#line 1126 "emit.cog"
                  

#line 1126 "emit.cog"
                  

#line 1126 "emit.cog"
   addDependencies(

#line 1126 "emit.cog"
                   context, 

#line 1126 "emit.cog"
                                   DEREF(

#line 1126 "emit.cog"
                            nameExp).name);
}
else
{


#line 1128 "emit.cog"
       if(auto appExp = 

#line 1128 "emit.cog"
                                      

#line 1128 "emit.cog"
                          

#line 1128 "emit.cog"
                        as<

#line 1128 "emit.cog"
                           AppExpBase> (

#line 1128 "emit.cog"
                                       exp))
{


#line 1130 "emit.cog"
                  

#line 1130 "emit.cog"
                  

#line 1130 "emit.cog"
   addDependencies(

#line 1130 "emit.cog"
                   context, 

#line 1130 "emit.cog"
                                  DEREF(

#line 1130 "emit.cog"
                            appExp).base);


#line 1131 "emit.cog"
   for(auto aa : 

#line 1131 "emit.cog"
                       DEREF(

#line 1131 "emit.cog"
                 appExp).args)
{


#line 1132 "emit.cog"
                   

#line 1132 "emit.cog"
                   

#line 1132 "emit.cog"
    addDependencies(

#line 1132 "emit.cog"
                    context, 

#line 1132 "emit.cog"
                               DEREF(

#line 1132 "emit.cog"
                             aa).exp);
}
}
}
}


#line 1136 "emit.cog"
 void addDependencies(

#line 1137 "emit.cog"
                          

#line 1137 "emit.cog"
           DeclSortContext

#line 1137 "emit.cog"
                          * context, 

#line 1138 "emit.cog"
           TypeExp typeExp)
{


#line 1140 "emit.cog"
                 

#line 1140 "emit.cog"
                 

#line 1140 "emit.cog"
  addDependencies(

#line 1140 "emit.cog"
                  context, 

#line 1140 "emit.cog"
                                  DEREF(

#line 1140 "emit.cog"
                           typeExp).exp);
}


#line 1143 "emit.cog"
 void addDependencies(

#line 1144 "emit.cog"
                          

#line 1144 "emit.cog"
           DeclSortContext

#line 1144 "emit.cog"
                          * context, 

#line 1145 "emit.cog"
        Decl decl)
{


#line 1148 "emit.cog"
  if(auto varDecl = 

#line 1148 "emit.cog"
                                   

#line 1148 "emit.cog"
                      

#line 1148 "emit.cog"
                    as<

#line 1148 "emit.cog"
                       VarDeclBase> (

#line 1148 "emit.cog"
                                    decl))
{


#line 1150 "emit.cog"
                  

#line 1150 "emit.cog"
                  

#line 1150 "emit.cog"
   addDependencies(

#line 1150 "emit.cog"
                   context, 

#line 1150 "emit.cog"
                                   DEREF(

#line 1150 "emit.cog"
                            varDecl).type);
}
else
{


#line 1152 "emit.cog"
       if(auto funcDecl = 

#line 1152 "emit.cog"
                                          

#line 1152 "emit.cog"
                            

#line 1152 "emit.cog"
                          as<

#line 1152 "emit.cog"
                             FuncDeclBase> (

#line 1152 "emit.cog"
                                           decl))
{


#line 1154 "emit.cog"
                  

#line 1154 "emit.cog"
                  

#line 1154 "emit.cog"
   addDependencies(

#line 1154 "emit.cog"
                   context, 

#line 1154 "emit.cog"
                                    DEREF(

#line 1154 "emit.cog"
                            funcDecl).resultType);


#line 1155 "emit.cog"
   for(auto dd : 

#line 1155 "emit.cog"
                                  

#line 1155 "emit.cog"
                         DEREF(

#line 1155 "emit.cog"
                 funcDecl).getDecls())
{
{


#line 1157 "emit.cog"
                   

#line 1157 "emit.cog"
                   

#line 1157 "emit.cog"
    addDependencies(

#line 1157 "emit.cog"
                    context, 

#line 1157 "emit.cog"
                             dd);
}
}
}
else
{


#line 1160 "emit.cog"
       if(auto aggTypeDecl = 

#line 1160 "emit.cog"
                                            

#line 1160 "emit.cog"
                               

#line 1160 "emit.cog"
                             as<

#line 1160 "emit.cog"
                                AggTypeDecl> (

#line 1160 "emit.cog"
                                             decl))
{


#line 1162 "emit.cog"
                  

#line 1162 "emit.cog"
                  

#line 1162 "emit.cog"
   addDependencies(

#line 1162 "emit.cog"
                   context, 

#line 1162 "emit.cog"
                                       DEREF(

#line 1162 "emit.cog"
                            aggTypeDecl).base);


#line 1163 "emit.cog"
   for(auto dd : 

#line 1163 "emit.cog"
                                     

#line 1163 "emit.cog"
                            DEREF(

#line 1163 "emit.cog"
                 aggTypeDecl).getDecls())
{
{


#line 1165 "emit.cog"
                   

#line 1165 "emit.cog"
                   

#line 1165 "emit.cog"
    addDependencies(

#line 1165 "emit.cog"
                    context, 

#line 1165 "emit.cog"
                             dd);
}
}
}
}
}
}


#line 1171 "emit.cog"
 void sortDecls(

#line 1172 "emit.cog"
                      

#line 1172 "emit.cog"
           EmitContext

#line 1172 "emit.cog"
                      * context, 

#line 1173 "emit.cog"
             ContainerDecl container)
{


#line 1175 "emit.cog"
  

#line 1175 "emit.cog"
  

#line 1175 "emit.cog"
                    DeclSortContext sortContext;


#line 1176 "emit.cog"
             DEREF(

#line 1176 "emit.cog"
  sortContext).unsortedDecls = 

#line 1176 "emit.cog"
                                                

#line 1176 "emit.cog"
                                       DEREF(

#line 1176 "emit.cog"
                              container).getDecls();


#line 1178 "emit.cog"
  while(

#line 1178 "emit.cog"
                                           

#line 1178 "emit.cog"
                                  DEREF(

#line 1178 "emit.cog"
                    DEREF(

#line 1178 "emit.cog"
         sortContext).unsortedDecls).getCount())
{
{


#line 1180 "emit.cog"
   

#line 1180 "emit.cog"
   auto decl = 

#line 1180 "emit.cog"
                                       

#line 1180 "emit.cog"
                         DEREF(

#line 1180 "emit.cog"
              sortContext).unsortedDecls[

#line 1180 "emit.cog"
                                        0];


#line 1182 "emit.cog"
                                     

#line 1182 "emit.cog"
                                     

#line 1182 "emit.cog"
                            DEREF(

#line 1182 "emit.cog"
              DEREF(

#line 1182 "emit.cog"
   sortContext).unsortedDecls).removeAt(

#line 1182 "emit.cog"
                                      0);


#line 1185 "emit.cog"
                  

#line 1185 "emit.cog"
                  

#line 1185 "emit.cog"
   addDependencies(

#line 1185 "emit.cog"
                   

#line 1185 "emit.cog"
                   &

#line 1185 "emit.cog"
                    sortContext, 

#line 1185 "emit.cog"
                                 decl);


#line 1187 "emit.cog"
          

#line 1187 "emit.cog"
          

#line 1187 "emit.cog"
   addDecl(

#line 1187 "emit.cog"
           

#line 1187 "emit.cog"
           &

#line 1187 "emit.cog"
            sortContext, 

#line 1187 "emit.cog"
                         decl);
}
}


#line 1190 "emit.cog"
                    

#line 1190 "emit.cog"
           DEREF(

#line 1190 "emit.cog"
  container).getDecls() = 

#line 1190 "emit.cog"
                                    DEREF(

#line 1190 "emit.cog"
                         sortContext).sortedDecls;
}


#line 1193 "emit.cog"
 void emitModuleInner(

#line 1194 "emit.cog"
             Session session, 

#line 1195 "emit.cog"
                  TerminatedStringSpan moduleNameText, 

#line 1196 "emit.cog"
                  

#line 1196 "emit.cog"
               Ptr<

#line 1196 "emit.cog"
                   Char>  outputPath, 

#line 1197 "emit.cog"
              

#line 1197 "emit.cog"
           Ptr<

#line 1197 "emit.cog"
               Char>  extra)
{


#line 1199 "emit.cog"
  

#line 1199 "emit.cog"
  auto moduleDecl = 

#line 1199 "emit.cog"
                          DEREF(

#line 1199 "emit.cog"
                   session).moduleDecl;


#line 1201 "emit.cog"
  

#line 1201 "emit.cog"
  auto stream = 

#line 1201 "emit.cog"
                    

#line 1201 "emit.cog"
               fopen(

#line 1201 "emit.cog"
                     outputPath, 

#line 1201 "emit.cog"
                                 "wb");


#line 1204 "emit.cog"
  

#line 1204 "emit.cog"
  

#line 1204 "emit.cog"
                EmitContext context;


#line 1205 "emit.cog"
         DEREF(

#line 1205 "emit.cog"
  context).session = 

#line 1205 "emit.cog"
                    session;


#line 1206 "emit.cog"
         DEREF(

#line 1206 "emit.cog"
  context).stream = 

#line 1206 "emit.cog"
                   stream;


#line 1207 "emit.cog"
         DEREF(

#line 1207 "emit.cog"
  context).suppressLineDirective = 

#line 1207 "emit.cog"
                                  0;


#line 1209 "emit.cog"
      

#line 1209 "emit.cog"
      

#line 1209 "emit.cog"
  emit(

#line 1209 "emit.cog"
       

#line 1209 "emit.cog"
       &

#line 1209 "emit.cog"
        context, 

#line 1209 "emit.cog"
                 "#include \"runtime/runtime.h\"\n");


#line 1211 "emit.cog"
  for(auto mm : 

#line 1211 "emit.cog"
                       DEREF(

#line 1211 "emit.cog"
                session).loadedModules)
{
{


#line 1213 "emit.cog"
         if(

#line 1213 "emit.cog"
               

#line 1213 "emit.cog"
            mm 

#line 1213 "emit.cog"
               == 

#line 1213 "emit.cog"
                  moduleDecl)
{


#line 1213 "emit.cog"
                              continue;
}


#line 1215 "emit.cog"
            

#line 1215 "emit.cog"
            

#line 1215 "emit.cog"
   sortDecls(

#line 1215 "emit.cog"
             

#line 1215 "emit.cog"
             &

#line 1215 "emit.cog"
              context, 

#line 1215 "emit.cog"
                       mm);


#line 1218 "emit.cog"
         

#line 1218 "emit.cog"
         

#line 1218 "emit.cog"
     emit(

#line 1218 "emit.cog"
          

#line 1218 "emit.cog"
          &

#line 1218 "emit.cog"
           context, 

#line 1218 "emit.cog"
                    "namespace ");


#line 1219 "emit.cog"
         

#line 1219 "emit.cog"
         

#line 1219 "emit.cog"
     emit(

#line 1219 "emit.cog"
          

#line 1219 "emit.cog"
          &

#line 1219 "emit.cog"
           context, 

#line 1219 "emit.cog"
                      DEREF(

#line 1219 "emit.cog"
                    mm).name);


#line 1220 "emit.cog"
         

#line 1220 "emit.cog"
         

#line 1220 "emit.cog"
     emit(

#line 1220 "emit.cog"
          

#line 1220 "emit.cog"
          &

#line 1220 "emit.cog"
           context, 

#line 1220 "emit.cog"
                    " {\n");


#line 1221 "emit.cog"
           

#line 1221 "emit.cog"
           

#line 1221 "emit.cog"
  emitDecls(

#line 1221 "emit.cog"
            

#line 1221 "emit.cog"
            &

#line 1221 "emit.cog"
             context, 

#line 1221 "emit.cog"
                      mm, 

#line 1221 "emit.cog"
                          kDeclEmitMode_MinimalForward);


#line 1222 "emit.cog"
           

#line 1222 "emit.cog"
           

#line 1222 "emit.cog"
  emitDecls(

#line 1222 "emit.cog"
            

#line 1222 "emit.cog"
            &

#line 1222 "emit.cog"
             context, 

#line 1222 "emit.cog"
                      mm, 

#line 1222 "emit.cog"
                          kDeclEmitMode_Forward);


#line 1223 "emit.cog"
         

#line 1223 "emit.cog"
         

#line 1223 "emit.cog"
     emit(

#line 1223 "emit.cog"
          

#line 1223 "emit.cog"
          &

#line 1223 "emit.cog"
           context, 

#line 1223 "emit.cog"
                    "}\n");
}
}


#line 1228 "emit.cog"
           

#line 1228 "emit.cog"
           

#line 1228 "emit.cog"
  sortDecls(

#line 1228 "emit.cog"
            

#line 1228 "emit.cog"
            &

#line 1228 "emit.cog"
             context, 

#line 1228 "emit.cog"
                      moduleDecl);


#line 1230 "emit.cog"
         

#line 1230 "emit.cog"
         

#line 1230 "emit.cog"
     emit(

#line 1230 "emit.cog"
          

#line 1230 "emit.cog"
          &

#line 1230 "emit.cog"
           context, 

#line 1230 "emit.cog"
                    "namespace ");


#line 1231 "emit.cog"
         

#line 1231 "emit.cog"
         

#line 1231 "emit.cog"
     emit(

#line 1231 "emit.cog"
          

#line 1231 "emit.cog"
          &

#line 1231 "emit.cog"
           context, 

#line 1231 "emit.cog"
                    moduleNameText);


#line 1232 "emit.cog"
         

#line 1232 "emit.cog"
         

#line 1232 "emit.cog"
     emit(

#line 1232 "emit.cog"
          

#line 1232 "emit.cog"
          &

#line 1232 "emit.cog"
           context, 

#line 1232 "emit.cog"
                    " {\n");


#line 1233 "emit.cog"
           

#line 1233 "emit.cog"
           

#line 1233 "emit.cog"
  emitDecls(

#line 1233 "emit.cog"
            

#line 1233 "emit.cog"
            &

#line 1233 "emit.cog"
             context, 

#line 1233 "emit.cog"
                      moduleDecl, 

#line 1233 "emit.cog"
                                  kDeclEmitMode_MinimalForward);


#line 1234 "emit.cog"
           

#line 1234 "emit.cog"
           

#line 1234 "emit.cog"
  emitDecls(

#line 1234 "emit.cog"
            

#line 1234 "emit.cog"
            &

#line 1234 "emit.cog"
             context, 

#line 1234 "emit.cog"
                      moduleDecl, 

#line 1234 "emit.cog"
                                  kDeclEmitMode_Forward);


#line 1235 "emit.cog"
           

#line 1235 "emit.cog"
           

#line 1235 "emit.cog"
  emitDecls(

#line 1235 "emit.cog"
            

#line 1235 "emit.cog"
            &

#line 1235 "emit.cog"
             context, 

#line 1235 "emit.cog"
                      moduleDecl, 

#line 1235 "emit.cog"
                                  kDeclEmitMode_Full);


#line 1238 "emit.cog"
  for(auto dd : 

#line 1238 "emit.cog"
                                   

#line 1238 "emit.cog"
                          DEREF(

#line 1238 "emit.cog"
                moduleDecl).getDecls())
{
{


#line 1240 "emit.cog"
   

#line 1240 "emit.cog"
   auto classDecl = 

#line 1240 "emit.cog"
                                

#line 1240 "emit.cog"
                     

#line 1240 "emit.cog"
                   as<

#line 1240 "emit.cog"
                      ClassDecl> (

#line 1240 "emit.cog"
                                 dd);


#line 1241 "emit.cog"
   if(

#line 1241 "emit.cog"
       

#line 1241 "emit.cog"
       !

#line 1241 "emit.cog"
        classDecl)
{


#line 1241 "emit.cog"
                   continue;
}


#line 1243 "emit.cog"
                                 

#line 1243 "emit.cog"
                                 

#line 1243 "emit.cog"
          DEREF(

#line 1243 "emit.cog"
   context).suppressLineDirective 

#line 1243 "emit.cog"
                                 += 

#line 1243 "emit.cog"
                                    1;


#line 1245 "emit.cog"
       

#line 1245 "emit.cog"
       

#line 1245 "emit.cog"
   emit(

#line 1245 "emit.cog"
        

#line 1245 "emit.cog"
        &

#line 1245 "emit.cog"
         context, 

#line 1245 "emit.cog"
                  "COG_DEFINE_CLASS(");


#line 1246 "emit.cog"
               

#line 1246 "emit.cog"
               

#line 1246 "emit.cog"
   emitDeclName(

#line 1246 "emit.cog"
                

#line 1246 "emit.cog"
                &

#line 1246 "emit.cog"
                 context, 

#line 1246 "emit.cog"
                          classDecl, 

#line 1246 "emit.cog"
                                     kDeclEmitMode_Full);


#line 1247 "emit.cog"
       

#line 1247 "emit.cog"
       

#line 1247 "emit.cog"
   emit(

#line 1247 "emit.cog"
        

#line 1247 "emit.cog"
        &

#line 1247 "emit.cog"
         context, 

#line 1247 "emit.cog"
                  ", ");


#line 1248 "emit.cog"
   if(auto base = 

#line 1248 "emit.cog"
                                DEREF(

#line 1248 "emit.cog"
                           DEREF(

#line 1248 "emit.cog"
                  classDecl).base).exp)
{


#line 1250 "emit.cog"
           

#line 1250 "emit.cog"
           

#line 1250 "emit.cog"
    emitExp(

#line 1250 "emit.cog"
            

#line 1250 "emit.cog"
            &

#line 1250 "emit.cog"
             context, 

#line 1250 "emit.cog"
                      base);
}
else
{


#line 1254 "emit.cog"
        

#line 1254 "emit.cog"
        

#line 1254 "emit.cog"
    emit(

#line 1254 "emit.cog"
         

#line 1254 "emit.cog"
         &

#line 1254 "emit.cog"
          context, 

#line 1254 "emit.cog"
                   "cog::Object");
}


#line 1256 "emit.cog"
       

#line 1256 "emit.cog"
       

#line 1256 "emit.cog"
   emit(

#line 1256 "emit.cog"
        

#line 1256 "emit.cog"
        &

#line 1256 "emit.cog"
         context, 

#line 1256 "emit.cog"
                  ")\n");


#line 1258 "emit.cog"
                                 

#line 1258 "emit.cog"
                                 

#line 1258 "emit.cog"
          DEREF(

#line 1258 "emit.cog"
   context).suppressLineDirective 

#line 1258 "emit.cog"
                                 -= 

#line 1258 "emit.cog"
                                    1;
}
}


#line 1262 "emit.cog"
      

#line 1262 "emit.cog"
      

#line 1262 "emit.cog"
  emit(

#line 1262 "emit.cog"
       

#line 1262 "emit.cog"
       &

#line 1262 "emit.cog"
        context, 

#line 1262 "emit.cog"
                 "void init() {\n");


#line 1263 "emit.cog"
  for(auto dd : 

#line 1263 "emit.cog"
                                   

#line 1263 "emit.cog"
                          DEREF(

#line 1263 "emit.cog"
                moduleDecl).getDecls())
{
{


#line 1265 "emit.cog"
   

#line 1265 "emit.cog"
   auto classDecl = 

#line 1265 "emit.cog"
                                

#line 1265 "emit.cog"
                     

#line 1265 "emit.cog"
                   as<

#line 1265 "emit.cog"
                      ClassDecl> (

#line 1265 "emit.cog"
                                 dd);


#line 1266 "emit.cog"
   if(

#line 1266 "emit.cog"
       

#line 1266 "emit.cog"
       !

#line 1266 "emit.cog"
        classDecl)
{


#line 1266 "emit.cog"
                   continue;
}


#line 1268 "emit.cog"
       

#line 1268 "emit.cog"
       

#line 1268 "emit.cog"
   emit(

#line 1268 "emit.cog"
        

#line 1268 "emit.cog"
        &

#line 1268 "emit.cog"
         context, 

#line 1268 "emit.cog"
                  "registerClass(getClass<");


#line 1269 "emit.cog"
               

#line 1269 "emit.cog"
               

#line 1269 "emit.cog"
   emitDeclName(

#line 1269 "emit.cog"
                

#line 1269 "emit.cog"
                &

#line 1269 "emit.cog"
                 context, 

#line 1269 "emit.cog"
                          classDecl, 

#line 1269 "emit.cog"
                                     kDeclEmitMode_Full);


#line 1270 "emit.cog"
       

#line 1270 "emit.cog"
       

#line 1270 "emit.cog"
   emit(

#line 1270 "emit.cog"
        

#line 1270 "emit.cog"
        &

#line 1270 "emit.cog"
         context, 

#line 1270 "emit.cog"
                  ">());\n");
}
}


#line 1272 "emit.cog"
      

#line 1272 "emit.cog"
      

#line 1272 "emit.cog"
  emit(

#line 1272 "emit.cog"
       

#line 1272 "emit.cog"
       &

#line 1272 "emit.cog"
        context, 

#line 1272 "emit.cog"
                 "}\n");


#line 1274 "emit.cog"
      

#line 1274 "emit.cog"
      

#line 1274 "emit.cog"
  emit(

#line 1274 "emit.cog"
       

#line 1274 "emit.cog"
       &

#line 1274 "emit.cog"
        context, 

#line 1274 "emit.cog"
                 "}\n");


#line 1276 "emit.cog"
  if(

#line 1276 "emit.cog"
     extra)
{


#line 1278 "emit.cog"
       

#line 1278 "emit.cog"
       

#line 1278 "emit.cog"
   emit(

#line 1278 "emit.cog"
        

#line 1278 "emit.cog"
        &

#line 1278 "emit.cog"
         context, 

#line 1278 "emit.cog"
                                      

#line 1278 "emit.cog"
                  TerminatedStringSpan(

#line 1278 "emit.cog"
                                       extra));
}


#line 1281 "emit.cog"
        

#line 1281 "emit.cog"
        

#line 1281 "emit.cog"
  fclose(

#line 1281 "emit.cog"
         stream);
}


#line 1285 "emit.cog"
 void emitModule(

#line 1286 "emit.cog"
           Session session)
{


#line 1288 "emit.cog"
     if(

#line 1288 "emit.cog"
        

#line 1288 "emit.cog"
        !

#line 1288 "emit.cog"
                DEREF(

#line 1288 "emit.cog"
         session).sourceFiles)
{


#line 1289 "emit.cog"
         return;
}


#line 1290 "emit.cog"
     if(

#line 1290 "emit.cog"
        

#line 1290 "emit.cog"
        !

#line 1290 "emit.cog"
                DEREF(

#line 1290 "emit.cog"
         session).moduleDecl)
{


#line 1291 "emit.cog"
         return;
}


#line 1294 "emit.cog"
  

#line 1294 "emit.cog"
  auto moduleDecl = 

#line 1294 "emit.cog"
                          DEREF(

#line 1294 "emit.cog"
                   session).moduleDecl;


#line 1295 "emit.cog"
  

#line 1295 "emit.cog"
  auto moduleName = 

#line 1295 "emit.cog"
                             DEREF(

#line 1295 "emit.cog"
                   moduleDecl).name;


#line 1296 "emit.cog"
              

#line 1296 "emit.cog"
              

#line 1296 "emit.cog"
     cogAssert(

#line 1296 "emit.cog"
               moduleName);


#line 1298 "emit.cog"
     

#line 1298 "emit.cog"
     auto modulePath = 

#line 1298 "emit.cog"
                             DEREF(

#line 1298 "emit.cog"
                      session).modulePath2;


#line 1299 "emit.cog"
              

#line 1299 "emit.cog"
              

#line 1299 "emit.cog"
     cogAssert(

#line 1299 "emit.cog"
               modulePath);


#line 1301 "emit.cog"
  

#line 1301 "emit.cog"
  auto moduleNameText = 

#line 1301 "emit.cog"
                              

#line 1301 "emit.cog"
                       getText(

#line 1301 "emit.cog"
                               moduleName);


#line 1302 "emit.cog"
     

#line 1302 "emit.cog"
     auto modulePathText = 

#line 1302 "emit.cog"
                                 

#line 1302 "emit.cog"
                          getText(

#line 1302 "emit.cog"
                                  modulePath);


#line 1307 "emit.cog"
  

#line 1307 "emit.cog"
  

#line 1307 "emit.cog"
                             

#line 1307 "emit.cog"
               FixedSizeArray<

#line 1307 "emit.cog"
                              1024, 

#line 1307 "emit.cog"
                                    Char>  buffer;


#line 1308 "emit.cog"
         

#line 1308 "emit.cog"
         

#line 1308 "emit.cog"
  sprintf(

#line 1308 "emit.cog"
          buffer, 

#line 1308 "emit.cog"
                  "%s.cog.cpp", 

#line 1308 "emit.cog"
                                              DEREF(

#line 1308 "emit.cog"
                                modulePathText).begin);


#line 1310 "emit.cog"
                 

#line 1310 "emit.cog"
                 

#line 1310 "emit.cog"
  emitModuleInner(

#line 1311 "emit.cog"
   session, 

#line 1312 "emit.cog"
   moduleNameText, 

#line 1313 "emit.cog"
   buffer, 

#line 1314 "emit.cog"
   nullptr);
}


#line 3 "eval.cog"
 

#line 6 "eval.cog"
 void evalModule(

#line 7 "eval.cog"
           Session session)
{


#line 10 "eval.cog"
  

#line 10 "eval.cog"
  auto moduleDecl = 

#line 10 "eval.cog"
                          DEREF(

#line 10 "eval.cog"
                   session).moduleDecl;


#line 13 "eval.cog"
  if(

#line 13 "eval.cog"
     

#line 13 "eval.cog"
     !

#line 13 "eval.cog"
      moduleDecl)
{


#line 14 "eval.cog"
   return;
}


#line 16 "eval.cog"
                 

#line 16 "eval.cog"
                 

#line 16 "eval.cog"
  emitModuleInner(

#line 17 "eval.cog"
   session, 

#line 18 "eval.cog"
   "cogc_eval", 

#line 19 "eval.cog"
   "cogc-eval.cog.cpp", 

#line 20 "eval.cog"
   "COG_EXPORT int _cogc_eval() { return cogc_eval::main(0, null); }\n");


#line 22 "eval.cog"
             

#line 22 "eval.cog"
             

#line 22 "eval.cog"
  loadAndEval(

#line 22 "eval.cog"
              "cogc-eval.cog.cpp");
}


#line 3 "lexer.cog"
 

#line 26 "source.cog"
 

#line 5 "token.cog"
 typedef 

#line 5 "token.cog"
                        UInt16 TokenFlags;


#line 5 "lexer.cog"
 

#line 15 "lexer.cog"
 void initializeLexer(

#line 16 "lexer.cog"
              

#line 16 "lexer.cog"
         Lexer

#line 16 "lexer.cog"
              * lexer, 

#line 17 "lexer.cog"
           Session session, 

#line 18 "lexer.cog"
                  

#line 18 "lexer.cog"
        SourceFile

#line 18 "lexer.cog"
                  * file)
{


#line 20 "lexer.cog"
       DEREF(

#line 20 "lexer.cog"
  lexer).session = 

#line 20 "lexer.cog"
                   session;


#line 21 "lexer.cog"
       DEREF(

#line 21 "lexer.cog"
  lexer).file = 

#line 21 "lexer.cog"
                file;


#line 23 "lexer.cog"
       DEREF(

#line 23 "lexer.cog"
  lexer).cursor = 

#line 23 "lexer.cog"
                          DEREF(

#line 23 "lexer.cog"
                     DEREF(

#line 23 "lexer.cog"
                 file).text).begin;


#line 24 "lexer.cog"
       DEREF(

#line 24 "lexer.cog"
  lexer).tokenFlags = 

#line 26 "lexer.cog"
   

#line 25 "lexer.cog"
   kTokenFlag_AtStartOfLine 

#line 26 "lexer.cog"
   | 

#line 26 "lexer.cog"
     kTokenFlag_AfterSpace;


#line 28 "lexer.cog"
       DEREF(

#line 28 "lexer.cog"
  lexer).rawStartPtr = 

#line 28 "lexer.cog"
                                                     

#line 28 "lexer.cog"
                      cast<

#line 28 "lexer.cog"
                           UIntPtr>(

#line 28 "lexer.cog"
                                             DEREF(

#line 28 "lexer.cog"
                                        DEREF(

#line 28 "lexer.cog"
                                    file).text).begin) 

#line 28 "lexer.cog"
                                                     - 

#line 28 "lexer.cog"
                                                                    DEREF(

#line 28 "lexer.cog"
                                                           DEREF(

#line 28 "lexer.cog"
                                                       file).firstLoc).raw;
}


#line 31 "lexer.cog"
 void finalizeLexer(

#line 32 "lexer.cog"
              

#line 32 "lexer.cog"
         Lexer

#line 32 "lexer.cog"
              * lexer)
{
}


#line 36 "lexer.cog"
 

#line 38 "lexer.cog"
                   

#line 38 "lexer.cog"
     DiagnosticSink

#line 38 "lexer.cog"
                   * getSink(

#line 37 "lexer.cog"
              

#line 37 "lexer.cog"
         Lexer

#line 37 "lexer.cog"
              * lexer)
{


#line 40 "lexer.cog"
  return 

#line 40 "lexer.cog"
         

#line 40 "lexer.cog"
         &

#line 40 "lexer.cog"
                       DEREF(

#line 40 "lexer.cog"
               DEREF(

#line 40 "lexer.cog"
          lexer).session).sink;
}


#line 43 "lexer.cog"
 

#line 43 "lexer.cog"
                                 Int peekByte(

#line 43 "lexer.cog"
                           

#line 43 "lexer.cog"
                      Lexer

#line 43 "lexer.cog"
                           * lexer)
{


#line 45 "lexer.cog"
  return 

#line 45 "lexer.cog"
         

#line 45 "lexer.cog"
         *

#line 45 "lexer.cog"
               DEREF(

#line 45 "lexer.cog"
          lexer).cursor;
}


#line 48 "lexer.cog"
 

#line 48 "lexer.cog"
                                      Int peekCodePoint(

#line 48 "lexer.cog"
                                

#line 48 "lexer.cog"
                           Lexer

#line 48 "lexer.cog"
                                * lexer)
{


#line 51 "lexer.cog"
  return 

#line 51 "lexer.cog"
                 

#line 51 "lexer.cog"
         peekByte(

#line 51 "lexer.cog"
                  lexer);
}


#line 54 "lexer.cog"
 

#line 54 "lexer.cog"
                                SourceLoc peekLoc(

#line 54 "lexer.cog"
                          

#line 54 "lexer.cog"
                     Lexer

#line 54 "lexer.cog"
                          * lexer)
{


#line 56 "lexer.cog"
  

#line 56 "lexer.cog"
  

#line 56 "lexer.cog"
            SourceLoc loc;


#line 57 "lexer.cog"
     DEREF(

#line 57 "lexer.cog"
  loc).raw = 

#line 57 "lexer.cog"
                                        

#line 57 "lexer.cog"
            cast<

#line 57 "lexer.cog"
                 UIntPtr>(

#line 57 "lexer.cog"
                               DEREF(

#line 57 "lexer.cog"
                          lexer).cursor) 

#line 57 "lexer.cog"
                                        - 

#line 57 "lexer.cog"
                                               DEREF(

#line 57 "lexer.cog"
                                          lexer).rawStartPtr;


#line 58 "lexer.cog"
  return 

#line 58 "lexer.cog"
         loc;
}


#line 61 "lexer.cog"
 void advanceByte(

#line 61 "lexer.cog"
                              

#line 61 "lexer.cog"
                         Lexer

#line 61 "lexer.cog"
                              * lexer)
{


#line 63 "lexer.cog"
           

#line 63 "lexer.cog"
           

#line 63 "lexer.cog"
  cogAssert(

#line 63 "lexer.cog"
                         

#line 63 "lexer.cog"
                 DEREF(

#line 63 "lexer.cog"
            lexer).cursor 

#line 63 "lexer.cog"
                         != 

#line 63 "lexer.cog"
                                           DEREF(

#line 63 "lexer.cog"
                                      DEREF(

#line 63 "lexer.cog"
                                 DEREF(

#line 63 "lexer.cog"
                            lexer).file).text).end);


#line 64 "lexer.cog"
              

#line 64 "lexer.cog"
              

#line 64 "lexer.cog"
       DEREF(

#line 64 "lexer.cog"
  lexer).cursor

#line 64 "lexer.cog"
              ++;
}


#line 67 "lexer.cog"
 

#line 67 "lexer.cog"
                         Bool isAlpha(

#line 67 "lexer.cog"
                 Int c)
{


#line 69 "lexer.cog"
  return 

#line 70 "lexer.cog"
   

#line 69 "lexer.cog"
         (

#line 69 "lexer.cog"
                     

#line 69 "lexer.cog"
          (

#line 69 "lexer.cog"
             

#line 69 "lexer.cog"
           c 

#line 69 "lexer.cog"
             >= 

#line 69 "lexer.cog"
                'a') 

#line 69 "lexer.cog"
                     && 

#line 69 "lexer.cog"
                        (

#line 69 "lexer.cog"
                           

#line 69 "lexer.cog"
                         c 

#line 69 "lexer.cog"
                           <= 

#line 69 "lexer.cog"
                              'z')) 

#line 70 "lexer.cog"
   || 

#line 71 "lexer.cog"
   

#line 70 "lexer.cog"
      (

#line 70 "lexer.cog"
                  

#line 70 "lexer.cog"
       (

#line 70 "lexer.cog"
          

#line 70 "lexer.cog"
        c 

#line 70 "lexer.cog"
          >= 

#line 70 "lexer.cog"
             'A') 

#line 70 "lexer.cog"
                  && 

#line 70 "lexer.cog"
                     (

#line 70 "lexer.cog"
                        

#line 70 "lexer.cog"
                      c 

#line 70 "lexer.cog"
                        <= 

#line 70 "lexer.cog"
                           'Z')) 

#line 71 "lexer.cog"
   || 

#line 71 "lexer.cog"
      (

#line 71 "lexer.cog"
         

#line 71 "lexer.cog"
       c 

#line 71 "lexer.cog"
         == 

#line 71 "lexer.cog"
            '_');
}


#line 74 "lexer.cog"
 

#line 74 "lexer.cog"
                         Bool isDigit(

#line 74 "lexer.cog"
                 Int c)
{


#line 76 "lexer.cog"
  return 

#line 76 "lexer.cog"
                    

#line 76 "lexer.cog"
         (

#line 76 "lexer.cog"
            

#line 76 "lexer.cog"
          c 

#line 76 "lexer.cog"
            >= 

#line 76 "lexer.cog"
               '0') 

#line 76 "lexer.cog"
                    && 

#line 76 "lexer.cog"
                       (

#line 76 "lexer.cog"
                          

#line 76 "lexer.cog"
                        c 

#line 76 "lexer.cog"
                          <= 

#line 76 "lexer.cog"
                             '9');
}


#line 79 "lexer.cog"
 

#line 79 "lexer.cog"
                            Bool isAlphaNum(

#line 79 "lexer.cog"
                    Int c)
{


#line 81 "lexer.cog"
  return 

#line 81 "lexer.cog"
                    

#line 81 "lexer.cog"
                

#line 81 "lexer.cog"
         isAlpha(

#line 81 "lexer.cog"
                 c) 

#line 81 "lexer.cog"
                    || 

#line 81 "lexer.cog"
                              

#line 81 "lexer.cog"
                       isDigit(

#line 81 "lexer.cog"
                               c);
}


#line 84 "lexer.cog"
 

#line 84 "lexer.cog"
                                Bool isOperatorChar(

#line 84 "lexer.cog"
                        Int c)
{


#line 86 "lexer.cog"
  return 

#line 86 "lexer.cog"
                                     

#line 86 "lexer.cog"
               

#line 86 "lexer.cog"
         strchr(

#line 86 "lexer.cog"
                "~!%^&*-+=|<>?/", 

#line 86 "lexer.cog"
                                  c) 

#line 86 "lexer.cog"
                                     != 

#line 86 "lexer.cog"
                                        0;
}


#line 89 "lexer.cog"
 

#line 89 "lexer.cog"
                              Bool isWhiteSpace(

#line 89 "lexer.cog"
                      Int c)
{


#line 91 "lexer.cog"
  return 

#line 91 "lexer.cog"
                          

#line 91 "lexer.cog"
               

#line 91 "lexer.cog"
         strchr(

#line 91 "lexer.cog"
                " \t", 

#line 91 "lexer.cog"
                       c) 

#line 91 "lexer.cog"
                          != 

#line 91 "lexer.cog"
                             0;
}


#line 94 "lexer.cog"
 void lexDigits(

#line 95 "lexer.cog"
                 

#line 95 "lexer.cog"
            Lexer

#line 95 "lexer.cog"
                 * lexer, 

#line 96 "lexer.cog"
           Int base)
{


#line 98 "lexer.cog"
     {
for(;;)
{
{


#line 100 "lexer.cog"
         

#line 100 "lexer.cog"
         auto c = 

#line 100 "lexer.cog"
                         

#line 100 "lexer.cog"
                 peekByte(

#line 100 "lexer.cog"
                          lexer);


#line 101 "lexer.cog"
         switch(

#line 101 "lexer.cog"
                c)
{
case 

#line 103 "lexer.cog"
              '0':
case 

#line 103 "lexer.cog"
                        '1':
case 

#line 103 "lexer.cog"
                                  '2':
case 

#line 103 "lexer.cog"
                                            '3':
case 

#line 103 "lexer.cog"
                                                      '4':
case 

#line 104 "lexer.cog"
              '5':
case 

#line 104 "lexer.cog"
                        '6':
case 

#line 104 "lexer.cog"
                                  '7':
case 

#line 104 "lexer.cog"
                                            '8':
case 

#line 104 "lexer.cog"
                                                      '9':
{


#line 105 "lexer.cog"
                        

#line 105 "lexer.cog"
                        

#line 105 "lexer.cog"
             advanceByte(

#line 105 "lexer.cog"
                         lexer);
}
{


#line 106 "lexer.cog"
             continue;
}
case 

#line 108 "lexer.cog"
              'a':
case 

#line 108 "lexer.cog"
                        'b':
case 

#line 108 "lexer.cog"
                                  'c':
case 

#line 108 "lexer.cog"
                                            'd':
case 

#line 108 "lexer.cog"
                                                      'e':
case 

#line 108 "lexer.cog"
                                                                'f':
case 

#line 109 "lexer.cog"
              'A':
case 

#line 109 "lexer.cog"
                        'B':
case 

#line 109 "lexer.cog"
                                  'C':
case 

#line 109 "lexer.cog"
                                            'D':
case 

#line 109 "lexer.cog"
                                                      'E':
case 

#line 109 "lexer.cog"
                                                                'F':
{


#line 110 "lexer.cog"
             if(

#line 110 "lexer.cog"
                     

#line 110 "lexer.cog"
                base 

#line 110 "lexer.cog"
                     > 

#line 110 "lexer.cog"
                       10)
{


#line 112 "lexer.cog"
                            

#line 112 "lexer.cog"
                            

#line 112 "lexer.cog"
                 advanceByte(

#line 112 "lexer.cog"
                             lexer);


#line 113 "lexer.cog"
                 continue;
}
}
{


#line 115 "lexer.cog"
             break;
}
default:
{


#line 118 "lexer.cog"
             return;
}
}
}
}}
}


#line 123 "lexer.cog"
 

#line 126 "lexer.cog"
     Bool peekNumberExponentMarker(

#line 124 "lexer.cog"
                 

#line 124 "lexer.cog"
            Lexer

#line 124 "lexer.cog"
                 * lexer, 

#line 125 "lexer.cog"
        Int base)
{


#line 128 "lexer.cog"
     switch(

#line 128 "lexer.cog"
                    

#line 128 "lexer.cog"
            peekByte(

#line 128 "lexer.cog"
                     lexer))
{
case 

#line 130 "lexer.cog"
          'e':
case 

#line 130 "lexer.cog"
                    'E':
{


#line 131 "lexer.cog"
         return 

#line 131 "lexer.cog"
                     

#line 131 "lexer.cog"
                base 

#line 131 "lexer.cog"
                     == 

#line 131 "lexer.cog"
                        10;
}
case 

#line 133 "lexer.cog"
          'p':
case 

#line 133 "lexer.cog"
                    'P':
{


#line 134 "lexer.cog"
         return 

#line 134 "lexer.cog"
                     

#line 134 "lexer.cog"
                base 

#line 134 "lexer.cog"
                     == 

#line 134 "lexer.cog"
                        16;
}
default:
{


#line 137 "lexer.cog"
         return 

#line 137 "lexer.cog"
                false;
}
}
}


#line 141 "lexer.cog"
 

#line 144 "lexer.cog"
     TokenCode lexNumber(

#line 142 "lexer.cog"
                 

#line 142 "lexer.cog"
            Lexer

#line 142 "lexer.cog"
                 * lexer, 

#line 143 "lexer.cog"
           Int base)
{


#line 146 "lexer.cog"
     

#line 146 "lexer.cog"
     auto code = 

#line 146 "lexer.cog"
                kTokenCode_IntegerLiteral;


#line 149 "lexer.cog"
              

#line 149 "lexer.cog"
              

#line 149 "lexer.cog"
     lexDigits(

#line 149 "lexer.cog"
               lexer, 

#line 149 "lexer.cog"
                      base);


#line 152 "lexer.cog"
     if(

#line 152 "lexer.cog"
                        

#line 152 "lexer.cog"
                

#line 152 "lexer.cog"
        peekByte(

#line 152 "lexer.cog"
                 lexer) 

#line 152 "lexer.cog"
                        == 

#line 152 "lexer.cog"
                           '.')
{


#line 154 "lexer.cog"
                    

#line 154 "lexer.cog"
                    

#line 154 "lexer.cog"
         advanceByte(

#line 154 "lexer.cog"
                     lexer);


#line 155 "lexer.cog"
         code = 

#line 155 "lexer.cog"
                kTokenCode_FloatingPointLiteral;


#line 156 "lexer.cog"
                  

#line 156 "lexer.cog"
                  

#line 156 "lexer.cog"
         lexDigits(

#line 156 "lexer.cog"
                   lexer, 

#line 156 "lexer.cog"
                          base);
}


#line 160 "lexer.cog"
     if(

#line 160 "lexer.cog"
                                

#line 160 "lexer.cog"
        peekNumberExponentMarker(

#line 160 "lexer.cog"
                                 lexer, 

#line 160 "lexer.cog"
                                        base))
{


#line 162 "lexer.cog"
                    

#line 162 "lexer.cog"
                    

#line 162 "lexer.cog"
         advanceByte(

#line 162 "lexer.cog"
                     lexer);


#line 163 "lexer.cog"
         code = 

#line 163 "lexer.cog"
                kTokenCode_FloatingPointLiteral;


#line 166 "lexer.cog"
         switch(

#line 166 "lexer.cog"
                        

#line 166 "lexer.cog"
                peekByte(

#line 166 "lexer.cog"
                         lexer))
{
case 

#line 168 "lexer.cog"
              '+':
case 

#line 168 "lexer.cog"
                        '-':
{


#line 169 "lexer.cog"
                        

#line 169 "lexer.cog"
                        

#line 169 "lexer.cog"
             advanceByte(

#line 169 "lexer.cog"
                         lexer);
}
{


#line 170 "lexer.cog"
             break;
}
default:
{


#line 173 "lexer.cog"
             break;
}
}


#line 177 "lexer.cog"
                  

#line 177 "lexer.cog"
                  

#line 177 "lexer.cog"
         lexDigits(

#line 177 "lexer.cog"
                   lexer, 

#line 177 "lexer.cog"
                          base);
}


#line 182 "lexer.cog"
     return 

#line 182 "lexer.cog"
            code;
}


#line 185 "lexer.cog"
 

#line 187 "lexer.cog"
     TokenCode lexIdentifier(

#line 186 "lexer.cog"
              

#line 186 "lexer.cog"
         Lexer

#line 186 "lexer.cog"
              * lexer)
{


#line 189 "lexer.cog"
  {
for(;;)
{
{


#line 191 "lexer.cog"
   

#line 191 "lexer.cog"
   auto c = 

#line 191 "lexer.cog"
                   

#line 191 "lexer.cog"
           peekByte(

#line 191 "lexer.cog"
                    lexer);


#line 192 "lexer.cog"
   if(

#line 192 "lexer.cog"
      

#line 192 "lexer.cog"
      !

#line 192 "lexer.cog"
                 

#line 192 "lexer.cog"
       isAlphaNum(

#line 192 "lexer.cog"
                  c))
{


#line 193 "lexer.cog"
    break;
}


#line 195 "lexer.cog"
              

#line 195 "lexer.cog"
              

#line 195 "lexer.cog"
   advanceByte(

#line 195 "lexer.cog"
               lexer);
}
}}


#line 197 "lexer.cog"
  return 

#line 197 "lexer.cog"
         kTokenCode_Identifier;
}


#line 200 "lexer.cog"
 

#line 202 "lexer.cog"
     TokenCode lexOperator(

#line 201 "lexer.cog"
              

#line 201 "lexer.cog"
         Lexer

#line 201 "lexer.cog"
              * lexer)
{


#line 204 "lexer.cog"
  {
for(;;)
{
{


#line 206 "lexer.cog"
   

#line 206 "lexer.cog"
   auto c = 

#line 206 "lexer.cog"
                   

#line 206 "lexer.cog"
           peekByte(

#line 206 "lexer.cog"
                    lexer);


#line 207 "lexer.cog"
   if(

#line 207 "lexer.cog"
      

#line 207 "lexer.cog"
      !

#line 207 "lexer.cog"
                     

#line 207 "lexer.cog"
       isOperatorChar(

#line 207 "lexer.cog"
                      c))
{


#line 208 "lexer.cog"
    break;
}


#line 210 "lexer.cog"
              

#line 210 "lexer.cog"
              

#line 210 "lexer.cog"
   advanceByte(

#line 210 "lexer.cog"
               lexer);
}
}}


#line 212 "lexer.cog"
  return 

#line 212 "lexer.cog"
         kTokenCode_InfixOperator;
}


#line 215 "lexer.cog"
 

#line 217 "lexer.cog"
     TokenCode lexLineComment(

#line 216 "lexer.cog"
              

#line 216 "lexer.cog"
         Lexer

#line 216 "lexer.cog"
              * lexer)
{


#line 219 "lexer.cog"
  {
for(;;)
{
{


#line 221 "lexer.cog"
   

#line 221 "lexer.cog"
   auto c = 

#line 221 "lexer.cog"
                   

#line 221 "lexer.cog"
           peekByte(

#line 221 "lexer.cog"
                    lexer);


#line 222 "lexer.cog"
   switch(

#line 222 "lexer.cog"
          c)
{
case 

#line 224 "lexer.cog"
        '\r':
case 

#line 224 "lexer.cog"
                   '\n':
case 

#line 224 "lexer.cog"
                              0:
{


#line 225 "lexer.cog"
    return 

#line 225 "lexer.cog"
           kTokenCode_LineComment;
}
default:
{


#line 228 "lexer.cog"
               

#line 228 "lexer.cog"
               

#line 228 "lexer.cog"
    advanceByte(

#line 228 "lexer.cog"
                lexer);
}
{


#line 229 "lexer.cog"
    break;
}
}
}
}}
}


#line 234 "lexer.cog"
 

#line 236 "lexer.cog"
     TokenCode lexBlockComment(

#line 235 "lexer.cog"
              

#line 235 "lexer.cog"
         Lexer

#line 235 "lexer.cog"
              * lexer)
{


#line 238 "lexer.cog"
  {
for(;;)
{
{


#line 240 "lexer.cog"
   

#line 240 "lexer.cog"
   auto c = 

#line 240 "lexer.cog"
                   

#line 240 "lexer.cog"
           peekByte(

#line 240 "lexer.cog"
                    lexer);


#line 241 "lexer.cog"
   switch(

#line 241 "lexer.cog"
          c)
{
case 

#line 243 "lexer.cog"
        0:
{


#line 245 "lexer.cog"
    return 

#line 245 "lexer.cog"
           kTokenCode_BlockComment;
}
case 

#line 247 "lexer.cog"
        '*':
{


#line 248 "lexer.cog"
               

#line 248 "lexer.cog"
               

#line 248 "lexer.cog"
    advanceByte(

#line 248 "lexer.cog"
                lexer);
}
{


#line 249 "lexer.cog"
    switch(

#line 249 "lexer.cog"
                   

#line 249 "lexer.cog"
           peekByte(

#line 249 "lexer.cog"
                    lexer))
{
case 

#line 251 "lexer.cog"
         '/':
{


#line 252 "lexer.cog"
                

#line 252 "lexer.cog"
                

#line 252 "lexer.cog"
     advanceByte(

#line 252 "lexer.cog"
                 lexer);
}
{


#line 253 "lexer.cog"
     return 

#line 253 "lexer.cog"
            kTokenCode_BlockComment;
}
default:
{


#line 255 "lexer.cog"
     break;
}
}
}
{


#line 257 "lexer.cog"
    break;
}
default:
{


#line 260 "lexer.cog"
               

#line 260 "lexer.cog"
               

#line 260 "lexer.cog"
    advanceByte(

#line 260 "lexer.cog"
                lexer);
}
{


#line 261 "lexer.cog"
    break;
}
}
}
}}
}


#line 266 "lexer.cog"
 

#line 268 "lexer.cog"
     TokenCode lexWhiteSpace(

#line 267 "lexer.cog"
              

#line 267 "lexer.cog"
         Lexer

#line 267 "lexer.cog"
              * lexer)
{


#line 270 "lexer.cog"
  {
for(;;)
{
{


#line 272 "lexer.cog"
   

#line 272 "lexer.cog"
   auto c = 

#line 272 "lexer.cog"
                   

#line 272 "lexer.cog"
           peekByte(

#line 272 "lexer.cog"
                    lexer);


#line 273 "lexer.cog"
   if(

#line 273 "lexer.cog"
      

#line 273 "lexer.cog"
      !

#line 273 "lexer.cog"
                   

#line 273 "lexer.cog"
       isWhiteSpace(

#line 273 "lexer.cog"
                    c))
{


#line 275 "lexer.cog"
    return 

#line 275 "lexer.cog"
           kTokenCode_WhiteSpace;
}


#line 278 "lexer.cog"
              

#line 278 "lexer.cog"
              

#line 278 "lexer.cog"
   advanceByte(

#line 278 "lexer.cog"
               lexer);
}
}}
}


#line 282 "lexer.cog"
 void lexStringLiteral(

#line 283 "lexer.cog"
              

#line 283 "lexer.cog"
         Lexer

#line 283 "lexer.cog"
              * lexer, 

#line 284 "lexer.cog"
             Int delimeter)
{


#line 286 "lexer.cog"
  {
for(;;)
{
{


#line 288 "lexer.cog"
   

#line 288 "lexer.cog"
   auto c = 

#line 288 "lexer.cog"
                   

#line 288 "lexer.cog"
           peekByte(

#line 288 "lexer.cog"
                    lexer);


#line 289 "lexer.cog"
   if(

#line 289 "lexer.cog"
        

#line 289 "lexer.cog"
      c 

#line 289 "lexer.cog"
        == 

#line 289 "lexer.cog"
           delimeter)
{


#line 291 "lexer.cog"
               

#line 291 "lexer.cog"
               

#line 291 "lexer.cog"
    advanceByte(

#line 291 "lexer.cog"
                lexer);


#line 292 "lexer.cog"
    return;
}


#line 295 "lexer.cog"
   switch(

#line 295 "lexer.cog"
          c)
{
case 

#line 297 "lexer.cog"
        0:
case 

#line 297 "lexer.cog"
                '\r':
case 

#line 297 "lexer.cog"
                           '\n':
{


#line 299 "lexer.cog"
    return;
}
case 

#line 301 "lexer.cog"
        '\\':
{
{


#line 303 "lexer.cog"
                

#line 303 "lexer.cog"
                

#line 303 "lexer.cog"
     advanceByte(

#line 303 "lexer.cog"
                 lexer);


#line 304 "lexer.cog"
     

#line 304 "lexer.cog"
     auto d = 

#line 304 "lexer.cog"
                     

#line 304 "lexer.cog"
             peekByte(

#line 304 "lexer.cog"
                      lexer);


#line 305 "lexer.cog"
     switch(

#line 305 "lexer.cog"
            d)
{
case 

#line 307 "lexer.cog"
          0:
case 

#line 307 "lexer.cog"
                  '\r':
case 

#line 307 "lexer.cog"
                             '\n':
{


#line 309 "lexer.cog"
      return;
}
default:
{


#line 312 "lexer.cog"
                 

#line 312 "lexer.cog"
                 

#line 312 "lexer.cog"
      advanceByte(

#line 312 "lexer.cog"
                  lexer);
}
{


#line 313 "lexer.cog"
      break;
}
}
}
}
{


#line 317 "lexer.cog"
    break;
}
default:
{


#line 320 "lexer.cog"
               

#line 320 "lexer.cog"
               

#line 320 "lexer.cog"
    advanceByte(

#line 320 "lexer.cog"
                lexer);
}
{


#line 321 "lexer.cog"
    continue;
}
}
}
}}
}


#line 327 "lexer.cog"
 

#line 329 "lexer.cog"
     TokenCode lexTokenImpl(

#line 328 "lexer.cog"
              

#line 328 "lexer.cog"
         Lexer

#line 328 "lexer.cog"
              * lexer)
{


#line 331 "lexer.cog"
  

#line 331 "lexer.cog"
  auto c = 

#line 331 "lexer.cog"
                  

#line 331 "lexer.cog"
          peekByte(

#line 331 "lexer.cog"
                   lexer);


#line 332 "lexer.cog"
  switch(

#line 332 "lexer.cog"
         c)
{
case 

#line 334 "lexer.cog"
       0:
{
{


#line 336 "lexer.cog"
    if(

#line 336 "lexer.cog"
                    

#line 336 "lexer.cog"
            DEREF(

#line 336 "lexer.cog"
       lexer).cursor 

#line 336 "lexer.cog"
                    == 

#line 336 "lexer.cog"
                                      DEREF(

#line 336 "lexer.cog"
                                 DEREF(

#line 336 "lexer.cog"
                            DEREF(

#line 336 "lexer.cog"
                       lexer).file).text).end)
{


#line 338 "lexer.cog"
     return 

#line 338 "lexer.cog"
            kTokenCode_EndOfFile;
}
}
}
{


#line 341 "lexer.cog"
   break;
}
case 

#line 343 "lexer.cog"
       '\r':
case 

#line 343 "lexer.cog"
                  '\n':
{


#line 344 "lexer.cog"
              

#line 344 "lexer.cog"
              

#line 344 "lexer.cog"
   advanceByte(

#line 344 "lexer.cog"
               lexer);
}
{
{


#line 346 "lexer.cog"
    

#line 346 "lexer.cog"
    auto d = 

#line 346 "lexer.cog"
                    

#line 346 "lexer.cog"
            peekByte(

#line 346 "lexer.cog"
                     lexer);


#line 347 "lexer.cog"
    if(

#line 347 "lexer.cog"
               

#line 347 "lexer.cog"
       (

#line 347 "lexer.cog"
          

#line 347 "lexer.cog"
        c 

#line 347 "lexer.cog"
          ^ 

#line 347 "lexer.cog"
            d) 

#line 347 "lexer.cog"
               == 

#line 347 "lexer.cog"
                  (

#line 347 "lexer.cog"
                        

#line 347 "lexer.cog"
                   '\r' 

#line 347 "lexer.cog"
                        ^ 

#line 347 "lexer.cog"
                          '\n'))
{


#line 349 "lexer.cog"
                

#line 349 "lexer.cog"
                

#line 349 "lexer.cog"
     advanceByte(

#line 349 "lexer.cog"
                 lexer);
}


#line 351 "lexer.cog"
    return 

#line 351 "lexer.cog"
           kTokenCode_EndOfLine;
}
}
{


#line 353 "lexer.cog"
   break;
}
case 

#line 355 "lexer.cog"
       ' ':
case 

#line 355 "lexer.cog"
                 '\t':
{


#line 356 "lexer.cog"
   return 

#line 356 "lexer.cog"
                       

#line 356 "lexer.cog"
          lexWhiteSpace(

#line 356 "lexer.cog"
                        lexer);
}
case 

#line 358 "lexer.cog"
       '\"':
{


#line 359 "lexer.cog"
              

#line 359 "lexer.cog"
              

#line 359 "lexer.cog"
   advanceByte(

#line 359 "lexer.cog"
               lexer);
}
{


#line 360 "lexer.cog"
                   

#line 360 "lexer.cog"
                   

#line 360 "lexer.cog"
   lexStringLiteral(

#line 360 "lexer.cog"
                    lexer, 

#line 360 "lexer.cog"
                           c);
}
{


#line 361 "lexer.cog"
   return 

#line 361 "lexer.cog"
          kTokenCode_StringLiteral;
}
case 

#line 363 "lexer.cog"
       '\'':
{


#line 364 "lexer.cog"
              

#line 364 "lexer.cog"
              

#line 364 "lexer.cog"
   advanceByte(

#line 364 "lexer.cog"
               lexer);
}
{


#line 365 "lexer.cog"
                   

#line 365 "lexer.cog"
                   

#line 365 "lexer.cog"
   lexStringLiteral(

#line 365 "lexer.cog"
                    lexer, 

#line 365 "lexer.cog"
                           c);
}
{


#line 366 "lexer.cog"
   return 

#line 366 "lexer.cog"
          kTokenCode_CharacterLiteral;
}
case 

#line 368 "lexer.cog"
       '/':
{


#line 369 "lexer.cog"
              

#line 369 "lexer.cog"
              

#line 369 "lexer.cog"
   advanceByte(

#line 369 "lexer.cog"
               lexer);
}
{
{


#line 371 "lexer.cog"
    

#line 371 "lexer.cog"
    auto d = 

#line 371 "lexer.cog"
                    

#line 371 "lexer.cog"
            peekByte(

#line 371 "lexer.cog"
                     lexer);


#line 372 "lexer.cog"
    switch(

#line 372 "lexer.cog"
           d)
{
case 

#line 374 "lexer.cog"
         '/':
{


#line 375 "lexer.cog"
     return 

#line 375 "lexer.cog"
                          

#line 375 "lexer.cog"
            lexLineComment(

#line 375 "lexer.cog"
                           lexer);
}
case 

#line 376 "lexer.cog"
         '*':
{


#line 377 "lexer.cog"
     return 

#line 377 "lexer.cog"
                           

#line 377 "lexer.cog"
            lexBlockComment(

#line 377 "lexer.cog"
                            lexer);
}
default:
{


#line 379 "lexer.cog"
     return 

#line 379 "lexer.cog"
                       

#line 379 "lexer.cog"
            lexOperator(

#line 379 "lexer.cog"
                        lexer);
}
}
}
}
{


#line 382 "lexer.cog"
   break;
}
case 

#line 384 "lexer.cog"
       '-':
{


#line 385 "lexer.cog"
              

#line 385 "lexer.cog"
              

#line 385 "lexer.cog"
   advanceByte(

#line 385 "lexer.cog"
               lexer);
}
{
{


#line 387 "lexer.cog"
    

#line 387 "lexer.cog"
    auto d = 

#line 387 "lexer.cog"
                    

#line 387 "lexer.cog"
            peekByte(

#line 387 "lexer.cog"
                     lexer);


#line 388 "lexer.cog"
    switch(

#line 388 "lexer.cog"
           d)
{
case 

#line 390 "lexer.cog"
         '>':
{


#line 392 "lexer.cog"
                

#line 392 "lexer.cog"
                

#line 392 "lexer.cog"
     advanceByte(

#line 392 "lexer.cog"
                 lexer);
}
{


#line 393 "lexer.cog"
     return 

#line 393 "lexer.cog"
            kTokenCode_Arrow;
}
default:
{


#line 395 "lexer.cog"
     return 

#line 395 "lexer.cog"
                       

#line 395 "lexer.cog"
            lexOperator(

#line 395 "lexer.cog"
                        lexer);
}
}
}
}
{


#line 398 "lexer.cog"
   break;
}
case 

#line 400 "lexer.cog"
       '=':
{


#line 401 "lexer.cog"
              

#line 401 "lexer.cog"
              

#line 401 "lexer.cog"
   advanceByte(

#line 401 "lexer.cog"
               lexer);
}
{
{


#line 403 "lexer.cog"
    

#line 403 "lexer.cog"
    auto d = 

#line 403 "lexer.cog"
                    

#line 403 "lexer.cog"
            peekByte(

#line 403 "lexer.cog"
                     lexer);


#line 404 "lexer.cog"
    if(

#line 404 "lexer.cog"
                     

#line 404 "lexer.cog"
       isOperatorChar(

#line 404 "lexer.cog"
                      d))
{


#line 406 "lexer.cog"
     return 

#line 406 "lexer.cog"
                       

#line 406 "lexer.cog"
            lexOperator(

#line 406 "lexer.cog"
                        lexer);
}
else
{


#line 410 "lexer.cog"
     return 

#line 410 "lexer.cog"
            kTokenCode_Assign;
}
}
}
{


#line 413 "lexer.cog"
   break;
}
case 

#line 415 "lexer.cog"
       '.':
{


#line 416 "lexer.cog"
              

#line 416 "lexer.cog"
              

#line 416 "lexer.cog"
   advanceByte(

#line 416 "lexer.cog"
               lexer);
}
{


#line 417 "lexer.cog"
   if(

#line 417 "lexer.cog"
                      

#line 417 "lexer.cog"
              

#line 417 "lexer.cog"
      peekByte(

#line 417 "lexer.cog"
               lexer) 

#line 417 "lexer.cog"
                      == 

#line 417 "lexer.cog"
                         '.')
{


#line 420 "lexer.cog"
    {
for(;;)
{
{


#line 422 "lexer.cog"
                

#line 422 "lexer.cog"
                

#line 422 "lexer.cog"
     advanceByte(

#line 422 "lexer.cog"
                 lexer);


#line 423 "lexer.cog"
     if(

#line 423 "lexer.cog"
                        

#line 423 "lexer.cog"
                

#line 423 "lexer.cog"
        peekByte(

#line 423 "lexer.cog"
                 lexer) 

#line 423 "lexer.cog"
                        != 

#line 423 "lexer.cog"
                           '.')
{


#line 424 "lexer.cog"
      break;
}
}
}}


#line 426 "lexer.cog"
    return 

#line 426 "lexer.cog"
           kTokenCode_InfixOperator;
}
else
{


#line 430 "lexer.cog"
    return 

#line 430 "lexer.cog"
           kTokenCode_Dot;
}
}
case 

#line 433 "lexer.cog"
          '0':
{


#line 434 "lexer.cog"
                    

#line 434 "lexer.cog"
                    

#line 434 "lexer.cog"
         advanceByte(

#line 434 "lexer.cog"
                     lexer);
}
{
{


#line 436 "lexer.cog"
             

#line 436 "lexer.cog"
             auto d = 

#line 436 "lexer.cog"
                             

#line 436 "lexer.cog"
                     peekByte(

#line 436 "lexer.cog"
                              lexer);


#line 437 "lexer.cog"
             switch(

#line 437 "lexer.cog"
                    d)
{
case 

#line 439 "lexer.cog"
                  'x':
case 

#line 439 "lexer.cog"
                            'X':
{


#line 440 "lexer.cog"
                            

#line 440 "lexer.cog"
                            

#line 440 "lexer.cog"
                 advanceByte(

#line 440 "lexer.cog"
                             lexer);
}
{


#line 441 "lexer.cog"
                 return 

#line 441 "lexer.cog"
                                 

#line 441 "lexer.cog"
                        lexNumber(

#line 441 "lexer.cog"
                                  lexer, 

#line 441 "lexer.cog"
                                         16);
}
case 

#line 443 "lexer.cog"
                  'b':
case 

#line 443 "lexer.cog"
                            'B':
{


#line 444 "lexer.cog"
                            

#line 444 "lexer.cog"
                            

#line 444 "lexer.cog"
                 advanceByte(

#line 444 "lexer.cog"
                             lexer);
}
{


#line 445 "lexer.cog"
                 return 

#line 445 "lexer.cog"
                                 

#line 445 "lexer.cog"
                        lexNumber(

#line 445 "lexer.cog"
                                  lexer, 

#line 445 "lexer.cog"
                                         2);
}
default:
{


#line 448 "lexer.cog"
                 return 

#line 448 "lexer.cog"
                                 

#line 448 "lexer.cog"
                        lexNumber(

#line 448 "lexer.cog"
                                  lexer, 

#line 448 "lexer.cog"
                                         10);
}
}
}
}
case 

#line 452 "lexer.cog"
                    '1':
case 

#line 452 "lexer.cog"
                              '2':
case 

#line 452 "lexer.cog"
                                        '3':
case 

#line 452 "lexer.cog"
                                                  '4':
case 

#line 453 "lexer.cog"
          '5':
case 

#line 453 "lexer.cog"
                    '6':
case 

#line 453 "lexer.cog"
                              '7':
case 

#line 453 "lexer.cog"
                                        '8':
case 

#line 453 "lexer.cog"
                                                  '9':
{


#line 454 "lexer.cog"
         return 

#line 454 "lexer.cog"
                         

#line 454 "lexer.cog"
                lexNumber(

#line 454 "lexer.cog"
                          lexer, 

#line 454 "lexer.cog"
                                 10);
}
case 

#line 456 "lexer.cog"
          '@':
{


#line 457 "lexer.cog"
                    

#line 457 "lexer.cog"
                    

#line 457 "lexer.cog"
         advanceByte(

#line 457 "lexer.cog"
                     lexer);
}
{


#line 458 "lexer.cog"
         return 

#line 458 "lexer.cog"
                             

#line 458 "lexer.cog"
                lexIdentifier(

#line 458 "lexer.cog"
                              lexer);
}
case 

#line 476 "lexer.cog"
       '{':
{


#line 476 "lexer.cog"
                       

#line 476 "lexer.cog"
                       

#line 476 "lexer.cog"
            advanceByte(

#line 476 "lexer.cog"
                        lexer);
}
{


#line 476 "lexer.cog"
                                return 

#line 476 "lexer.cog"
                                       kTokenCode_LCurly;
}
case 

#line 477 "lexer.cog"
       '}':
{


#line 477 "lexer.cog"
                       

#line 477 "lexer.cog"
                       

#line 477 "lexer.cog"
            advanceByte(

#line 477 "lexer.cog"
                        lexer);
}
{


#line 477 "lexer.cog"
                                return 

#line 477 "lexer.cog"
                                       kTokenCode_RCurly;
}
case 

#line 478 "lexer.cog"
       '[':
{


#line 478 "lexer.cog"
                       

#line 478 "lexer.cog"
                       

#line 478 "lexer.cog"
            advanceByte(

#line 478 "lexer.cog"
                        lexer);
}
{


#line 478 "lexer.cog"
                                return 

#line 478 "lexer.cog"
                                       kTokenCode_LSquare;
}
case 

#line 479 "lexer.cog"
       ']':
{


#line 479 "lexer.cog"
                       

#line 479 "lexer.cog"
                       

#line 479 "lexer.cog"
            advanceByte(

#line 479 "lexer.cog"
                        lexer);
}
{


#line 479 "lexer.cog"
                                return 

#line 479 "lexer.cog"
                                       kTokenCode_RSquare;
}
case 

#line 480 "lexer.cog"
       '(':
{


#line 480 "lexer.cog"
                       

#line 480 "lexer.cog"
                       

#line 480 "lexer.cog"
            advanceByte(

#line 480 "lexer.cog"
                        lexer);
}
{


#line 480 "lexer.cog"
                                return 

#line 480 "lexer.cog"
                                       kTokenCode_LParen;
}
case 

#line 481 "lexer.cog"
       ')':
{


#line 481 "lexer.cog"
                       

#line 481 "lexer.cog"
                       

#line 481 "lexer.cog"
            advanceByte(

#line 481 "lexer.cog"
                        lexer);
}
{


#line 481 "lexer.cog"
                                return 

#line 481 "lexer.cog"
                                       kTokenCode_RParen;
}
case 

#line 482 "lexer.cog"
       ';':
{


#line 482 "lexer.cog"
                       

#line 482 "lexer.cog"
                       

#line 482 "lexer.cog"
            advanceByte(

#line 482 "lexer.cog"
                        lexer);
}
{


#line 482 "lexer.cog"
                                return 

#line 482 "lexer.cog"
                                       kTokenCode_Semi;
}
case 

#line 483 "lexer.cog"
       ':':
{


#line 483 "lexer.cog"
                       

#line 483 "lexer.cog"
                       

#line 483 "lexer.cog"
            advanceByte(

#line 483 "lexer.cog"
                        lexer);
}
{


#line 483 "lexer.cog"
                                return 

#line 483 "lexer.cog"
                                       kTokenCode_Colon;
}
case 

#line 484 "lexer.cog"
       ',':
{


#line 484 "lexer.cog"
                       

#line 484 "lexer.cog"
                       

#line 484 "lexer.cog"
            advanceByte(

#line 484 "lexer.cog"
                        lexer);
}
{


#line 484 "lexer.cog"
                                return 

#line 484 "lexer.cog"
                                       kTokenCode_Comma;
}
default:
{


#line 487 "lexer.cog"
   break;
}
}


#line 489 "lexer.cog"
  if(

#line 489 "lexer.cog"
            

#line 489 "lexer.cog"
     isAlpha(

#line 489 "lexer.cog"
             c))
{


#line 491 "lexer.cog"
   return 

#line 491 "lexer.cog"
                       

#line 491 "lexer.cog"
          lexIdentifier(

#line 491 "lexer.cog"
                        lexer);
}
else
{


#line 493 "lexer.cog"
       if(

#line 493 "lexer.cog"
                        

#line 493 "lexer.cog"
          isOperatorChar(

#line 493 "lexer.cog"
                         c))
{


#line 495 "lexer.cog"
   return 

#line 495 "lexer.cog"
                     

#line 495 "lexer.cog"
          lexOperator(

#line 495 "lexer.cog"
                      lexer);
}
else
{


#line 499 "lexer.cog"
           

#line 499 "lexer.cog"
           

#line 499 "lexer.cog"
   diagnose(

#line 499 "lexer.cog"
                   

#line 499 "lexer.cog"
            getSink(

#line 499 "lexer.cog"
                    lexer), 

#line 500 "lexer.cog"
           

#line 500 "lexer.cog"
    peekLoc(

#line 500 "lexer.cog"
            lexer), 

#line 501 "lexer.cog"
    kDiagnostic_unexpectedCharacter, 

#line 502 "lexer.cog"
                 

#line 502 "lexer.cog"
    peekCodePoint(

#line 502 "lexer.cog"
                  lexer));


#line 503 "lexer.cog"
              

#line 503 "lexer.cog"
              

#line 503 "lexer.cog"
   advanceByte(

#line 503 "lexer.cog"
               lexer);


#line 504 "lexer.cog"
   return 

#line 504 "lexer.cog"
          kTokenCode_Invalid;
}
}
}


#line 57 "token.cog"
 

#line 66 "token.cog"
  

#line 66 "token.cog"
                   SourceLoc Token::getLoc()
{


#line 68 "token.cog"
   return 

#line 68 "token.cog"
                   

#line 68 "token.cog"
          SourceLoc(

#line 68 "token.cog"
                    rawLoc);
}


#line 508 "lexer.cog"
 

#line 510 "lexer.cog"
     Token lexToken(

#line 509 "lexer.cog"
              

#line 509 "lexer.cog"
         Lexer

#line 509 "lexer.cog"
              * lexer)
{


#line 512 "lexer.cog"
  {
for(;;)
{
{


#line 515 "lexer.cog"
   

#line 515 "lexer.cog"
   auto begin = 

#line 515 "lexer.cog"
                    DEREF(

#line 515 "lexer.cog"
               lexer).cursor;


#line 516 "lexer.cog"
   

#line 516 "lexer.cog"
   auto flags = 

#line 516 "lexer.cog"
                    DEREF(

#line 516 "lexer.cog"
               lexer).tokenFlags;


#line 517 "lexer.cog"
   

#line 517 "lexer.cog"
   auto code = 

#line 517 "lexer.cog"
                          

#line 517 "lexer.cog"
              lexTokenImpl(

#line 517 "lexer.cog"
                           lexer);


#line 518 "lexer.cog"
   

#line 518 "lexer.cog"
   auto end = 

#line 518 "lexer.cog"
                  DEREF(

#line 518 "lexer.cog"
             lexer).cursor;


#line 519 "lexer.cog"
   

#line 519 "lexer.cog"
   auto rawData = 

#line 519 "lexer.cog"
                 cast<

#line 519 "lexer.cog"
                         

#line 519 "lexer.cog"
                      Ptr<

#line 519 "lexer.cog"
                          Void> >(

#line 519 "lexer.cog"
                                  begin);


#line 521 "lexer.cog"
   switch(

#line 521 "lexer.cog"
          code)
{
case 

#line 523 "lexer.cog"
        kTokenCode_Identifier:
case 

#line 524 "lexer.cog"
        kTokenCode_InfixOperator:
case 

#line 525 "lexer.cog"
        kTokenCode_PrefixOperator:
case 

#line 526 "lexer.cog"
        kTokenCode_PostfixOperator:
{


#line 527 "lexer.cog"
    rawData = 

#line 527 "lexer.cog"
                     

#line 527 "lexer.cog"
              getName(

#line 527 "lexer.cog"
                           DEREF(

#line 527 "lexer.cog"
                      lexer).session, 

#line 527 "lexer.cog"
                                               

#line 527 "lexer.cog"
                                     StringSpan(

#line 527 "lexer.cog"
                                                begin, 

#line 527 "lexer.cog"
                                                       end));
}
default:
{


#line 530 "lexer.cog"
         DEREF(

#line 530 "lexer.cog"
    lexer).tokenFlags = 

#line 530 "lexer.cog"
                       0;
}
{


#line 531 "lexer.cog"
    break;
}
case 

#line 533 "lexer.cog"
        kTokenCode_LineComment:
{


#line 534 "lexer.cog"
    continue;
}
case 

#line 536 "lexer.cog"
        kTokenCode_EndOfLine:
{


#line 537 "lexer.cog"
                     

#line 537 "lexer.cog"
                     

#line 537 "lexer.cog"
         DEREF(

#line 537 "lexer.cog"
    lexer).tokenFlags 

#line 537 "lexer.cog"
                     |= 

#line 537 "lexer.cog"
                        kTokenFlag_AtStartOfLine;
}
case 

#line 538 "lexer.cog"
        kTokenCode_WhiteSpace:
case 

#line 539 "lexer.cog"
        kTokenCode_BlockComment:
{


#line 540 "lexer.cog"
                     

#line 540 "lexer.cog"
                     

#line 540 "lexer.cog"
         DEREF(

#line 540 "lexer.cog"
    lexer).tokenFlags 

#line 540 "lexer.cog"
                     |= 

#line 540 "lexer.cog"
                        kTokenFlag_AfterSpace;
}
{


#line 541 "lexer.cog"
    continue;
}
}


#line 544 "lexer.cog"
   

#line 544 "lexer.cog"
   

#line 544 "lexer.cog"
               Token token;


#line 545 "lexer.cog"
        DEREF(

#line 545 "lexer.cog"
   token).code = 

#line 545 "lexer.cog"
                code;


#line 546 "lexer.cog"
        DEREF(

#line 546 "lexer.cog"
   token).flags = 

#line 546 "lexer.cog"
                 flags;


#line 547 "lexer.cog"
        DEREF(

#line 547 "lexer.cog"
   token).rawData = 

#line 547 "lexer.cog"
                   rawData;


#line 548 "lexer.cog"
        DEREF(

#line 548 "lexer.cog"
   token).rawSize = 

#line 548 "lexer.cog"
                       

#line 548 "lexer.cog"
                   end 

#line 548 "lexer.cog"
                       - 

#line 548 "lexer.cog"
                         begin;


#line 549 "lexer.cog"
        DEREF(

#line 549 "lexer.cog"
   token).rawLoc = 

#line 549 "lexer.cog"
                                       

#line 549 "lexer.cog"
                  cast<

#line 549 "lexer.cog"
                       UIntPtr>(

#line 549 "lexer.cog"
                                begin) 

#line 549 "lexer.cog"
                                       - 

#line 549 "lexer.cog"
                                              DEREF(

#line 549 "lexer.cog"
                                         lexer).rawStartPtr;


#line 550 "lexer.cog"
        DEREF(

#line 550 "lexer.cog"
   token).advance = 

#line 550 "lexer.cog"
                   0;


#line 551 "lexer.cog"
   return 

#line 551 "lexer.cog"
          token;
}
}}
}


#line 555 "lexer.cog"
 

#line 561 "lexer.cog"
          

#line 561 "lexer.cog"
     Token

#line 561 "lexer.cog"
          * matchDelimeter(

#line 556 "lexer.cog"
              

#line 556 "lexer.cog"
         Lexer

#line 556 "lexer.cog"
              * lexer, 

#line 557 "lexer.cog"
             

#line 557 "lexer.cog"
        Token

#line 557 "lexer.cog"
             * open, 

#line 558 "lexer.cog"
              

#line 558 "lexer.cog"
         Token

#line 558 "lexer.cog"
              * begin, 

#line 559 "lexer.cog"
               

#line 559 "lexer.cog"
       ConstPtr<

#line 559 "lexer.cog"
                Token>  end, 

#line 560 "lexer.cog"
                    TokenCode closingTokenCode)
{


#line 563 "lexer.cog"
  

#line 563 "lexer.cog"
  auto cursor = 

#line 563 "lexer.cog"
               begin;


#line 564 "lexer.cog"
  while(

#line 564 "lexer.cog"
               

#line 564 "lexer.cog"
        cursor 

#line 564 "lexer.cog"
               != 

#line 564 "lexer.cog"
                  end)
{
{


#line 566 "lexer.cog"
   

#line 566 "lexer.cog"
   auto code = 

#line 566 "lexer.cog"
                    DEREF(

#line 566 "lexer.cog"
              cursor).code;


#line 567 "lexer.cog"
   if(

#line 567 "lexer.cog"
           

#line 567 "lexer.cog"
      code 

#line 567 "lexer.cog"
           == 

#line 567 "lexer.cog"
              closingTokenCode)
{


#line 572 "lexer.cog"
        DEREF(

#line 572 "lexer.cog"
    open).advance = 

#line 572 "lexer.cog"
                           

#line 572 "lexer.cog"
                   uint32_t(

#line 572 "lexer.cog"
                                             

#line 572 "lexer.cog"
                             (

#line 572 "lexer.cog"
                                     

#line 572 "lexer.cog"
                              cursor 

#line 572 "lexer.cog"
                                     - 

#line 572 "lexer.cog"
                                       open) 

#line 572 "lexer.cog"
                                             - 

#line 572 "lexer.cog"
                                               1);


#line 574 "lexer.cog"
    return 

#line 574 "lexer.cog"
           cursor;
}


#line 577 "lexer.cog"
   switch(

#line 577 "lexer.cog"
                DEREF(

#line 577 "lexer.cog"
          cursor).code)
{
default:
{


#line 580 "lexer.cog"
    cursor = 

#line 580 "lexer.cog"
                    

#line 580 "lexer.cog"
             cursor 

#line 580 "lexer.cog"
                    + 

#line 580 "lexer.cog"
                      1;
}
{


#line 581 "lexer.cog"
    break;
}
case 

#line 586 "lexer.cog"
        kTokenCode_LParen:
{


#line 587 "lexer.cog"
    cursor = 

#line 587 "lexer.cog"
                           

#line 587 "lexer.cog"
             matchDelimeter(

#line 587 "lexer.cog"
                            lexer, 

#line 587 "lexer.cog"
                                   cursor, 

#line 587 "lexer.cog"
                                                 

#line 587 "lexer.cog"
                                           cursor 

#line 587 "lexer.cog"
                                                 + 

#line 587 "lexer.cog"
                                                  1, 

#line 587 "lexer.cog"
                                                     end, 

#line 587 "lexer.cog"
                                                          kTokenCode_RParen);
}
{


#line 588 "lexer.cog"
    break;
}
case 

#line 590 "lexer.cog"
        kTokenCode_LCurly:
{


#line 591 "lexer.cog"
    cursor = 

#line 591 "lexer.cog"
                           

#line 591 "lexer.cog"
             matchDelimeter(

#line 591 "lexer.cog"
                            lexer, 

#line 591 "lexer.cog"
                                   cursor, 

#line 591 "lexer.cog"
                                                 

#line 591 "lexer.cog"
                                           cursor 

#line 591 "lexer.cog"
                                                 + 

#line 591 "lexer.cog"
                                                  1, 

#line 591 "lexer.cog"
                                                     end, 

#line 591 "lexer.cog"
                                                          kTokenCode_RCurly);
}
{


#line 592 "lexer.cog"
    break;
}
case 

#line 594 "lexer.cog"
        kTokenCode_LSquare:
{


#line 595 "lexer.cog"
    cursor = 

#line 595 "lexer.cog"
                           

#line 595 "lexer.cog"
             matchDelimeter(

#line 595 "lexer.cog"
                            lexer, 

#line 595 "lexer.cog"
                                   cursor, 

#line 595 "lexer.cog"
                                                 

#line 595 "lexer.cog"
                                           cursor 

#line 595 "lexer.cog"
                                                 + 

#line 595 "lexer.cog"
                                                  1, 

#line 595 "lexer.cog"
                                                     end, 

#line 595 "lexer.cog"
                                                          kTokenCode_RSquare);
}
{


#line 596 "lexer.cog"
    break;
}
}
}
}


#line 602 "lexer.cog"
  return 

#line 602 "lexer.cog"
         cursor;
}


#line 605 "lexer.cog"
 void matchDelimeters(

#line 606 "lexer.cog"
              

#line 606 "lexer.cog"
         Lexer

#line 606 "lexer.cog"
              * lexer, 

#line 607 "lexer.cog"
              

#line 607 "lexer.cog"
         Token

#line 607 "lexer.cog"
              * begin, 

#line 608 "lexer.cog"
               

#line 608 "lexer.cog"
       ConstPtr<

#line 608 "lexer.cog"
                Token>  end)
{


#line 610 "lexer.cog"
                

#line 610 "lexer.cog"
                

#line 610 "lexer.cog"
  matchDelimeter(

#line 610 "lexer.cog"
                 lexer, 

#line 610 "lexer.cog"
                        0, 

#line 610 "lexer.cog"
                           begin, 

#line 610 "lexer.cog"
                                  end, 

#line 610 "lexer.cog"
                                       kTokenCode_EndOfFile);
}


#line 613 "lexer.cog"
 void markUpOperators(

#line 614 "lexer.cog"
              

#line 614 "lexer.cog"
         Lexer

#line 614 "lexer.cog"
              * lexer, 

#line 615 "lexer.cog"
              

#line 615 "lexer.cog"
         Token

#line 615 "lexer.cog"
              * begin, 

#line 616 "lexer.cog"
               

#line 616 "lexer.cog"
       ConstPtr<

#line 616 "lexer.cog"
                Token>  end)
{


#line 618 "lexer.cog"
  

#line 618 "lexer.cog"
  auto afterSpace = 

#line 618 "lexer.cog"
                   true;


#line 620 "lexer.cog"
  

#line 620 "lexer.cog"
  auto cursor = 

#line 620 "lexer.cog"
               begin;


#line 621 "lexer.cog"
  while(

#line 621 "lexer.cog"
               

#line 621 "lexer.cog"
        cursor 

#line 621 "lexer.cog"
               != 

#line 621 "lexer.cog"
                  end)
{
{


#line 623 "lexer.cog"
   

#line 623 "lexer.cog"
   auto code = 

#line 623 "lexer.cog"
                    DEREF(

#line 623 "lexer.cog"
              cursor).code;


#line 624 "lexer.cog"
   

#line 624 "lexer.cog"
   auto nextCode = 

#line 624 "lexer.cog"
                              DEREF(

#line 624 "lexer.cog"
                  (

#line 624 "lexer.cog"
                          

#line 624 "lexer.cog"
                   cursor 

#line 624 "lexer.cog"
                          + 

#line 624 "lexer.cog"
                            1)).code;


#line 626 "lexer.cog"
   if(

#line 626 "lexer.cog"
           

#line 626 "lexer.cog"
      code 

#line 626 "lexer.cog"
           == 

#line 626 "lexer.cog"
              kTokenCode_InfixOperator)
{


#line 628 "lexer.cog"
    if(

#line 628 "lexer.cog"
                    

#line 628 "lexer.cog"
             DEREF(

#line 628 "lexer.cog"
       cursor).flags 

#line 628 "lexer.cog"
                    & 

#line 628 "lexer.cog"
                      kTokenFlag_AfterSpace)
{


#line 630 "lexer.cog"
     afterSpace = 

#line 630 "lexer.cog"
                  true;
}


#line 633 "lexer.cog"
    

#line 633 "lexer.cog"
    auto beforeSpace = 

#line 633 "lexer.cog"
                                                                   

#line 633 "lexer.cog"
                      (

#line 633 "lexer.cog"
                                          

#line 633 "lexer.cog"
                                   DEREF(

#line 633 "lexer.cog"
                       (

#line 633 "lexer.cog"
                               

#line 633 "lexer.cog"
                        cursor 

#line 633 "lexer.cog"
                               + 

#line 633 "lexer.cog"
                                 1)).flags 

#line 633 "lexer.cog"
                                          & 

#line 633 "lexer.cog"
                                            kTokenFlag_AfterSpace) 

#line 633 "lexer.cog"
                                                                   != 

#line 633 "lexer.cog"
                                                                      0;


#line 634 "lexer.cog"
    switch(

#line 634 "lexer.cog"
           nextCode)
{
default:
{


#line 637 "lexer.cog"
     break;
}
case 

#line 639 "lexer.cog"
         kTokenCode_RParen:
case 

#line 640 "lexer.cog"
         kTokenCode_RSquare:
case 

#line 641 "lexer.cog"
         kTokenCode_RCurly:
case 

#line 642 "lexer.cog"
         kTokenCode_Semi:
case 

#line 643 "lexer.cog"
         kTokenCode_Colon:
case 

#line 644 "lexer.cog"
         kTokenCode_Comma:
{


#line 645 "lexer.cog"
     beforeSpace = 

#line 645 "lexer.cog"
                   true;
}
}


#line 648 "lexer.cog"
    if(

#line 648 "lexer.cog"
                   

#line 648 "lexer.cog"
       beforeSpace 

#line 648 "lexer.cog"
                   == 

#line 648 "lexer.cog"
                      afterSpace)
{
}
else
{


#line 652 "lexer.cog"
         if(

#line 652 "lexer.cog"
            beforeSpace)
{


#line 654 "lexer.cog"
           DEREF(

#line 654 "lexer.cog"
     cursor).code = 

#line 654 "lexer.cog"
                   kTokenCode_PostfixOperator;
}
else
{


#line 658 "lexer.cog"
           DEREF(

#line 658 "lexer.cog"
     cursor).code = 

#line 658 "lexer.cog"
                   kTokenCode_PrefixOperator;
}
}
}


#line 662 "lexer.cog"
   switch(

#line 662 "lexer.cog"
          code)
{
default:
{


#line 665 "lexer.cog"
    afterSpace = 

#line 665 "lexer.cog"
                 false;
}
{


#line 666 "lexer.cog"
    break;
}
case 

#line 668 "lexer.cog"
        kTokenCode_LParen:
case 

#line 669 "lexer.cog"
        kTokenCode_LSquare:
case 

#line 670 "lexer.cog"
        kTokenCode_LCurly:
case 

#line 671 "lexer.cog"
        kTokenCode_Semi:
case 

#line 672 "lexer.cog"
        kTokenCode_Colon:
case 

#line 673 "lexer.cog"
        kTokenCode_Comma:
{


#line 674 "lexer.cog"
    afterSpace = 

#line 674 "lexer.cog"
                 true;
}
{


#line 675 "lexer.cog"
    break;
}
}


#line 678 "lexer.cog"
         

#line 678 "lexer.cog"
         

#line 678 "lexer.cog"
   cursor

#line 678 "lexer.cog"
         ++;
}
}
}


#line 72 "token.cog"
 

#line 77 "token.cog"
  TokenSpan::TokenSpan()
{


#line 79 "token.cog"
       DEREF(

#line 79 "token.cog"
   this).begin_ = 

#line 79 "token.cog"
                 nullptr;


#line 80 "token.cog"
       DEREF(

#line 80 "token.cog"
   this).end_ = 

#line 80 "token.cog"
               nullptr;
}


#line 83 "token.cog"
  TokenSpan::TokenSpan(

#line 83 "token.cog"
                      

#line 83 "token.cog"
              ConstPtr<

#line 83 "token.cog"
                       Token>  begin, 

#line 83 "token.cog"
                                            

#line 83 "token.cog"
                                    ConstPtr<

#line 83 "token.cog"
                                             Token>  end)
{


#line 85 "token.cog"
       DEREF(

#line 85 "token.cog"
   this).begin_ = 

#line 85 "token.cog"
                 begin;


#line 86 "token.cog"
       DEREF(

#line 86 "token.cog"
   this).end_ = 

#line 86 "token.cog"
               end;
}


#line 682 "lexer.cog"
 

#line 685 "lexer.cog"
     TokenSpan lexTokens(

#line 683 "lexer.cog"
           Session session, 

#line 684 "lexer.cog"
                  

#line 684 "lexer.cog"
        SourceFile

#line 684 "lexer.cog"
                  * file)
{


#line 687 "lexer.cog"
  

#line 687 "lexer.cog"
  

#line 687 "lexer.cog"
              Lexer lexer;


#line 688 "lexer.cog"
                 

#line 688 "lexer.cog"
                 

#line 688 "lexer.cog"
  initializeLexer(

#line 688 "lexer.cog"
                  

#line 688 "lexer.cog"
                  &

#line 688 "lexer.cog"
                   lexer, 

#line 688 "lexer.cog"
                          session, 

#line 688 "lexer.cog"
                                   file);


#line 690 "lexer.cog"
  

#line 690 "lexer.cog"
  

#line 690 "lexer.cog"
                   SizeT tokenLimit = 

#line 690 "lexer.cog"
                           16;


#line 691 "lexer.cog"
  

#line 691 "lexer.cog"
  auto tokens = 

#line 691 "lexer.cog"
               cast<

#line 691 "lexer.cog"
                       

#line 691 "lexer.cog"
                    Ptr<

#line 691 "lexer.cog"
                        Token> >(

#line 691 "lexer.cog"
                                       

#line 691 "lexer.cog"
                                 malloc(

#line 691 "lexer.cog"
                                                   

#line 691 "lexer.cog"
                                        tokenLimit 

#line 691 "lexer.cog"
                                                   * 

#line 691 "lexer.cog"
                                                                  

#line 691 "lexer.cog"
                                                           

#line 691 "lexer.cog"
                                                     sizeOf<

#line 691 "lexer.cog"
                                                            Token> ()));


#line 692 "lexer.cog"
  

#line 692 "lexer.cog"
  

#line 692 "lexer.cog"
                   SizeT tokenCount = 

#line 692 "lexer.cog"
                           0;


#line 694 "lexer.cog"
  {
for(;;)
{
{


#line 696 "lexer.cog"
   

#line 696 "lexer.cog"
   auto token = 

#line 696 "lexer.cog"
                       

#line 696 "lexer.cog"
               lexToken(

#line 696 "lexer.cog"
                        

#line 696 "lexer.cog"
                        &

#line 696 "lexer.cog"
                         lexer);


#line 698 "lexer.cog"
   if(

#line 698 "lexer.cog"
                 

#line 698 "lexer.cog"
      tokenCount 

#line 698 "lexer.cog"
                 == 

#line 698 "lexer.cog"
                    tokenLimit)
{


#line 700 "lexer.cog"
               

#line 700 "lexer.cog"
               

#line 700 "lexer.cog"
    tokenLimit 

#line 700 "lexer.cog"
               *= 

#line 700 "lexer.cog"
                  2;


#line 701 "lexer.cog"
    tokens = 

#line 701 "lexer.cog"
             cast<

#line 701 "lexer.cog"
                     

#line 701 "lexer.cog"
                  Ptr<

#line 701 "lexer.cog"
                      Token> >(

#line 701 "lexer.cog"
                                      

#line 701 "lexer.cog"
                               realloc(

#line 701 "lexer.cog"
                                       tokens, 

#line 701 "lexer.cog"
                                                         

#line 701 "lexer.cog"
                                               tokenLimit 

#line 701 "lexer.cog"
                                                         * 

#line 701 "lexer.cog"
                                                                       

#line 701 "lexer.cog"
                                                                

#line 701 "lexer.cog"
                                                          sizeOf<

#line 701 "lexer.cog"
                                                                 Token> ()));
}


#line 703 "lexer.cog"
         

#line 703 "lexer.cog"
   tokens[

#line 703 "lexer.cog"
                    

#line 703 "lexer.cog"
          tokenCount

#line 703 "lexer.cog"
                    ++] = 

#line 703 "lexer.cog"
                          token;


#line 705 "lexer.cog"
   if(

#line 705 "lexer.cog"
                 

#line 705 "lexer.cog"
           DEREF(

#line 705 "lexer.cog"
      token).code 

#line 705 "lexer.cog"
                 == 

#line 705 "lexer.cog"
                    kTokenCode_EndOfFile)
{


#line 706 "lexer.cog"
    break;
}
}
}}


#line 710 "lexer.cog"
  tokens = 

#line 710 "lexer.cog"
           cast<

#line 710 "lexer.cog"
                   

#line 710 "lexer.cog"
                Ptr<

#line 710 "lexer.cog"
                    Token> >(

#line 710 "lexer.cog"
                                    

#line 710 "lexer.cog"
                             realloc(

#line 710 "lexer.cog"
                                     tokens, 

#line 710 "lexer.cog"
                                                       

#line 710 "lexer.cog"
                                             tokenLimit 

#line 710 "lexer.cog"
                                                       * 

#line 710 "lexer.cog"
                                                                     

#line 710 "lexer.cog"
                                                              

#line 710 "lexer.cog"
                                                        sizeOf<

#line 710 "lexer.cog"
                                                               Token> ()));


#line 713 "lexer.cog"
  

#line 713 "lexer.cog"
  auto endToken = 

#line 713 "lexer.cog"
                        

#line 713 "lexer.cog"
                 tokens 

#line 713 "lexer.cog"
                        + 

#line 713 "lexer.cog"
                                     

#line 713 "lexer.cog"
                          tokenCount 

#line 713 "lexer.cog"
                                     - 

#line 713 "lexer.cog"
                                       1;


#line 715 "lexer.cog"
  

#line 715 "lexer.cog"
  auto tokenSpan = 

#line 715 "lexer.cog"
                           

#line 715 "lexer.cog"
                  TokenSpan(

#line 715 "lexer.cog"
                            tokens, 

#line 715 "lexer.cog"
                                    endToken);


#line 717 "lexer.cog"
                 

#line 717 "lexer.cog"
                 

#line 717 "lexer.cog"
  matchDelimeters(

#line 717 "lexer.cog"
                  

#line 717 "lexer.cog"
                  &

#line 717 "lexer.cog"
                   lexer, 

#line 717 "lexer.cog"
                          tokens, 

#line 717 "lexer.cog"
                                  endToken);


#line 719 "lexer.cog"
                 

#line 719 "lexer.cog"
                 

#line 719 "lexer.cog"
  markUpOperators(

#line 719 "lexer.cog"
                  

#line 719 "lexer.cog"
                  &

#line 719 "lexer.cog"
                   lexer, 

#line 719 "lexer.cog"
                          tokens, 

#line 719 "lexer.cog"
                                  endToken);


#line 721 "lexer.cog"
               

#line 721 "lexer.cog"
               

#line 721 "lexer.cog"
  finalizeLexer(

#line 721 "lexer.cog"
                

#line 721 "lexer.cog"
                &

#line 721 "lexer.cog"
                 lexer);


#line 723 "lexer.cog"
  return 

#line 723 "lexer.cog"
         tokenSpan;
}


#line 3 "main.cog"
 

#line 5 "main.cog"
 void parseCommandLine(

#line 6 "main.cog"
           Session session, 

#line 7 "main.cog"
             

#line 7 "main.cog"
          Ptr<

#line 7 "main.cog"
              Int>  ioArgc, 

#line 8 "main.cog"
           

#line 8 "main.cog"
        Ptr<

#line 8 "main.cog"
               

#line 8 "main.cog"
            Ptr<

#line 8 "main.cog"
                Char> >  argv)
{


#line 10 "main.cog"
  

#line 10 "main.cog"
  auto argCursor = 

#line 10 "main.cog"
                  argv;


#line 11 "main.cog"
     

#line 11 "main.cog"
     auto argEnd = 

#line 11 "main.cog"
                       

#line 11 "main.cog"
                  argv 

#line 11 "main.cog"
                       + 

#line 11 "main.cog"
                         

#line 11 "main.cog"
                         *

#line 11 "main.cog"
                          ioArgc;


#line 13 "main.cog"
  

#line 13 "main.cog"
  auto writeCursor = 

#line 13 "main.cog"
                    argv;


#line 15 "main.cog"
  if(

#line 15 "main.cog"
                

#line 15 "main.cog"
      argCursor 

#line 15 "main.cog"
                != 

#line 15 "main.cog"
                   argEnd)
{


#line 18 "main.cog"
            

#line 18 "main.cog"
            

#line 18 "main.cog"
   argCursor

#line 18 "main.cog"
            ++;
}


#line 21 "main.cog"
  while(

#line 21 "main.cog"
                  

#line 21 "main.cog"
        argCursor 

#line 21 "main.cog"
                  != 

#line 21 "main.cog"
                     argEnd)
{
{


#line 24 "main.cog"
         

#line 24 "main.cog"
         

#line 24 "main.cog"
                      

#line 24 "main.cog"
                   Ptr<

#line 24 "main.cog"
                       Char>  arg = 

#line 24 "main.cog"
                               

#line 24 "main.cog"
                               *

#line 24 "main.cog"
                                         

#line 24 "main.cog"
                                argCursor

#line 24 "main.cog"
                                         ++;


#line 27 "main.cog"
         if(

#line 27 "main.cog"
                             

#line 27 "main.cog"
             (

#line 27 "main.cog"
                     

#line 27 "main.cog"
                 

#line 27 "main.cog"
              arg[

#line 27 "main.cog"
                  0] 

#line 27 "main.cog"
                     == 

#line 27 "main.cog"
                        '-') 

#line 27 "main.cog"
                             && 

#line 27 "main.cog"
                                (

#line 27 "main.cog"
                                        

#line 27 "main.cog"
                                    

#line 27 "main.cog"
                                 arg[

#line 27 "main.cog"
                                     1] 

#line 27 "main.cog"
                                        != 

#line 27 "main.cog"
                                           0))
{


#line 29 "main.cog"
             if(

#line 29 "main.cog"
                                   

#line 29 "main.cog"
                       

#line 29 "main.cog"
                 strcmp(

#line 29 "main.cog"
                        arg, 

#line 29 "main.cog"
                             "--") 

#line 29 "main.cog"
                                   == 

#line 29 "main.cog"
                                      0)
{


#line 32 "main.cog"
     while(

#line 32 "main.cog"
                      

#line 32 "main.cog"
            argCursor 

#line 32 "main.cog"
                      != 

#line 32 "main.cog"
                         argEnd)
{
{


#line 34 "main.cog"
      

#line 34 "main.cog"
      *

#line 34 "main.cog"
                  

#line 34 "main.cog"
       writeCursor

#line 34 "main.cog"
                  ++ = 

#line 34 "main.cog"
                       

#line 34 "main.cog"
                       *

#line 34 "main.cog"
                                 

#line 34 "main.cog"
                        argCursor

#line 34 "main.cog"
                                 ++;
}
}


#line 36 "main.cog"
     break;
}
else
{


#line 38 "main.cog"
         if(

#line 38 "main.cog"
                               

#line 38 "main.cog"
                   

#line 38 "main.cog"
             strcmp(

#line 38 "main.cog"
                    arg, 

#line 38 "main.cog"
                         "-m") 

#line 38 "main.cog"
                               == 

#line 38 "main.cog"
                                  0)
{


#line 40 "main.cog"
     if(

#line 40 "main.cog"
                   

#line 40 "main.cog"
         argCursor 

#line 40 "main.cog"
                   == 

#line 40 "main.cog"
                      argEnd)
{


#line 42 "main.cog"
             

#line 42 "main.cog"
             

#line 42 "main.cog"
      fprintf(

#line 42 "main.cog"
              stderr, 

#line 42 "main.cog"
                      "command line: error: expected an argument after \'-m\' option\n");
}
else
{


#line 46 "main.cog"
      

#line 46 "main.cog"
      auto valArg = 

#line 46 "main.cog"
                   

#line 46 "main.cog"
                   *

#line 46 "main.cog"
                             

#line 46 "main.cog"
                    argCursor

#line 46 "main.cog"
                             ++;


#line 47 "main.cog"
                   

#line 47 "main.cog"
                   

#line 47 "main.cog"
      setModulePath(

#line 47 "main.cog"
                    session, 

#line 47 "main.cog"
                                                 

#line 47 "main.cog"
                             TerminatedStringSpan(

#line 47 "main.cog"
                                                  valArg));
}
}
else
{


#line 50 "main.cog"
         if(

#line 50 "main.cog"
                               

#line 50 "main.cog"
                   

#line 50 "main.cog"
             strcmp(

#line 50 "main.cog"
                    arg, 

#line 50 "main.cog"
                         "-o") 

#line 50 "main.cog"
                               == 

#line 50 "main.cog"
                                  0)
{


#line 52 "main.cog"
     if(

#line 52 "main.cog"
                   

#line 52 "main.cog"
         argCursor 

#line 52 "main.cog"
                   == 

#line 52 "main.cog"
                      argEnd)
{


#line 54 "main.cog"
             

#line 54 "main.cog"
             

#line 54 "main.cog"
      fprintf(

#line 54 "main.cog"
              stderr, 

#line 54 "main.cog"
                      "command line: error: expected an argument after \'-o\' option\n");
}
else
{


#line 58 "main.cog"
      

#line 58 "main.cog"
      auto valArg = 

#line 58 "main.cog"
                   

#line 58 "main.cog"
                   *

#line 58 "main.cog"
                             

#line 58 "main.cog"
                    argCursor

#line 58 "main.cog"
                             ++;
}
}
else
{


#line 62 "main.cog"
         if(

#line 62 "main.cog"
                                  

#line 62 "main.cog"
                   

#line 62 "main.cog"
             strcmp(

#line 62 "main.cog"
                    arg, 

#line 62 "main.cog"
                         "-eval") 

#line 62 "main.cog"
                                  == 

#line 62 "main.cog"
                                     0)
{


#line 65 "main.cog"
                

#line 65 "main.cog"
                

#line 65 "main.cog"
     setEvaluate(

#line 65 "main.cog"
                 session);
}
else
{


#line 69 "main.cog"
            

#line 69 "main.cog"
            

#line 69 "main.cog"
     fprintf(

#line 69 "main.cog"
             stderr, 

#line 69 "main.cog"
                     "command line: unknown option \'%s\'\n", 

#line 69 "main.cog"
                                                            arg);
}
}
}
}
}
else
{


#line 74 "main.cog"
    

#line 74 "main.cog"
    *

#line 74 "main.cog"
                

#line 74 "main.cog"
     writeCursor

#line 74 "main.cog"
                ++ = 

#line 74 "main.cog"
                     arg;
}
}
}


#line 78 "main.cog"
  

#line 78 "main.cog"
  *

#line 78 "main.cog"
   ioArgc = 

#line 78 "main.cog"
                        

#line 78 "main.cog"
            writeCursor 

#line 78 "main.cog"
                        - 

#line 78 "main.cog"
                          argv;


#line 82 "main.cog"
     if(

#line 82 "main.cog"
        

#line 82 "main.cog"
        !

#line 82 "main.cog"
                      

#line 82 "main.cog"
         getModuleName(

#line 82 "main.cog"
                       session))
{


#line 84 "main.cog"
         if(

#line 84 "main.cog"
                    

#line 84 "main.cog"
            

#line 84 "main.cog"
            *

#line 84 "main.cog"
             ioArgc 

#line 84 "main.cog"
                    == 

#line 84 "main.cog"
                       1)
{


#line 87 "main.cog"
             

#line 87 "main.cog"
             auto name = 

#line 87 "main.cog"
                                                                  

#line 87 "main.cog"
                                                     DEREF(

#line 87 "main.cog"
                                            

#line 87 "main.cog"
                        TerminatedStringSpan(

#line 87 "main.cog"
                                                 

#line 87 "main.cog"
                                             argv[

#line 87 "main.cog"
                                                  0])).asStringSpan();


#line 90 "main.cog"
                             

#line 90 "main.cog"
                             

#line 90 "main.cog"
                 DEREF(

#line 90 "main.cog"
             name).trimFromEnd(

#line 90 "main.cog"
                                                                       

#line 90 "main.cog"
                                                          DEREF(

#line 90 "main.cog"
                                                  

#line 90 "main.cog"
                              TerminatedStringSpan(

#line 90 "main.cog"
                                                   ".cog")).asStringSpan());


#line 92 "main.cog"
                          

#line 92 "main.cog"
                          

#line 92 "main.cog"
             setModulePath(

#line 92 "main.cog"
                           session, 

#line 92 "main.cog"
                                    name);
}
else
{


#line 97 "main.cog"
                    

#line 97 "main.cog"
                    

#line 97 "main.cog"
             fprintf(

#line 97 "main.cog"
                     stderr, 

#line 97 "main.cog"
                             "module name must be specified when using more than one input file");


#line 98 "main.cog"
                 

#line 98 "main.cog"
                 

#line 98 "main.cog"
             exit(

#line 98 "main.cog"
                  1);
}
}
}


#line 103 "main.cog"
 

#line 103 "main.cog"
                                                   Int main(

#line 103 "main.cog"
                   Int argc, 

#line 103 "main.cog"
                                  

#line 103 "main.cog"
                               Ptr<

#line 103 "main.cog"
                                      

#line 103 "main.cog"
                                   Ptr<

#line 103 "main.cog"
                                       Char> >  argv)
{


#line 105 "main.cog"
  

#line 105 "main.cog"
  auto session = 

#line 105 "main.cog"
                             

#line 105 "main.cog"
                createSession();


#line 107 "main.cog"
                  

#line 107 "main.cog"
                  

#line 107 "main.cog"
  parseCommandLine(

#line 107 "main.cog"
                   session, 

#line 107 "main.cog"
                            

#line 107 "main.cog"
                            &

#line 107 "main.cog"
                             argc, 

#line 107 "main.cog"
                                   argv);


#line 109 "main.cog"
  

#line 109 "main.cog"
  

#line 109 "main.cog"
           Int ii = 

#line 109 "main.cog"
                 0;


#line 110 "main.cog"
  while(

#line 110 "main.cog"
           

#line 110 "main.cog"
        ii 

#line 110 "main.cog"
           < 

#line 110 "main.cog"
             argc)
{
{


#line 112 "main.cog"
                       

#line 112 "main.cog"
                       

#line 112 "main.cog"
         loadSourceFile(

#line 112 "main.cog"
                        session, 

#line 112 "main.cog"
                                                     

#line 112 "main.cog"
                                 TerminatedStringSpan(

#line 112 "main.cog"
                                                          

#line 112 "main.cog"
                                                      argv[

#line 112 "main.cog"
                                                           ii]));


#line 113 "main.cog"
   ii = 

#line 113 "main.cog"
           

#line 113 "main.cog"
        ii 

#line 113 "main.cog"
           + 

#line 113 "main.cog"
             1;
}
}


#line 116 "main.cog"
     if(

#line 116 "main.cog"
                               

#line 116 "main.cog"
                     

#line 116 "main.cog"
        getErrorCount(

#line 116 "main.cog"
                      session) 

#line 116 "main.cog"
                               > 

#line 116 "main.cog"
                                 0)
{


#line 117 "main.cog"
         return 

#line 117 "main.cog"
                1;
}


#line 121 "main.cog"
     if(

#line 121 "main.cog"
                               

#line 121 "main.cog"
                     

#line 121 "main.cog"
        getErrorCount(

#line 121 "main.cog"
                      session) 

#line 121 "main.cog"
                               > 

#line 121 "main.cog"
                                 0)
{


#line 122 "main.cog"
         return 

#line 122 "main.cog"
                1;
}


#line 124 "main.cog"
  if(

#line 124 "main.cog"
            DEREF(

#line 124 "main.cog"
     session).eval)
{


#line 126 "main.cog"
             

#line 126 "main.cog"
             

#line 126 "main.cog"
   evalModule(

#line 126 "main.cog"
              session);
}
else
{


#line 130 "main.cog"
             

#line 130 "main.cog"
             

#line 130 "main.cog"
   emitModule(

#line 130 "main.cog"
              session);
}


#line 133 "main.cog"
  return 

#line 133 "main.cog"
         0;
}


#line 3 "name.cog"
 

#line 11 "name.cog"
 

#line 14 "name.cog"
        

#line 14 "name.cog"
     Ptr<

#line 14 "name.cog"
         Name>  getName(

#line 12 "name.cog"
           Session session, 

#line 13 "name.cog"
        StringSpan text)
{


#line 16 "name.cog"
  {


#line 16 "name.cog"
      

#line 16 "name.cog"
      auto nn = 

#line 16 "name.cog"
                      DEREF(

#line 16 "name.cog"
               session).names;
for(;

#line 16 "name.cog"
                              nn;

#line 16 "name.cog"
                                  nn = 

#line 16 "name.cog"
                                         DEREF(

#line 16 "name.cog"
                                       nn).next)
{
{


#line 18 "name.cog"
   if(

#line 18 "name.cog"
              

#line 18 "name.cog"
        DEREF(

#line 18 "name.cog"
      nn).text 

#line 18 "name.cog"
              == 

#line 18 "name.cog"
                 text)
{


#line 19 "name.cog"
    return 

#line 19 "name.cog"
           nn;
}
}
}}


#line 23 "name.cog"
  

#line 23 "name.cog"
  auto textSize = 

#line 23 "name.cog"
                          

#line 23 "name.cog"
                     DEREF(

#line 23 "name.cog"
                 text).end 

#line 23 "name.cog"
                          - 

#line 23 "name.cog"
                                DEREF(

#line 23 "name.cog"
                            text).begin;


#line 24 "name.cog"
  

#line 24 "name.cog"
  auto name = 

#line 24 "name.cog"
             cast<

#line 24 "name.cog"
                     

#line 24 "name.cog"
                  Ptr<

#line 24 "name.cog"
                      Name> >(

#line 24 "name.cog"
                                      

#line 24 "name.cog"
                                malloc(

#line 24 "name.cog"
                                                    

#line 24 "name.cog"
                                             

#line 24 "name.cog"
                                       sizeof(

#line 24 "name.cog"
                                              Name) 

#line 24 "name.cog"
                                                    + 

#line 24 "name.cog"
                                                               

#line 24 "name.cog"
                                                      textSize 

#line 24 "name.cog"
                                                               + 

#line 24 "name.cog"
                                                                 1));


#line 26 "name.cog"
  

#line 26 "name.cog"
  auto textBegin = 

#line 26 "name.cog"
                  cast<

#line 26 "name.cog"
                          

#line 26 "name.cog"
                       Ptr<

#line 26 "name.cog"
                           Char> >(

#line 26 "name.cog"
                                        

#line 26 "name.cog"
                                   name 

#line 26 "name.cog"
                                        + 

#line 26 "name.cog"
                                          1);


#line 27 "name.cog"
  

#line 27 "name.cog"
  auto textEnd = 

#line 27 "name.cog"
                          

#line 27 "name.cog"
                textBegin 

#line 27 "name.cog"
                          + 

#line 27 "name.cog"
                            textSize;


#line 29 "name.cog"
        

#line 29 "name.cog"
        

#line 29 "name.cog"
  memcpy(

#line 29 "name.cog"
         textBegin, 

#line 29 "name.cog"
                        DEREF(

#line 29 "name.cog"
                    text).begin, 

#line 29 "name.cog"
                                textSize);


#line 30 "name.cog"
  

#line 30 "name.cog"
  *

#line 30 "name.cog"
   textEnd = 

#line 30 "name.cog"
             0;


#line 32 "name.cog"
      DEREF(

#line 32 "name.cog"
  name).text = 

#line 32 "name.cog"
                                  

#line 32 "name.cog"
              TerminatedStringSpan(

#line 32 "name.cog"
                                   textBegin, 

#line 32 "name.cog"
                                              textEnd);


#line 33 "name.cog"
      DEREF(

#line 33 "name.cog"
  name).next = 

#line 33 "name.cog"
                     DEREF(

#line 33 "name.cog"
              session).names;


#line 34 "name.cog"
         DEREF(

#line 34 "name.cog"
  session).names = 

#line 34 "name.cog"
                  name;


#line 35 "name.cog"
  return 

#line 35 "name.cog"
         name;
}


#line 38 "name.cog"
 

#line 40 "name.cog"
     TerminatedStringSpan getText(

#line 39 "name.cog"
           

#line 39 "name.cog"
        Ptr<

#line 39 "name.cog"
            Name>  name)
{


#line 42 "name.cog"
  if(

#line 42 "name.cog"
     

#line 42 "name.cog"
     !

#line 42 "name.cog"
      name)
{


#line 43 "name.cog"
   return 

#line 43 "name.cog"
          "";
}


#line 44 "name.cog"
  return 

#line 44 "name.cog"
             DEREF(

#line 44 "name.cog"
         name).text;
}


#line 47 "name.cog"
 

#line 50 "name.cog"
        

#line 50 "name.cog"
     Ptr<

#line 50 "name.cog"
         Name>  getName(

#line 48 "name.cog"
           Session session, 

#line 49 "name.cog"
           

#line 49 "name.cog"
        Ptr<

#line 49 "name.cog"
            Char>  text)
{


#line 52 "name.cog"
  return 

#line 52 "name.cog"
                

#line 52 "name.cog"
         getName(

#line 52 "name.cog"
                 session, 

#line 52 "name.cog"
                                              

#line 52 "name.cog"
                          TerminatedStringSpan(

#line 52 "name.cog"
                                               text));
}


#line 3 "parser.cog"
 

#line 5 "parser.cog"
 typedef 

#line 5 "parser.cog"
                         UInt32 ParserFlags;


#line 7 "parser.cog"
 

#line 13 "parser.cog"
 

#line 29 "parser.cog"
 void debugState(

#line 29 "parser.cog"
                               

#line 29 "parser.cog"
                         Parser

#line 29 "parser.cog"
                               * parser)
{
}


#line 43 "parser.cog"
 

#line 45 "parser.cog"
                

#line 45 "parser.cog"
        ConstPtr<

#line 45 "parser.cog"
                 Token>  advanceToken(

#line 44 "parser.cog"
                   

#line 44 "parser.cog"
             Parser

#line 44 "parser.cog"
                   * parser)
{


#line 47 "parser.cog"
     

#line 47 "parser.cog"
     auto result = 

#line 47 "parser.cog"
                        DEREF(

#line 47 "parser.cog"
                  parser).token;


#line 48 "parser.cog"
           DEREF(

#line 48 "parser.cog"
     parser).token = 

#line 48 "parser.cog"
                          DEREF(

#line 48 "parser.cog"
                    parser).cursor;


#line 49 "parser.cog"
     if(

#line 49 "parser.cog"
                      

#line 49 "parser.cog"
              DEREF(

#line 49 "parser.cog"
        parser).cursor 

#line 49 "parser.cog"
                      != 

#line 49 "parser.cog"
                               DEREF(

#line 49 "parser.cog"
                         parser).end)
{


#line 51 "parser.cog"
                      

#line 51 "parser.cog"
                      

#line 51 "parser.cog"
               DEREF(

#line 51 "parser.cog"
         parser).cursor

#line 51 "parser.cog"
                      ++;
}


#line 53 "parser.cog"
               

#line 53 "parser.cog"
               

#line 53 "parser.cog"
     debugState(

#line 53 "parser.cog"
                parser);


#line 54 "parser.cog"
     return 

#line 54 "parser.cog"
            result;
}


#line 57 "parser.cog"
 

#line 59 "parser.cog"
                

#line 59 "parser.cog"
        ConstPtr<

#line 59 "parser.cog"
                 Token>  advanceFragment(

#line 58 "parser.cog"
                   

#line 58 "parser.cog"
             Parser

#line 58 "parser.cog"
                   * parser)
{


#line 61 "parser.cog"
     

#line 61 "parser.cog"
     auto result = 

#line 61 "parser.cog"
                        DEREF(

#line 61 "parser.cog"
                  parser).token;


#line 62 "parser.cog"
           DEREF(

#line 62 "parser.cog"
     parser).token = 

#line 62 "parser.cog"
                          DEREF(

#line 62 "parser.cog"
                    parser).cursor;


#line 63 "parser.cog"
           DEREF(

#line 63 "parser.cog"
     parser).cursor = 

#line 63 "parser.cog"
                                   

#line 63 "parser.cog"
                           DEREF(

#line 63 "parser.cog"
                     parser).cursor 

#line 63 "parser.cog"
                                   + 

#line 63 "parser.cog"
                                                           

#line 63 "parser.cog"
                                                  DEREF(

#line 63 "parser.cog"
                                           DEREF(

#line 63 "parser.cog"
                                     parser).cursor).advance 

#line 63 "parser.cog"
                                                           + 

#line 63 "parser.cog"
                                                             1;


#line 64 "parser.cog"
     if(

#line 64 "parser.cog"
                      

#line 64 "parser.cog"
              DEREF(

#line 64 "parser.cog"
        parser).cursor 

#line 64 "parser.cog"
                      != 

#line 64 "parser.cog"
                               DEREF(

#line 64 "parser.cog"
                         parser).end)
{


#line 66 "parser.cog"
                      

#line 66 "parser.cog"
                      

#line 66 "parser.cog"
               DEREF(

#line 66 "parser.cog"
         parser).cursor

#line 66 "parser.cog"
                      ++;
}


#line 68 "parser.cog"
               

#line 68 "parser.cog"
               

#line 68 "parser.cog"
     debugState(

#line 68 "parser.cog"
                parser);


#line 69 "parser.cog"
     return 

#line 69 "parser.cog"
            result;
}


#line 72 "parser.cog"
 void initializeParser(

#line 73 "parser.cog"
                   

#line 73 "parser.cog"
             Parser

#line 73 "parser.cog"
                   * parser, 

#line 74 "parser.cog"
              Session session, 

#line 75 "parser.cog"
                     

#line 75 "parser.cog"
           SourceFile

#line 75 "parser.cog"
                     * file)
{


#line 77 "parser.cog"
     

#line 77 "parser.cog"
     auto tokens = 

#line 77 "parser.cog"
                           

#line 77 "parser.cog"
                  lexTokens(

#line 77 "parser.cog"
                            session, 

#line 77 "parser.cog"
                                     file);


#line 79 "parser.cog"
           DEREF(

#line 79 "parser.cog"
     parser).session = 

#line 79 "parser.cog"
                      session;


#line 80 "parser.cog"
           DEREF(

#line 80 "parser.cog"
     parser).scope = 

#line 80 "parser.cog"
                    0;


#line 81 "parser.cog"
           DEREF(

#line 81 "parser.cog"
     parser).begin = 

#line 81 "parser.cog"
                          DEREF(

#line 81 "parser.cog"
                    tokens).begin_;


#line 82 "parser.cog"
           DEREF(

#line 82 "parser.cog"
     parser).cursor = 

#line 82 "parser.cog"
                           DEREF(

#line 82 "parser.cog"
                     tokens).begin_;


#line 83 "parser.cog"
           DEREF(

#line 83 "parser.cog"
     parser).end = 

#line 83 "parser.cog"
                        DEREF(

#line 83 "parser.cog"
                  tokens).end_;


#line 84 "parser.cog"
           DEREF(

#line 84 "parser.cog"
     parser).flags = 

#line 84 "parser.cog"
                    0;


#line 85 "parser.cog"
        DEREF(

#line 85 "parser.cog"
  parser).genericDepth = 

#line 85 "parser.cog"
                        0;


#line 87 "parser.cog"
                 

#line 87 "parser.cog"
                 

#line 87 "parser.cog"
     advanceToken(

#line 87 "parser.cog"
                  parser);
}


#line 90 "parser.cog"
 void finalizeParser(

#line 91 "parser.cog"
                   

#line 91 "parser.cog"
             Parser

#line 91 "parser.cog"
                   * parser)
{
}


#line 94 "parser.cog"
 void pushScope(

#line 95 "parser.cog"
                   

#line 95 "parser.cog"
             Parser

#line 95 "parser.cog"
                   * parser, 

#line 96 "parser.cog"
                ContainerDecl container)
{


#line 98 "parser.cog"
     

#line 98 "parser.cog"
     auto scope = 

#line 98 "parser.cog"
                             

#line 98 "parser.cog"
                      

#line 98 "parser.cog"
                 alloc<

#line 98 "parser.cog"
                       Scope> ();


#line 99 "parser.cog"
          DEREF(

#line 99 "parser.cog"
     scope).parent = 

#line 99 "parser.cog"
                          DEREF(

#line 99 "parser.cog"
                    parser).scope;


#line 102 "parser.cog"
                     DEREF(

#line 102 "parser.cog"
          DEREF(

#line 102 "parser.cog"
     scope).directLink).container = 

#line 102 "parser.cog"
                                  container;


#line 104 "parser.cog"
           DEREF(

#line 104 "parser.cog"
     parser).scope = 

#line 104 "parser.cog"
                    scope;
}


#line 107 "parser.cog"
 void restoreScope(

#line 108 "parser.cog"
                   

#line 108 "parser.cog"
             Parser

#line 108 "parser.cog"
                   * parser, 

#line 109 "parser.cog"
                 

#line 109 "parser.cog"
            Scope

#line 109 "parser.cog"
                 * scope)
{


#line 112 "parser.cog"
           DEREF(

#line 112 "parser.cog"
     parser).scope = 

#line 112 "parser.cog"
                    scope;
}


#line 115 "parser.cog"
 void popScope(

#line 116 "parser.cog"
                   

#line 116 "parser.cog"
             Parser

#line 116 "parser.cog"
                   * parser)
{


#line 118 "parser.cog"
              

#line 118 "parser.cog"
              

#line 118 "parser.cog"
     cogAssert(

#line 118 "parser.cog"
                     DEREF(

#line 118 "parser.cog"
               parser).scope);


#line 119 "parser.cog"
                 

#line 119 "parser.cog"
                 

#line 119 "parser.cog"
     restoreScope(

#line 119 "parser.cog"
                  parser, 

#line 119 "parser.cog"
                                      DEREF(

#line 119 "parser.cog"
                                DEREF(

#line 119 "parser.cog"
                          parser).scope).parent);
}


#line 123 "parser.cog"
 

#line 124 "parser.cog"
                      

#line 124 "parser.cog"
        DiagnosticSink

#line 124 "parser.cog"
                      * getSink(

#line 123 "parser.cog"
                            

#line 123 "parser.cog"
                      Parser

#line 123 "parser.cog"
                            * parser)
{


#line 126 "parser.cog"
     return 

#line 126 "parser.cog"
            

#line 126 "parser.cog"
            &

#line 126 "parser.cog"
                           DEREF(

#line 126 "parser.cog"
                   DEREF(

#line 126 "parser.cog"
             parser).session).sink;
}


#line 129 "parser.cog"
 

#line 130 "parser.cog"
        SourceLoc peekLoc(

#line 129 "parser.cog"
                            

#line 129 "parser.cog"
                      Parser

#line 129 "parser.cog"
                            * parser)
{


#line 132 "parser.cog"
     return 

#line 132 "parser.cog"
                     

#line 132 "parser.cog"
            SourceLoc(

#line 132 "parser.cog"
                                  DEREF(

#line 132 "parser.cog"
                            DEREF(

#line 132 "parser.cog"
                      parser).token).rawLoc);
}


#line 135 "parser.cog"
 

#line 136 "parser.cog"
        TokenCode peekTokenCode(

#line 135 "parser.cog"
                                  

#line 135 "parser.cog"
                            Parser

#line 135 "parser.cog"
                                  * parser)
{


#line 138 "parser.cog"
     return 

#line 138 "parser.cog"
                        DEREF(

#line 138 "parser.cog"
                  DEREF(

#line 138 "parser.cog"
            parser).token).code;
}


#line 141 "parser.cog"
 

#line 142 "parser.cog"
        Bool peekTokenCode(

#line 141 "parser.cog"
                                  

#line 141 "parser.cog"
                            Parser

#line 141 "parser.cog"
                                  * parser, 

#line 141 "parser.cog"
                                           TokenCode code)
{


#line 144 "parser.cog"
     return 

#line 144 "parser.cog"
                              

#line 144 "parser.cog"
                        DEREF(

#line 144 "parser.cog"
                  DEREF(

#line 144 "parser.cog"
            parser).token).code 

#line 144 "parser.cog"
                              == 

#line 144 "parser.cog"
                                 code;
}


#line 147 "parser.cog"
 

#line 148 "parser.cog"
        Bool isAtEnd(

#line 147 "parser.cog"
                            

#line 147 "parser.cog"
                      Parser

#line 147 "parser.cog"
                            * parser)
{


#line 150 "parser.cog"
     return 

#line 150 "parser.cog"
                          

#line 150 "parser.cog"
                  DEREF(

#line 150 "parser.cog"
            parser).cursor 

#line 150 "parser.cog"
                          == 

#line 150 "parser.cog"
                                   DEREF(

#line 150 "parser.cog"
                             parser).end;
}


#line 153 "parser.cog"
 

#line 154 "parser.cog"
        Bool isRecovering(

#line 153 "parser.cog"
                                 

#line 153 "parser.cog"
                           Parser

#line 153 "parser.cog"
                                 * parser)
{


#line 156 "parser.cog"
     return 

#line 156 "parser.cog"
                                                    

#line 156 "parser.cog"
            (

#line 156 "parser.cog"
                          

#line 156 "parser.cog"
                   DEREF(

#line 156 "parser.cog"
             parser).flags 

#line 156 "parser.cog"
                          & 

#line 156 "parser.cog"
                            kParserFlag_Recovering) 

#line 156 "parser.cog"
                                                    != 

#line 156 "parser.cog"
                                                       0;
}


#line 159 "parser.cog"
 void unexpected(

#line 159 "parser.cog"
                               

#line 159 "parser.cog"
                         Parser

#line 159 "parser.cog"
                               * parser)
{


#line 161 "parser.cog"
     if(

#line 161 "parser.cog"
        

#line 161 "parser.cog"
        !

#line 161 "parser.cog"
                     

#line 161 "parser.cog"
         isRecovering(

#line 161 "parser.cog"
                      parser))
{


#line 163 "parser.cog"
                 

#line 163 "parser.cog"
                 

#line 163 "parser.cog"
         diagnose(

#line 163 "parser.cog"
                         

#line 163 "parser.cog"
                  getSink(

#line 163 "parser.cog"
                          parser), 

#line 163 "parser.cog"
                                          

#line 163 "parser.cog"
                                   peekLoc(

#line 163 "parser.cog"
                                           parser), 

#line 163 "parser.cog"
                                                    kDiagnostic_unexpectedToken, 

#line 163 "parser.cog"
                                                                                              

#line 163 "parser.cog"
                                                                                 peekTokenCode(

#line 163 "parser.cog"
                                                                                               parser));


#line 164 "parser.cog"
                      

#line 164 "parser.cog"
                      

#line 164 "parser.cog"
               DEREF(

#line 164 "parser.cog"
         parser).flags 

#line 164 "parser.cog"
                      |= 

#line 164 "parser.cog"
                         kParserFlag_Recovering;
}
}


#line 168 "parser.cog"
 void unexpected(

#line 168 "parser.cog"
                               

#line 168 "parser.cog"
                         Parser

#line 168 "parser.cog"
                               * parser, 

#line 168 "parser.cog"
                                            TokenCode expected)
{


#line 170 "parser.cog"
     if(

#line 170 "parser.cog"
        

#line 170 "parser.cog"
        !

#line 170 "parser.cog"
                     

#line 170 "parser.cog"
         isRecovering(

#line 170 "parser.cog"
                      parser))
{


#line 172 "parser.cog"
                 

#line 172 "parser.cog"
                 

#line 172 "parser.cog"
         diagnose(

#line 172 "parser.cog"
                         

#line 172 "parser.cog"
                  getSink(

#line 172 "parser.cog"
                          parser), 

#line 172 "parser.cog"
                                          

#line 172 "parser.cog"
                                   peekLoc(

#line 172 "parser.cog"
                                           parser), 

#line 172 "parser.cog"
                                                    kDiagnostic_unexpectedTokenExpectedToken, 

#line 172 "parser.cog"
                                                                                                           

#line 172 "parser.cog"
                                                                                              peekTokenCode(

#line 172 "parser.cog"
                                                                                                            parser), 

#line 172 "parser.cog"
                                                                                                                     expected);


#line 173 "parser.cog"
                      

#line 173 "parser.cog"
                      

#line 173 "parser.cog"
               DEREF(

#line 173 "parser.cog"
         parser).flags 

#line 173 "parser.cog"
                      |= 

#line 173 "parser.cog"
                         kParserFlag_Recovering;
}
}


#line 177 "parser.cog"
 

#line 181 "parser.cog"
        Bool tokenIsInSet(

#line 178 "parser.cog"
             TokenCode needle, 

#line 179 "parser.cog"
            Int count, 

#line 180 "parser.cog"
                       

#line 180 "parser.cog"
               ConstPtr<

#line 180 "parser.cog"
                        TokenCode>  haystack)
{


#line 183 "parser.cog"
     {


#line 183 "parser.cog"
         

#line 183 "parser.cog"
         auto ii = 

#line 183 "parser.cog"
                  0;
for(;

#line 183 "parser.cog"
                        

#line 183 "parser.cog"
                     ii 

#line 183 "parser.cog"
                        < 

#line 183 "parser.cog"
                          count;

#line 183 "parser.cog"
                                 

#line 183 "parser.cog"
                                 ++

#line 183 "parser.cog"
                                   ii)
{
{


#line 185 "parser.cog"
         if(

#line 185 "parser.cog"
                   

#line 185 "parser.cog"
            needle 

#line 185 "parser.cog"
                   == 

#line 185 "parser.cog"
                              

#line 185 "parser.cog"
                      haystack[

#line 185 "parser.cog"
                               ii])
{


#line 187 "parser.cog"
             return 

#line 187 "parser.cog"
                    true;
}
}
}}


#line 190 "parser.cog"
     return 

#line 190 "parser.cog"
            false;
}


#line 193 "parser.cog"
 

#line 198 "parser.cog"
        Bool recoverIfTokenIsInSet(

#line 194 "parser.cog"
                   

#line 194 "parser.cog"
             Parser

#line 194 "parser.cog"
                   * parser, 

#line 195 "parser.cog"
             TokenCode needle, 

#line 196 "parser.cog"
            Int count, 

#line 197 "parser.cog"
                       

#line 197 "parser.cog"
               ConstPtr<

#line 197 "parser.cog"
                        TokenCode>  haystack)
{


#line 200 "parser.cog"
     if(

#line 200 "parser.cog"
                    

#line 200 "parser.cog"
        tokenIsInSet(

#line 200 "parser.cog"
                     needle, 

#line 200 "parser.cog"
                             count, 

#line 200 "parser.cog"
                                    haystack))
{


#line 202 "parser.cog"
                      

#line 202 "parser.cog"
                      

#line 202 "parser.cog"
               DEREF(

#line 202 "parser.cog"
         parser).flags 

#line 202 "parser.cog"
                      &= 

#line 202 "parser.cog"
                         

#line 202 "parser.cog"
                         ~

#line 202 "parser.cog"
                          kParserFlag_Recovering;


#line 203 "parser.cog"
         return 

#line 203 "parser.cog"
                true;
}


#line 205 "parser.cog"
     return 

#line 205 "parser.cog"
            false;
}


#line 208 "parser.cog"
 void tryRecover(

#line 209 "parser.cog"
                   

#line 209 "parser.cog"
             Parser

#line 209 "parser.cog"
                   * parser, 

#line 210 "parser.cog"
                         Int recoverBeforeCount, 

#line 211 "parser.cog"
                            

#line 211 "parser.cog"
                    ConstPtr<

#line 211 "parser.cog"
                             TokenCode>  recoverBefore, 

#line 212 "parser.cog"
                        Int recoverAfterCount, 

#line 213 "parser.cog"
                           

#line 213 "parser.cog"
                   ConstPtr<

#line 213 "parser.cog"
                            TokenCode>  recoverAfter)
{


#line 215 "parser.cog"
     if(

#line 215 "parser.cog"
        

#line 215 "parser.cog"
        !

#line 215 "parser.cog"
                     

#line 215 "parser.cog"
         isRecovering(

#line 215 "parser.cog"
                      parser))
{


#line 216 "parser.cog"
         return;
}


#line 219 "parser.cog"
     while(

#line 219 "parser.cog"
           

#line 219 "parser.cog"
           !

#line 219 "parser.cog"
                   

#line 219 "parser.cog"
            isAtEnd(

#line 219 "parser.cog"
                    parser))
{
{


#line 221 "parser.cog"
         

#line 221 "parser.cog"
         auto peek = 

#line 221 "parser.cog"
                                 

#line 221 "parser.cog"
                    peekTokenCode(

#line 221 "parser.cog"
                                  parser);


#line 225 "parser.cog"
         if(

#line 225 "parser.cog"
                                 

#line 225 "parser.cog"
            recoverIfTokenIsInSet(

#line 225 "parser.cog"
                                  parser, 

#line 225 "parser.cog"
                                          peek, 

#line 225 "parser.cog"
                                                recoverBeforeCount, 

#line 225 "parser.cog"
                                                                    recoverBefore))
{


#line 228 "parser.cog"
             return;
}


#line 234 "parser.cog"
         if(

#line 234 "parser.cog"
                                 

#line 234 "parser.cog"
            recoverIfTokenIsInSet(

#line 234 "parser.cog"
                                  parser, 

#line 234 "parser.cog"
                                          peek, 

#line 234 "parser.cog"
                                                recoverAfterCount, 

#line 234 "parser.cog"
                                                                   recoverAfter))
{


#line 237 "parser.cog"
                         

#line 237 "parser.cog"
                         

#line 237 "parser.cog"
             advanceToken(

#line 237 "parser.cog"
                          parser);


#line 238 "parser.cog"
             return;
}


#line 243 "parser.cog"
         switch(

#line 243 "parser.cog"
                peek)
{
case 

#line 245 "parser.cog"
              kTokenCode_EndOfFile:
case 

#line 246 "parser.cog"
              kTokenCode_RCurly:
case 

#line 247 "parser.cog"
              kTokenCode_RParen:
case 

#line 248 "parser.cog"
              kTokenCode_RSquare:
{


#line 251 "parser.cog"
             return;
}
default:
{


#line 254 "parser.cog"
             break;
}
}


#line 259 "parser.cog"
                        

#line 259 "parser.cog"
                        

#line 259 "parser.cog"
         advanceFragment(

#line 259 "parser.cog"
                         parser);
}
}
}


#line 264 "parser.cog"
 void tryRecover(

#line 264 "parser.cog"
                               

#line 264 "parser.cog"
                         Parser

#line 264 "parser.cog"
                               * parser)
{


#line 266 "parser.cog"
     if(

#line 266 "parser.cog"
        

#line 266 "parser.cog"
        !

#line 266 "parser.cog"
                     

#line 266 "parser.cog"
         isRecovering(

#line 266 "parser.cog"
                      parser))
{


#line 267 "parser.cog"
         return;
}


#line 272 "parser.cog"
     

#line 272 "parser.cog"
     

#line 272 "parser.cog"
                                       

#line 272 "parser.cog"
                         FixedSizeArray<

#line 272 "parser.cog"
                                        1, 

#line 272 "parser.cog"
                                           TokenCode>  recoverBefore;


#line 273 "parser.cog"
                  

#line 273 "parser.cog"
     recoverBefore[

#line 273 "parser.cog"
                   0] = 

#line 273 "parser.cog"
                        kTokenCode_LCurly;


#line 275 "parser.cog"
     

#line 275 "parser.cog"
     

#line 275 "parser.cog"
                                      

#line 275 "parser.cog"
                        FixedSizeArray<

#line 275 "parser.cog"
                                       2, 

#line 275 "parser.cog"
                                          TokenCode>  recoverAfter;


#line 276 "parser.cog"
                 

#line 276 "parser.cog"
     recoverAfter[

#line 276 "parser.cog"
                  0] = 

#line 276 "parser.cog"
                       kTokenCode_Semi;


#line 277 "parser.cog"
                 

#line 277 "parser.cog"
     recoverAfter[

#line 277 "parser.cog"
                  1] = 

#line 277 "parser.cog"
                       kTokenCode_RCurly;


#line 280 "parser.cog"
               

#line 280 "parser.cog"
               

#line 280 "parser.cog"
     tryRecover(

#line 280 "parser.cog"
                parser, 

#line 280 "parser.cog"
                        1, 

#line 280 "parser.cog"
                           recoverBefore, 

#line 280 "parser.cog"
                                          2, 

#line 280 "parser.cog"
                                             recoverAfter);
}


#line 284 "parser.cog"
 void tryRecoverBefore(

#line 284 "parser.cog"
                                     

#line 284 "parser.cog"
                               Parser

#line 284 "parser.cog"
                                     * parser, 

#line 284 "parser.cog"
                                              TokenCode code)
{


#line 286 "parser.cog"
     if(

#line 286 "parser.cog"
         

#line 286 "parser.cog"
         !

#line 286 "parser.cog"
                      

#line 286 "parser.cog"
          isRecovering(

#line 286 "parser.cog"
                       parser))
{


#line 287 "parser.cog"
         return;
}


#line 290 "parser.cog"
     

#line 290 "parser.cog"
     

#line 290 "parser.cog"
                                       

#line 290 "parser.cog"
                         FixedSizeArray<

#line 290 "parser.cog"
                                        1, 

#line 290 "parser.cog"
                                           TokenCode>  recoverBefore;


#line 291 "parser.cog"
                  

#line 291 "parser.cog"
     recoverBefore[

#line 291 "parser.cog"
                   0] = 

#line 291 "parser.cog"
                        code;


#line 293 "parser.cog"
               

#line 293 "parser.cog"
               

#line 293 "parser.cog"
     tryRecover(

#line 293 "parser.cog"
                parser, 

#line 293 "parser.cog"
                        1, 

#line 293 "parser.cog"
                           recoverBefore, 

#line 293 "parser.cog"
                                          0, 

#line 293 "parser.cog"
                                             nullptr);
}


#line 297 "parser.cog"
 

#line 300 "parser.cog"
                

#line 300 "parser.cog"
        ConstPtr<

#line 300 "parser.cog"
                 Token>  advanceIf(

#line 298 "parser.cog"
                   

#line 298 "parser.cog"
             Parser

#line 298 "parser.cog"
                   * parser, 

#line 299 "parser.cog"
               TokenCode expected)
{


#line 302 "parser.cog"
     if(

#line 302 "parser.cog"
                              

#line 302 "parser.cog"
                     

#line 302 "parser.cog"
        peekTokenCode(

#line 302 "parser.cog"
                      parser) 

#line 302 "parser.cog"
                              == 

#line 302 "parser.cog"
                                 expected)
{


#line 304 "parser.cog"
         return 

#line 304 "parser.cog"
                            

#line 304 "parser.cog"
                advanceToken(

#line 304 "parser.cog"
                             parser);
}


#line 306 "parser.cog"
     return 

#line 306 "parser.cog"
            0;
}


#line 309 "parser.cog"
 

#line 312 "parser.cog"
                

#line 312 "parser.cog"
        ConstPtr<

#line 312 "parser.cog"
                 Token>  advanceIf(

#line 310 "parser.cog"
                   

#line 310 "parser.cog"
             Parser

#line 310 "parser.cog"
                   * parser, 

#line 311 "parser.cog"
               StringSpan expected)
{


#line 314 "parser.cog"
     switch(

#line 314 "parser.cog"
                         

#line 314 "parser.cog"
            peekTokenCode(

#line 314 "parser.cog"
                          parser))
{
case 

#line 316 "parser.cog"
          kTokenCode_Identifier:
{


#line 317 "parser.cog"
         if(

#line 317 "parser.cog"
                                                   

#line 317 "parser.cog"
                   

#line 317 "parser.cog"
            getText(

#line 317 "parser.cog"
                           

#line 317 "parser.cog"
                    (

#line 317 "parser.cog"
                         

#line 317 "parser.cog"
                     Name

#line 317 "parser.cog"
                         *)(

#line 317 "parser.cog"
                                        DEREF(

#line 317 "parser.cog"
                                  DEREF(

#line 317 "parser.cog"
                            parser).token).rawData)) 

#line 317 "parser.cog"
                                                   == 

#line 317 "parser.cog"
                                                      expected)
{


#line 319 "parser.cog"
             return 

#line 319 "parser.cog"
                                

#line 319 "parser.cog"
                    advanceToken(

#line 319 "parser.cog"
                                 parser);
}
}
default:
{


#line 323 "parser.cog"
         break;
}
}


#line 325 "parser.cog"
     return 

#line 325 "parser.cog"
            0;
}


#line 328 "parser.cog"
 

#line 331 "parser.cog"
                

#line 331 "parser.cog"
        ConstPtr<

#line 331 "parser.cog"
                 Token>  advanceIfFragment(

#line 329 "parser.cog"
                   

#line 329 "parser.cog"
             Parser

#line 329 "parser.cog"
                   * parser, 

#line 330 "parser.cog"
               TokenCode expected)
{


#line 333 "parser.cog"
     if(

#line 333 "parser.cog"
                              

#line 333 "parser.cog"
                     

#line 333 "parser.cog"
        peekTokenCode(

#line 333 "parser.cog"
                      parser) 

#line 333 "parser.cog"
                              == 

#line 333 "parser.cog"
                                 expected)
{


#line 335 "parser.cog"
         return 

#line 335 "parser.cog"
                               

#line 335 "parser.cog"
                advanceFragment(

#line 335 "parser.cog"
                                parser);
}


#line 337 "parser.cog"
     return 

#line 337 "parser.cog"
            0;
}


#line 340 "parser.cog"
 

#line 343 "parser.cog"
                

#line 343 "parser.cog"
        ConstPtr<

#line 343 "parser.cog"
                 Token>  expect(

#line 341 "parser.cog"
                   

#line 341 "parser.cog"
             Parser

#line 341 "parser.cog"
                   * parser, 

#line 342 "parser.cog"
               TokenCode expected)
{


#line 345 "parser.cog"
     if(auto token = 

#line 345 "parser.cog"
                             

#line 345 "parser.cog"
                    advanceIf(

#line 345 "parser.cog"
                              parser, 

#line 345 "parser.cog"
                                      expected))
{


#line 346 "parser.cog"
         return 

#line 346 "parser.cog"
                token;
}


#line 348 "parser.cog"
               

#line 348 "parser.cog"
               

#line 348 "parser.cog"
     unexpected(

#line 348 "parser.cog"
                parser, 

#line 348 "parser.cog"
                        expected);


#line 349 "parser.cog"
     return 

#line 349 "parser.cog"
            0;
}


#line 352 "parser.cog"
 

#line 355 "parser.cog"
                

#line 355 "parser.cog"
        ConstPtr<

#line 355 "parser.cog"
                 Token>  expectFragment(

#line 353 "parser.cog"
                   

#line 353 "parser.cog"
             Parser

#line 353 "parser.cog"
                   * parser, 

#line 354 "parser.cog"
               TokenCode expected)
{


#line 357 "parser.cog"
     if(auto token = 

#line 357 "parser.cog"
                                     

#line 357 "parser.cog"
                    advanceIfFragment(

#line 357 "parser.cog"
                                      parser, 

#line 357 "parser.cog"
                                              expected))
{


#line 358 "parser.cog"
         return 

#line 358 "parser.cog"
                token;
}


#line 360 "parser.cog"
               

#line 360 "parser.cog"
               

#line 360 "parser.cog"
     unexpected(

#line 360 "parser.cog"
                parser, 

#line 360 "parser.cog"
                        expected);


#line 361 "parser.cog"
     return 

#line 361 "parser.cog"
            0;
}


#line 364 "parser.cog"
 

#line 366 "parser.cog"
            

#line 366 "parser.cog"
        Name

#line 366 "parser.cog"
            * expectIdentifier(

#line 365 "parser.cog"
                   

#line 365 "parser.cog"
             Parser

#line 365 "parser.cog"
                   * parser)
{


#line 368 "parser.cog"
     if(auto token = 

#line 368 "parser.cog"
                             

#line 368 "parser.cog"
                    advanceIf(

#line 368 "parser.cog"
                              parser, 

#line 368 "parser.cog"
                                      kTokenCode_Identifier))
{


#line 370 "parser.cog"
         

#line 370 "parser.cog"
         auto name = 

#line 370 "parser.cog"
                    cast<

#line 370 "parser.cog"
                            

#line 370 "parser.cog"
                         Ptr<

#line 370 "parser.cog"
                             Name> >(

#line 370 "parser.cog"
                                          DEREF(

#line 370 "parser.cog"
                                     token).rawData);


#line 371 "parser.cog"
         return 

#line 371 "parser.cog"
                name;
}
else
{


#line 375 "parser.cog"
                   

#line 375 "parser.cog"
                   

#line 375 "parser.cog"
         unexpected(

#line 375 "parser.cog"
                    parser, 

#line 375 "parser.cog"
                            kTokenCode_Identifier);


#line 376 "parser.cog"
         return 

#line 376 "parser.cog"
                0;
}
}


#line 381 "parser.cog"
 

#line 384 "parser.cog"
                

#line 384 "parser.cog"
        ConstPtr<

#line 384 "parser.cog"
                 Token>  advanceIfEnd(

#line 382 "parser.cog"
                   

#line 382 "parser.cog"
             Parser

#line 382 "parser.cog"
                   * parser, 

#line 383 "parser.cog"
               TokenCode expected)
{


#line 386 "parser.cog"
     if(

#line 386 "parser.cog"
               

#line 386 "parser.cog"
        isAtEnd(

#line 386 "parser.cog"
                parser))
{


#line 388 "parser.cog"
         return 

#line 388 "parser.cog"
                      

#line 388 "parser.cog"
                expect(

#line 388 "parser.cog"
                       parser, 

#line 388 "parser.cog"
                               expected);
}


#line 392 "parser.cog"
     return 

#line 392 "parser.cog"
                     

#line 392 "parser.cog"
            advanceIf(

#line 392 "parser.cog"
                      parser, 

#line 392 "parser.cog"
                              expected);
}


#line 611 "syntax.cog"
 

#line 616 "syntax.cog"
  LookupResultItem::LookupResultItem()
{


#line 618 "syntax.cog"
       DEREF(

#line 618 "syntax.cog"
   this).decl = 

#line 618 "syntax.cog"
               nullptr;
}


#line 624 "syntax.cog"
  LookupResultItem::LookupResultItem(

#line 624 "syntax.cog"
             Decl decl)
{


#line 626 "syntax.cog"
       DEREF(

#line 626 "syntax.cog"
   this).decl = 

#line 626 "syntax.cog"
               decl;
}


#line 630 "syntax.cog"
 

#line 634 "syntax.cog"
  

#line 634 "syntax.cog"
                     

#line 634 "syntax.cog"
                  Ptr<

#line 634 "syntax.cog"
                      LookupResultItem>  LookupResult::begin()
{


#line 634 "syntax.cog"
                                          return 

#line 634 "syntax.cog"
                                                            

#line 634 "syntax.cog"
                                                      DEREF(

#line 634 "syntax.cog"
                                                 items).begin();
}


#line 635 "syntax.cog"
  

#line 635 "syntax.cog"
                   

#line 635 "syntax.cog"
                Ptr<

#line 635 "syntax.cog"
                    LookupResultItem>  LookupResult::end()
{


#line 635 "syntax.cog"
                                        return 

#line 635 "syntax.cog"
                                                        

#line 635 "syntax.cog"
                                                    DEREF(

#line 635 "syntax.cog"
                                               items).end();
}


#line 638 "syntax.cog"
  

#line 638 "syntax.cog"
                    Bool LookupResult::isEmpty()
{


#line 638 "syntax.cog"
                           return 

#line 638 "syntax.cog"
                                                   

#line 638 "syntax.cog"
                                                

#line 638 "syntax.cog"
                                       DEREF(

#line 638 "syntax.cog"
                                  items).getCount() 

#line 638 "syntax.cog"
                                                   == 

#line 638 "syntax.cog"
                                                      0;
}


#line 639 "syntax.cog"
     

#line 639 "syntax.cog"
                        Bool LookupResult::isUnique()
{


#line 639 "syntax.cog"
                               return 

#line 639 "syntax.cog"
                                                       

#line 639 "syntax.cog"
                                                    

#line 639 "syntax.cog"
                                           DEREF(

#line 639 "syntax.cog"
                                      items).getCount() 

#line 639 "syntax.cog"
                                                       == 

#line 639 "syntax.cog"
                                                          1;
}


#line 640 "syntax.cog"
     

#line 640 "syntax.cog"
                            Bool LookupResult::isOverloaded()
{


#line 640 "syntax.cog"
                                   return 

#line 640 "syntax.cog"
                                                           

#line 640 "syntax.cog"
                                                        

#line 640 "syntax.cog"
                                               DEREF(

#line 640 "syntax.cog"
                                          items).getCount() 

#line 640 "syntax.cog"
                                                           > 

#line 640 "syntax.cog"
                                                             1;
}


#line 642 "syntax.cog"
     

#line 642 "syntax.cog"
                       Decl LookupResult::getDecl()
{


#line 644 "syntax.cog"
                  

#line 644 "syntax.cog"
                  

#line 644 "syntax.cog"
         cogAssert(

#line 644 "syntax.cog"
                           

#line 644 "syntax.cog"
                   isUnique());


#line 645 "syntax.cog"
         return 

#line 645 "syntax.cog"
                        DEREF(

#line 645 "syntax.cog"
                     

#line 645 "syntax.cog"
                items[

#line 645 "syntax.cog"
                      0]).decl;
}


#line 395 "parser.cog"
 

#line 398 "parser.cog"
        LookupResult lookup(

#line 396 "parser.cog"
                   

#line 396 "parser.cog"
             Parser

#line 396 "parser.cog"
                   * parser, 

#line 397 "parser.cog"
               

#line 397 "parser.cog"
           Name

#line 397 "parser.cog"
               * name)
{


#line 400 "parser.cog"
     return 

#line 400 "parser.cog"
                  

#line 400 "parser.cog"
            lookup(

#line 400 "parser.cog"
                         DEREF(

#line 400 "parser.cog"
                   parser).scope, 

#line 400 "parser.cog"
                                 name);
}


#line 405 "parser.cog"
 

#line 407 "parser.cog"
        SyntaxDecl getSyntaxDecl(

#line 406 "parser.cog"
                     

#line 406 "parser.cog"
             ConstRef<

#line 406 "parser.cog"
                      LookupResult>  result)
{


#line 409 "parser.cog"
     for(auto item : 

#line 409 "parser.cog"
                            

#line 409 "parser.cog"
                     UNCONST(

#line 409 "parser.cog"
                             result))
{
{


#line 412 "parser.cog"
         if(auto syntaxDecl = 

#line 412 "parser.cog"
                                           

#line 412 "parser.cog"
                               

#line 412 "parser.cog"
                             as<

#line 412 "parser.cog"
                                SyntaxDecl> (

#line 412 "parser.cog"
                                                DEREF(

#line 412 "parser.cog"
                                            item).decl))
{


#line 414 "parser.cog"
             return 

#line 414 "parser.cog"
                    syntaxDecl;
}
}
}


#line 419 "parser.cog"
     return 

#line 419 "parser.cog"
            nullptr;
}


#line 422 "parser.cog"
 

#line 425 "parser.cog"
        NameExp createNameExp(

#line 423 "parser.cog"
                   

#line 423 "parser.cog"
             Parser

#line 423 "parser.cog"
                   * parser, 

#line 424 "parser.cog"
                    

#line 424 "parser.cog"
            ConstPtr<

#line 424 "parser.cog"
                     Token>  token)
{


#line 427 "parser.cog"
     

#line 427 "parser.cog"
     auto name = 

#line 427 "parser.cog"
                cast<

#line 427 "parser.cog"
                        

#line 427 "parser.cog"
                     Ptr<

#line 427 "parser.cog"
                         Name> >(

#line 427 "parser.cog"
                                      DEREF(

#line 427 "parser.cog"
                                 token).rawData);


#line 428 "parser.cog"
     

#line 428 "parser.cog"
     auto exp = 

#line 428 "parser.cog"
                                    

#line 428 "parser.cog"
                           

#line 428 "parser.cog"
               createObject<

#line 428 "parser.cog"
                            NameExp> ();


#line 429 "parser.cog"
        DEREF(

#line 429 "parser.cog"
     exp).loc = 

#line 429 "parser.cog"
                           

#line 429 "parser.cog"
                    DEREF(

#line 429 "parser.cog"
               token).getLoc();


#line 430 "parser.cog"
        DEREF(

#line 430 "parser.cog"
     exp).name = 

#line 430 "parser.cog"
                name;


#line 431 "parser.cog"
        DEREF(

#line 431 "parser.cog"
     exp).scope = 

#line 431 "parser.cog"
                       DEREF(

#line 431 "parser.cog"
                 parser).scope;


#line 432 "parser.cog"
     return 

#line 432 "parser.cog"
            exp;
}


#line 435 "parser.cog"
 

#line 437 "parser.cog"
        Exp createErrorExp(

#line 436 "parser.cog"
                   

#line 436 "parser.cog"
             Parser

#line 436 "parser.cog"
                   * parser)
{


#line 439 "parser.cog"
     

#line 439 "parser.cog"
     auto exp = 

#line 439 "parser.cog"
                                     

#line 439 "parser.cog"
                           

#line 439 "parser.cog"
               createObject<

#line 439 "parser.cog"
                            ErrorExp> ();


#line 440 "parser.cog"
        DEREF(

#line 440 "parser.cog"
     exp).loc = 

#line 440 "parser.cog"
                      

#line 440 "parser.cog"
               peekLoc(

#line 440 "parser.cog"
                       parser);


#line 441 "parser.cog"
     return 

#line 441 "parser.cog"
            exp;
}


#line 444 "parser.cog"
 

#line 445 "parser.cog"
    Arg parseArg(

#line 444 "parser.cog"
                             

#line 444 "parser.cog"
                       Parser

#line 444 "parser.cog"
                             * parser)
{


#line 447 "parser.cog"
     

#line 447 "parser.cog"
     auto argExp = 

#line 447 "parser.cog"
                          

#line 447 "parser.cog"
                  parseExp(

#line 447 "parser.cog"
                           parser);


#line 448 "parser.cog"
     return 

#line 448 "parser.cog"
                               

#line 448 "parser.cog"
            createPositionalArg(

#line 448 "parser.cog"
                                parser, 

#line 448 "parser.cog"
                                        argExp);
}


#line 451 "parser.cog"
 

#line 453 "parser.cog"
             

#line 453 "parser.cog"
        Array<

#line 453 "parser.cog"
              Arg>  parseArgs(

#line 452 "parser.cog"
                   

#line 452 "parser.cog"
             Parser

#line 452 "parser.cog"
                   * parser)
{


#line 455 "parser.cog"
     

#line 455 "parser.cog"
     

#line 455 "parser.cog"
                    

#line 455 "parser.cog"
               Array<

#line 455 "parser.cog"
                     Arg>  args;


#line 456 "parser.cog"
     switch(

#line 456 "parser.cog"
                         

#line 456 "parser.cog"
            peekTokenCode(

#line 456 "parser.cog"
                          parser))
{
case 

#line 458 "parser.cog"
          kTokenCode_RParen:
case 

#line 459 "parser.cog"
          kTokenCode_RCurly:
case 

#line 460 "parser.cog"
          kTokenCode_RSquare:
case 

#line 461 "parser.cog"
          kTokenCode_EndOfFile:
{


#line 462 "parser.cog"
         return 

#line 462 "parser.cog"
                args;
}
default:
{


#line 465 "parser.cog"
         break;
}
}


#line 468 "parser.cog"
     {
for(;;)
{
{


#line 470 "parser.cog"
         

#line 470 "parser.cog"
         auto arg = 

#line 470 "parser.cog"
                           

#line 470 "parser.cog"
                   parseArg(

#line 470 "parser.cog"
                            parser);


#line 471 "parser.cog"
         if(

#line 471 "parser.cog"
            arg)
{


#line 473 "parser.cog"
                        

#line 473 "parser.cog"
                        

#line 473 "parser.cog"
                 DEREF(

#line 473 "parser.cog"
             args).append(

#line 473 "parser.cog"
                         arg);
}


#line 476 "parser.cog"
         switch(

#line 476 "parser.cog"
                             

#line 476 "parser.cog"
                peekTokenCode(

#line 476 "parser.cog"
                              parser))
{
case 

#line 478 "parser.cog"
              kTokenCode_RParen:
case 

#line 479 "parser.cog"
              kTokenCode_RCurly:
case 

#line 480 "parser.cog"
              kTokenCode_RSquare:
case 

#line 481 "parser.cog"
              kTokenCode_EndOfFile:
{


#line 482 "parser.cog"
             return 

#line 482 "parser.cog"
                    args;
}
default:
{


#line 485 "parser.cog"
             break;
}
}


#line 488 "parser.cog"
               

#line 488 "parser.cog"
               

#line 488 "parser.cog"
         expect(

#line 488 "parser.cog"
                parser, 

#line 488 "parser.cog"
                        kTokenCode_Comma);


#line 490 "parser.cog"
                         

#line 490 "parser.cog"
                         

#line 490 "parser.cog"
         tryRecoverBefore(

#line 490 "parser.cog"
                          parser, 

#line 490 "parser.cog"
                                  kTokenCode_RParen);
}
}}
}


#line 494 "parser.cog"
 

#line 495 "parser.cog"
        Arg parseGenericArg(

#line 494 "parser.cog"
                                    

#line 494 "parser.cog"
                              Parser

#line 494 "parser.cog"
                                    * parser)
{


#line 497 "parser.cog"
     

#line 497 "parser.cog"
     auto flags = 

#line 497 "parser.cog"
                       DEREF(

#line 497 "parser.cog"
                 parser).flags;


#line 498 "parser.cog"
                  

#line 498 "parser.cog"
                  

#line 498 "parser.cog"
           DEREF(

#line 498 "parser.cog"
     parser).flags 

#line 498 "parser.cog"
                  |= 

#line 498 "parser.cog"
                     kParserFlag_InsideGenericClause;


#line 499 "parser.cog"
     

#line 499 "parser.cog"
     auto arg = 

#line 499 "parser.cog"
                       

#line 499 "parser.cog"
               parseArg(

#line 499 "parser.cog"
                        parser);


#line 500 "parser.cog"
           DEREF(

#line 500 "parser.cog"
     parser).flags = 

#line 500 "parser.cog"
                    flags;


#line 501 "parser.cog"
     return 

#line 501 "parser.cog"
            arg;
}


#line 504 "parser.cog"
 

#line 506 "parser.cog"
             

#line 506 "parser.cog"
        Array<

#line 506 "parser.cog"
              Arg>  parseGenericArgs(

#line 505 "parser.cog"
                   

#line 505 "parser.cog"
             Parser

#line 505 "parser.cog"
                   * parser)
{


#line 508 "parser.cog"
     

#line 508 "parser.cog"
     

#line 508 "parser.cog"
                    

#line 508 "parser.cog"
               Array<

#line 508 "parser.cog"
                     Arg>  args;


#line 509 "parser.cog"
     if(

#line 509 "parser.cog"
                        

#line 509 "parser.cog"
        peekGenericClose(

#line 509 "parser.cog"
                         parser))
{


#line 510 "parser.cog"
         return 

#line 510 "parser.cog"
                args;
}


#line 512 "parser.cog"
     {
for(;;)
{
{


#line 514 "parser.cog"
         

#line 514 "parser.cog"
         auto arg = 

#line 514 "parser.cog"
                                  

#line 514 "parser.cog"
                   parseGenericArg(

#line 514 "parser.cog"
                                   parser);


#line 515 "parser.cog"
         if(

#line 515 "parser.cog"
            arg)
{


#line 517 "parser.cog"
                        

#line 517 "parser.cog"
                        

#line 517 "parser.cog"
                 DEREF(

#line 517 "parser.cog"
             args).append(

#line 517 "parser.cog"
                         arg);
}


#line 520 "parser.cog"
         if(

#line 520 "parser.cog"
                            

#line 520 "parser.cog"
            peekGenericClose(

#line 520 "parser.cog"
                             parser))
{


#line 521 "parser.cog"
             return 

#line 521 "parser.cog"
                    args;
}


#line 523 "parser.cog"
               

#line 523 "parser.cog"
               

#line 523 "parser.cog"
         expect(

#line 523 "parser.cog"
                parser, 

#line 523 "parser.cog"
                        kTokenCode_Comma);
}
}}
}


#line 527 "parser.cog"
 

#line 529 "parser.cog"
        Bool peekGenericApp(

#line 528 "parser.cog"
                     

#line 528 "parser.cog"
               Parser

#line 528 "parser.cog"
                     * inParser)
{


#line 532 "parser.cog"
     

#line 532 "parser.cog"
     auto parserImpl = 

#line 532 "parser.cog"
                      

#line 532 "parser.cog"
                      *

#line 532 "parser.cog"
                       inParser;


#line 533 "parser.cog"
     

#line 533 "parser.cog"
     auto parser = 

#line 533 "parser.cog"
                  

#line 533 "parser.cog"
                  &

#line 533 "parser.cog"
                   parserImpl;


#line 536 "parser.cog"
     if(

#line 536 "parser.cog"
        

#line 536 "parser.cog"
        !

#line 536 "parser.cog"
                            

#line 536 "parser.cog"
         tryParseGenericOpen(

#line 536 "parser.cog"
                             parser))
{


#line 537 "parser.cog"
         return 

#line 537 "parser.cog"
                false;
}


#line 540 "parser.cog"
     {
for(;;)
{
{


#line 542 "parser.cog"
         if(

#line 542 "parser.cog"
                            

#line 542 "parser.cog"
            peekGenericClose(

#line 542 "parser.cog"
                             parser))
{


#line 543 "parser.cog"
             break;
}


#line 545 "parser.cog"
         switch(

#line 545 "parser.cog"
                             

#line 545 "parser.cog"
                peekTokenCode(

#line 545 "parser.cog"
                              parser))
{
case 

#line 547 "parser.cog"
              kTokenCode_EndOfFile:
case 

#line 548 "parser.cog"
              kTokenCode_RParen:
case 

#line 549 "parser.cog"
              kTokenCode_RSquare:
case 

#line 550 "parser.cog"
              kTokenCode_RCurly:
case 

#line 551 "parser.cog"
              kTokenCode_Semi:
{


#line 552 "parser.cog"
             return 

#line 552 "parser.cog"
                    false;
}
default:
{


#line 557 "parser.cog"
                            

#line 557 "parser.cog"
                            

#line 557 "parser.cog"
             advanceFragment(

#line 557 "parser.cog"
                             parser);
}
{


#line 558 "parser.cog"
             break;
}
}
}
}}


#line 563 "parser.cog"
                       

#line 563 "parser.cog"
                       

#line 563 "parser.cog"
     expectGenericClose(

#line 563 "parser.cog"
                        parser);


#line 569 "parser.cog"
     return 

#line 569 "parser.cog"
            true;
}


#line 572 "parser.cog"
 

#line 575 "parser.cog"
        Exp maybeParseGenericApp(

#line 573 "parser.cog"
                   

#line 573 "parser.cog"
             Parser

#line 573 "parser.cog"
                   * parser, 

#line 574 "parser.cog"
           Exp base)
{


#line 577 "parser.cog"
     if(

#line 577 "parser.cog"
        

#line 577 "parser.cog"
        !

#line 577 "parser.cog"
                       

#line 577 "parser.cog"
         peekGenericApp(

#line 577 "parser.cog"
                        parser))
{


#line 578 "parser.cog"
         return 

#line 578 "parser.cog"
                base;
}


#line 580 "parser.cog"
  

#line 580 "parser.cog"
  auto loc = 

#line 580 "parser.cog"
                   

#line 580 "parser.cog"
            peekLoc(

#line 580 "parser.cog"
                    parser);


#line 581 "parser.cog"
                        

#line 581 "parser.cog"
                        

#line 581 "parser.cog"
     tryParseGenericOpen(

#line 581 "parser.cog"
                         parser);


#line 584 "parser.cog"
     

#line 584 "parser.cog"
     auto args = 

#line 584 "parser.cog"
                                

#line 584 "parser.cog"
                parseGenericArgs(

#line 584 "parser.cog"
                                 parser);


#line 586 "parser.cog"
                       

#line 586 "parser.cog"
                       

#line 586 "parser.cog"
     expectGenericClose(

#line 586 "parser.cog"
                        parser);


#line 588 "parser.cog"
     

#line 588 "parser.cog"
     auto exp = 

#line 588 "parser.cog"
                                          

#line 588 "parser.cog"
                           

#line 588 "parser.cog"
               createObject<

#line 588 "parser.cog"
                            GenericAppExp> ();


#line 589 "parser.cog"
     DEREF(

#line 589 "parser.cog"
  exp).loc = 

#line 589 "parser.cog"
            loc;


#line 590 "parser.cog"
        DEREF(

#line 590 "parser.cog"
     exp).base = 

#line 590 "parser.cog"
                base;


#line 591 "parser.cog"
        DEREF(

#line 591 "parser.cog"
     exp).args = 

#line 591 "parser.cog"
                args;


#line 592 "parser.cog"
     return 

#line 592 "parser.cog"
            exp;
}


#line 531 "syntax.cog"
 typedef 

#line 531 "syntax.cog"
                       Int64 IntLitVal;


#line 595 "parser.cog"
 

#line 597 "parser.cog"
        IntLitVal getIntegerLiteralVal(

#line 596 "parser.cog"
                    

#line 596 "parser.cog"
            ConstRef<

#line 596 "parser.cog"
                     Token>  token)
{


#line 599 "parser.cog"
     

#line 599 "parser.cog"
     auto textBegin = 

#line 599 "parser.cog"
                     cast<

#line 599 "parser.cog"
                                  

#line 599 "parser.cog"
                          ConstPtr<

#line 599 "parser.cog"
                                   Char> >(

#line 599 "parser.cog"
                                                DEREF(

#line 599 "parser.cog"
                                           token).rawData);


#line 600 "parser.cog"
     

#line 600 "parser.cog"
     auto textEnd = 

#line 600 "parser.cog"
                             

#line 600 "parser.cog"
                   textBegin 

#line 600 "parser.cog"
                             + 

#line 600 "parser.cog"
                                    DEREF(

#line 600 "parser.cog"
                               token).rawSize;


#line 602 "parser.cog"
     

#line 602 "parser.cog"
     

#line 602 "parser.cog"
               IntLitVal val = 

#line 602 "parser.cog"
                           0;


#line 603 "parser.cog"
     

#line 603 "parser.cog"
     auto base = 

#line 603 "parser.cog"
                10;


#line 605 "parser.cog"
     

#line 605 "parser.cog"
     auto tt = 

#line 605 "parser.cog"
              textBegin;


#line 606 "parser.cog"
     if(

#line 606 "parser.cog"
           

#line 606 "parser.cog"
        tt 

#line 606 "parser.cog"
           != 

#line 606 "parser.cog"
                      

#line 606 "parser.cog"
              textEnd 

#line 606 "parser.cog"
                      && 

#line 606 "parser.cog"
                             

#line 606 "parser.cog"
                         

#line 606 "parser.cog"
                         *

#line 606 "parser.cog"
                          tt 

#line 606 "parser.cog"
                             == 

#line 606 "parser.cog"
                                '0')
{


#line 608 "parser.cog"
         

#line 608 "parser.cog"
         

#line 608 "parser.cog"
         ++

#line 608 "parser.cog"
           tt;


#line 610 "parser.cog"
         if(

#line 610 "parser.cog"
               

#line 610 "parser.cog"
            tt 

#line 610 "parser.cog"
               == 

#line 610 "parser.cog"
                  textEnd)
{


#line 611 "parser.cog"
             return 

#line 611 "parser.cog"
                    0;
}


#line 613 "parser.cog"
         switch(

#line 613 "parser.cog"
                

#line 613 "parser.cog"
                *

#line 613 "parser.cog"
                 tt)
{
case 

#line 615 "parser.cog"
              'x':
case 

#line 615 "parser.cog"
                        'X':
{


#line 616 "parser.cog"
             base = 

#line 616 "parser.cog"
                    16;
}
{


#line 617 "parser.cog"
               

#line 617 "parser.cog"
               

#line 617 "parser.cog"
             tt

#line 617 "parser.cog"
               ++;
}
{


#line 618 "parser.cog"
             break;
}
case 

#line 619 "parser.cog"
              'b':
case 

#line 619 "parser.cog"
                        'B':
{


#line 620 "parser.cog"
             base = 

#line 620 "parser.cog"
                    2;
}
{


#line 621 "parser.cog"
               

#line 621 "parser.cog"
               

#line 621 "parser.cog"
             tt

#line 621 "parser.cog"
               ++;
}
{


#line 622 "parser.cog"
             break;
}
default:
{


#line 624 "parser.cog"
             break;
}
}
}


#line 628 "parser.cog"
     while(

#line 628 "parser.cog"
              

#line 628 "parser.cog"
           tt 

#line 628 "parser.cog"
              != 

#line 628 "parser.cog"
                 textEnd)
{
{


#line 630 "parser.cog"
         

#line 630 "parser.cog"
         auto c = 

#line 630 "parser.cog"
                 

#line 630 "parser.cog"
                 *

#line 630 "parser.cog"
                    

#line 630 "parser.cog"
                  tt

#line 630 "parser.cog"
                    ++;


#line 631 "parser.cog"
         if(

#line 631 "parser.cog"
                       

#line 631 "parser.cog"
            (

#line 631 "parser.cog"
               

#line 631 "parser.cog"
             c 

#line 631 "parser.cog"
               >= 

#line 631 "parser.cog"
                  '0') 

#line 631 "parser.cog"
                       && 

#line 631 "parser.cog"
                          (

#line 631 "parser.cog"
                             

#line 631 "parser.cog"
                           c 

#line 631 "parser.cog"
                             <= 

#line 631 "parser.cog"
                                '9'))
{


#line 633 "parser.cog"
             val = 

#line 633 "parser.cog"
                      

#line 633 "parser.cog"
                   val 

#line 633 "parser.cog"
                      * 

#line 633 "parser.cog"
                            

#line 633 "parser.cog"
                       base 

#line 633 "parser.cog"
                            + 

#line 633 "parser.cog"
                              (

#line 633 "parser.cog"
                                 

#line 633 "parser.cog"
                               c 

#line 633 "parser.cog"
                                 - 

#line 633 "parser.cog"
                                   '0');
}
}
}


#line 636 "parser.cog"
     return 

#line 636 "parser.cog"
            val;
}


#line 639 "parser.cog"
 

#line 641 "parser.cog"
        String getStringLiteralVal(

#line 640 "parser.cog"
                    

#line 640 "parser.cog"
            ConstRef<

#line 640 "parser.cog"
                     Token>  token)
{


#line 643 "parser.cog"
     

#line 643 "parser.cog"
     auto textBegin = 

#line 643 "parser.cog"
                     cast<

#line 643 "parser.cog"
                                  

#line 643 "parser.cog"
                          ConstPtr<

#line 643 "parser.cog"
                                   Char> >(

#line 643 "parser.cog"
                                                DEREF(

#line 643 "parser.cog"
                                           token).rawData);


#line 644 "parser.cog"
     

#line 644 "parser.cog"
     auto textEnd = 

#line 644 "parser.cog"
                             

#line 644 "parser.cog"
                   textBegin 

#line 644 "parser.cog"
                             + 

#line 644 "parser.cog"
                                    DEREF(

#line 644 "parser.cog"
                               token).rawSize;


#line 648 "parser.cog"
     

#line 648 "parser.cog"
     auto cursor = 

#line 648 "parser.cog"
                  textBegin;


#line 650 "parser.cog"
     

#line 650 "parser.cog"
     

#line 650 "parser.cog"
               String val;


#line 652 "parser.cog"
     

#line 652 "parser.cog"
     auto delimeter = 

#line 652 "parser.cog"
                     

#line 652 "parser.cog"
                     *

#line 652 "parser.cog"
                            

#line 652 "parser.cog"
                      cursor

#line 652 "parser.cog"
                            ++;


#line 653 "parser.cog"
     {
for(;;)
{
{


#line 655 "parser.cog"
         

#line 655 "parser.cog"
         auto c = 

#line 655 "parser.cog"
                 

#line 655 "parser.cog"
                 *

#line 655 "parser.cog"
                        

#line 655 "parser.cog"
                  cursor

#line 655 "parser.cog"
                        ++;


#line 657 "parser.cog"
         if(

#line 657 "parser.cog"
              

#line 657 "parser.cog"
            c 

#line 657 "parser.cog"
              == 

#line 657 "parser.cog"
                 delimeter)
{


#line 658 "parser.cog"
             break;
}


#line 660 "parser.cog"
         switch(

#line 660 "parser.cog"
                c)
{
case 

#line 662 "parser.cog"
              '\\':
{
{


#line 664 "parser.cog"
                 

#line 664 "parser.cog"
                 auto d = 

#line 664 "parser.cog"
                         

#line 664 "parser.cog"
                         *

#line 664 "parser.cog"
                                

#line 664 "parser.cog"
                          cursor

#line 664 "parser.cog"
                                ++;


#line 665 "parser.cog"
                 switch(

#line 665 "parser.cog"
                        d)
{
case 

#line 667 "parser.cog"
                      'r':
{


#line 667 "parser.cog"
                                     

#line 667 "parser.cog"
                                     

#line 667 "parser.cog"
                              DEREF(

#line 667 "parser.cog"
                           val).append(

#line 667 "parser.cog"
                                      '\r');
}
{


#line 667 "parser.cog"
                                             break;
}
case 

#line 668 "parser.cog"
                      'n':
{


#line 668 "parser.cog"
                                     

#line 668 "parser.cog"
                                     

#line 668 "parser.cog"
                              DEREF(

#line 668 "parser.cog"
                           val).append(

#line 668 "parser.cog"
                                      '\n');
}
{


#line 668 "parser.cog"
                                             break;
}
case 

#line 669 "parser.cog"
                      't':
{


#line 669 "parser.cog"
                                     

#line 669 "parser.cog"
                                     

#line 669 "parser.cog"
                              DEREF(

#line 669 "parser.cog"
                           val).append(

#line 669 "parser.cog"
                                      '\t');
}
{


#line 669 "parser.cog"
                                             break;
}
case 

#line 670 "parser.cog"
                      '\\':
{


#line 670 "parser.cog"
                                      

#line 670 "parser.cog"
                                      

#line 670 "parser.cog"
                               DEREF(

#line 670 "parser.cog"
                            val).append(

#line 670 "parser.cog"
                                       '\\');
}
{


#line 670 "parser.cog"
                                              break;
}
case 

#line 671 "parser.cog"
                      '\"':
{


#line 671 "parser.cog"
                                      

#line 671 "parser.cog"
                                      

#line 671 "parser.cog"
                               DEREF(

#line 671 "parser.cog"
                            val).append(

#line 671 "parser.cog"
                                       '\"');
}
{


#line 671 "parser.cog"
                                              break;
}
case 

#line 672 "parser.cog"
                      '\'':
{


#line 672 "parser.cog"
                                      

#line 672 "parser.cog"
                                      

#line 672 "parser.cog"
                               DEREF(

#line 672 "parser.cog"
                            val).append(

#line 672 "parser.cog"
                                       '\'');
}
{


#line 672 "parser.cog"
                                              break;
}
default:
{


#line 675 "parser.cog"
                              

#line 675 "parser.cog"
                              

#line 675 "parser.cog"
                     cogAssert(

#line 675 "parser.cog"
                               

#line 675 "parser.cog"
                               !

#line 675 "parser.cog"
                                "unimplemented");
}
{


#line 676 "parser.cog"
                     break;
}
}
}
}
{


#line 679 "parser.cog"
             break;
}
default:
{


#line 681 "parser.cog"
                       

#line 681 "parser.cog"
                       

#line 681 "parser.cog"
                DEREF(

#line 681 "parser.cog"
             val).append(

#line 681 "parser.cog"
                        c);
}
{


#line 682 "parser.cog"
             break;
}
}
}
}}


#line 686 "parser.cog"
     return 

#line 686 "parser.cog"
            val;
}


#line 689 "parser.cog"
 

#line 691 "parser.cog"
        Exp parseAtomicExp(

#line 690 "parser.cog"
                   

#line 690 "parser.cog"
             Parser

#line 690 "parser.cog"
                   * parser)
{


#line 693 "parser.cog"
     switch(

#line 693 "parser.cog"
                         

#line 693 "parser.cog"
            peekTokenCode(

#line 693 "parser.cog"
                          parser))
{
case 

#line 695 "parser.cog"
          kTokenCode_Identifier:
{
{


#line 698 "parser.cog"
             

#line 698 "parser.cog"
             auto loc = 

#line 698 "parser.cog"
                              

#line 698 "parser.cog"
                       peekLoc(

#line 698 "parser.cog"
                               parser);


#line 699 "parser.cog"
             

#line 699 "parser.cog"
             auto name = 

#line 699 "parser.cog"
                        cast<

#line 699 "parser.cog"
                                

#line 699 "parser.cog"
                             Ptr<

#line 699 "parser.cog"
                                 Name> >(

#line 699 "parser.cog"
                                                     DEREF(

#line 699 "parser.cog"
                                               DEREF(

#line 699 "parser.cog"
                                         parser).token).rawData);


#line 700 "parser.cog"
             

#line 700 "parser.cog"
             auto result = 

#line 700 "parser.cog"
                                

#line 700 "parser.cog"
                          lookup(

#line 700 "parser.cog"
                                 parser, 

#line 700 "parser.cog"
                                         name);


#line 702 "parser.cog"
             if(auto syntax = 

#line 702 "parser.cog"
                                          

#line 702 "parser.cog"
                             getSyntaxDecl(

#line 702 "parser.cog"
                                           result))
{


#line 704 "parser.cog"
                 if(

#line 704 "parser.cog"
                              

#line 704 "parser.cog"
                    isSubClass(

#line 704 "parser.cog"
                                     DEREF(

#line 704 "parser.cog"
                               syntax).syntaxClass, 

#line 704 "parser.cog"
                                                                

#line 704 "parser.cog"
                                                           

#line 704 "parser.cog"
                                                   getClass<

#line 704 "parser.cog"
                                                            Exp> ()))
{


#line 706 "parser.cog"
                                 

#line 706 "parser.cog"
                                 

#line 706 "parser.cog"
                     advanceToken(

#line 706 "parser.cog"
                                  parser);


#line 708 "parser.cog"
                     

#line 708 "parser.cog"
                     auto result = 

#line 708 "parser.cog"
                                                 

#line 708 "parser.cog"
                                        DEREF(

#line 708 "parser.cog"
                                  syntax).callback(

#line 708 "parser.cog"
                                                  parser);


#line 709 "parser.cog"
                     

#line 709 "parser.cog"
                     auto resultExp = 

#line 709 "parser.cog"
                                            

#line 709 "parser.cog"
                                       

#line 709 "parser.cog"
                                     as<

#line 709 "parser.cog"
                                        Exp> (

#line 709 "parser.cog"
                                             result);


#line 713 "parser.cog"
                              DEREF(

#line 713 "parser.cog"
                     resultExp).loc = 

#line 713 "parser.cog"
                                     loc;


#line 715 "parser.cog"
                     return 

#line 715 "parser.cog"
                            resultExp;
}
}


#line 720 "parser.cog"
             

#line 720 "parser.cog"
             auto nameToken = 

#line 720 "parser.cog"
                                         

#line 720 "parser.cog"
                             advanceToken(

#line 720 "parser.cog"
                                          parser);


#line 721 "parser.cog"
             

#line 721 "parser.cog"
             auto exp = 

#line 721 "parser.cog"
                                    

#line 721 "parser.cog"
                       createNameExp(

#line 721 "parser.cog"
                                     parser, 

#line 721 "parser.cog"
                                             nameToken);


#line 722 "parser.cog"
             return 

#line 722 "parser.cog"
                                        

#line 722 "parser.cog"
                    maybeParseGenericApp(

#line 722 "parser.cog"
                                         parser, 

#line 722 "parser.cog"
                                                 exp);
}
}
{


#line 724 "parser.cog"
         break;
}
case 

#line 730 "parser.cog"
          kTokenCode_IntegerLiteral:
{
{


#line 732 "parser.cog"
             

#line 732 "parser.cog"
             auto token = 

#line 732 "parser.cog"
                                     

#line 732 "parser.cog"
                         advanceToken(

#line 732 "parser.cog"
                                      parser);


#line 733 "parser.cog"
             

#line 733 "parser.cog"
             auto exp = 

#line 733 "parser.cog"
                                              

#line 733 "parser.cog"
                                   

#line 733 "parser.cog"
                       createObject<

#line 733 "parser.cog"
                                    IntLitExp> ();


#line 734 "parser.cog"
                DEREF(

#line 734 "parser.cog"
             exp).loc = 

#line 734 "parser.cog"
                                   

#line 734 "parser.cog"
                            DEREF(

#line 734 "parser.cog"
                       token).getLoc();


#line 735 "parser.cog"
                DEREF(

#line 735 "parser.cog"
             exp).val = 

#line 735 "parser.cog"
                                           

#line 735 "parser.cog"
                       getIntegerLiteralVal(

#line 735 "parser.cog"
                                            

#line 735 "parser.cog"
                                            *

#line 735 "parser.cog"
                                             token);


#line 736 "parser.cog"
             return 

#line 736 "parser.cog"
                    exp;
}
}
case 

#line 739 "parser.cog"
          kTokenCode_StringLiteral:
{
{


#line 741 "parser.cog"
             

#line 741 "parser.cog"
             auto token = 

#line 741 "parser.cog"
                                     

#line 741 "parser.cog"
                         advanceToken(

#line 741 "parser.cog"
                                      parser);


#line 742 "parser.cog"
             

#line 742 "parser.cog"
             auto exp = 

#line 742 "parser.cog"
                                                 

#line 742 "parser.cog"
                                   

#line 742 "parser.cog"
                       createObject<

#line 742 "parser.cog"
                                    StringLitExp> ();


#line 743 "parser.cog"
                DEREF(

#line 743 "parser.cog"
             exp).loc = 

#line 743 "parser.cog"
                                   

#line 743 "parser.cog"
                            DEREF(

#line 743 "parser.cog"
                       token).getLoc();


#line 744 "parser.cog"
                DEREF(

#line 744 "parser.cog"
             exp).val = 

#line 744 "parser.cog"
                                          

#line 744 "parser.cog"
                       getStringLiteralVal(

#line 744 "parser.cog"
                                           

#line 744 "parser.cog"
                                           *

#line 744 "parser.cog"
                                            token);


#line 745 "parser.cog"
             return 

#line 745 "parser.cog"
                    exp;
}
}
case 

#line 748 "parser.cog"
          kTokenCode_CharacterLiteral:
{
{


#line 750 "parser.cog"
             

#line 750 "parser.cog"
             auto token = 

#line 750 "parser.cog"
                                     

#line 750 "parser.cog"
                         advanceToken(

#line 750 "parser.cog"
                                      parser);


#line 751 "parser.cog"
             

#line 751 "parser.cog"
             auto exp = 

#line 751 "parser.cog"
                                                    

#line 751 "parser.cog"
                                   

#line 751 "parser.cog"
                       createObject<

#line 751 "parser.cog"
                                    CharacterLitExp> ();


#line 752 "parser.cog"
                DEREF(

#line 752 "parser.cog"
             exp).loc = 

#line 752 "parser.cog"
                                   

#line 752 "parser.cog"
                            DEREF(

#line 752 "parser.cog"
                       token).getLoc();


#line 753 "parser.cog"
                DEREF(

#line 753 "parser.cog"
             exp).val = 

#line 753 "parser.cog"
                                          

#line 753 "parser.cog"
                       getStringLiteralVal(

#line 753 "parser.cog"
                                           

#line 753 "parser.cog"
                                           *

#line 753 "parser.cog"
                                            token);


#line 754 "parser.cog"
             return 

#line 754 "parser.cog"
                    exp;
}
}
case 

#line 757 "parser.cog"
          kTokenCode_LParen:
{
{


#line 759 "parser.cog"
             

#line 759 "parser.cog"
             auto open = 

#line 759 "parser.cog"
                                    

#line 759 "parser.cog"
                        advanceToken(

#line 759 "parser.cog"
                                     parser);


#line 760 "parser.cog"
             

#line 760 "parser.cog"
             auto inner = 

#line 760 "parser.cog"
                                 

#line 760 "parser.cog"
                         parseExp(

#line 760 "parser.cog"
                                  parser);


#line 761 "parser.cog"
                   

#line 761 "parser.cog"
                   

#line 761 "parser.cog"
             expect(

#line 761 "parser.cog"
                    parser, 

#line 761 "parser.cog"
                            kTokenCode_RParen);


#line 765 "parser.cog"
             

#line 765 "parser.cog"
             auto exp = 

#line 765 "parser.cog"
                                             

#line 765 "parser.cog"
                                   

#line 765 "parser.cog"
                       createObject<

#line 765 "parser.cog"
                                    ParenExp> ();


#line 766 "parser.cog"
                DEREF(

#line 766 "parser.cog"
             exp).loc = 

#line 766 "parser.cog"
                                  

#line 766 "parser.cog"
                           DEREF(

#line 766 "parser.cog"
                       open).getLoc();


#line 767 "parser.cog"
                DEREF(

#line 767 "parser.cog"
             exp).base = 

#line 767 "parser.cog"
                        inner;


#line 769 "parser.cog"
             return 

#line 769 "parser.cog"
                    exp;
}
}
default:
{


#line 773 "parser.cog"
                   

#line 773 "parser.cog"
                   

#line 773 "parser.cog"
         unexpected(

#line 773 "parser.cog"
                    parser);
}
{


#line 774 "parser.cog"
         return 

#line 774 "parser.cog"
                              

#line 774 "parser.cog"
                createErrorExp(

#line 774 "parser.cog"
                               parser);
}
}
}


#line 778 "parser.cog"
 

#line 781 "parser.cog"
        Arg createPositionalArg(

#line 779 "parser.cog"
                   

#line 779 "parser.cog"
             Parser

#line 779 "parser.cog"
                   * parser, 

#line 780 "parser.cog"
          Exp exp)
{


#line 783 "parser.cog"
     

#line 783 "parser.cog"
     auto arg = 

#line 783 "parser.cog"
                                          

#line 783 "parser.cog"
                           

#line 783 "parser.cog"
               createObject<

#line 783 "parser.cog"
                            PositionalArg> ();


#line 784 "parser.cog"
        DEREF(

#line 784 "parser.cog"
     arg).loc = 

#line 784 "parser.cog"
                  DEREF(

#line 784 "parser.cog"
               exp).loc;


#line 785 "parser.cog"
        DEREF(

#line 785 "parser.cog"
     arg).exp = 

#line 785 "parser.cog"
               exp;


#line 786 "parser.cog"
     return 

#line 786 "parser.cog"
            arg;
}


#line 789 "parser.cog"
 

#line 794 "parser.cog"
        AppExpBase createApp(

#line 790 "parser.cog"
                   

#line 790 "parser.cog"
             Parser

#line 790 "parser.cog"
                   * parser, 

#line 791 "parser.cog"
          AppExpBase exp, 

#line 792 "parser.cog"
                 

#line 792 "parser.cog"
         ConstPtr<

#line 792 "parser.cog"
                  Token>  op, 

#line 793 "parser.cog"
             Exp argExp)
{


#line 796 "parser.cog"
        DEREF(

#line 796 "parser.cog"
     exp).loc = 

#line 796 "parser.cog"
                        

#line 796 "parser.cog"
                 DEREF(

#line 796 "parser.cog"
               op).getLoc();


#line 797 "parser.cog"
        DEREF(

#line 797 "parser.cog"
     exp).base = 

#line 797 "parser.cog"
                             

#line 797 "parser.cog"
                createNameExp(

#line 797 "parser.cog"
                              parser, 

#line 797 "parser.cog"
                                      op);


#line 799 "parser.cog"
     

#line 799 "parser.cog"
     

#line 799 "parser.cog"
                    

#line 799 "parser.cog"
               Array<

#line 799 "parser.cog"
                     Arg>  args;


#line 800 "parser.cog"
                

#line 800 "parser.cog"
                

#line 800 "parser.cog"
         DEREF(

#line 800 "parser.cog"
     args).append(

#line 800 "parser.cog"
                                    

#line 800 "parser.cog"
                 createPositionalArg(

#line 800 "parser.cog"
                                     parser, 

#line 800 "parser.cog"
                                             argExp));


#line 801 "parser.cog"
        DEREF(

#line 801 "parser.cog"
     exp).args = 

#line 801 "parser.cog"
                args;


#line 802 "parser.cog"
     return 

#line 802 "parser.cog"
            exp;
}


#line 805 "parser.cog"
 

#line 811 "parser.cog"
        AppExpBase createApp(

#line 806 "parser.cog"
                   

#line 806 "parser.cog"
             Parser

#line 806 "parser.cog"
                   * parser, 

#line 807 "parser.cog"
          AppExpBase exp, 

#line 808 "parser.cog"
                 

#line 808 "parser.cog"
         ConstPtr<

#line 808 "parser.cog"
                  Token>  op, 

#line 809 "parser.cog"
              Exp argExp0, 

#line 810 "parser.cog"
              Exp argExp1)
{


#line 813 "parser.cog"
        DEREF(

#line 813 "parser.cog"
     exp).loc = 

#line 813 "parser.cog"
                        

#line 813 "parser.cog"
                 DEREF(

#line 813 "parser.cog"
               op).getLoc();


#line 814 "parser.cog"
        DEREF(

#line 814 "parser.cog"
     exp).base = 

#line 814 "parser.cog"
                             

#line 814 "parser.cog"
                createNameExp(

#line 814 "parser.cog"
                              parser, 

#line 814 "parser.cog"
                                      op);


#line 816 "parser.cog"
     

#line 816 "parser.cog"
     

#line 816 "parser.cog"
                    

#line 816 "parser.cog"
               Array<

#line 816 "parser.cog"
                     Arg>  args;


#line 817 "parser.cog"
                

#line 817 "parser.cog"
                

#line 817 "parser.cog"
         DEREF(

#line 817 "parser.cog"
     args).append(

#line 817 "parser.cog"
                                    

#line 817 "parser.cog"
                 createPositionalArg(

#line 817 "parser.cog"
                                     parser, 

#line 817 "parser.cog"
                                             argExp0));


#line 818 "parser.cog"
                

#line 818 "parser.cog"
                

#line 818 "parser.cog"
         DEREF(

#line 818 "parser.cog"
     args).append(

#line 818 "parser.cog"
                                    

#line 818 "parser.cog"
                 createPositionalArg(

#line 818 "parser.cog"
                                     parser, 

#line 818 "parser.cog"
                                             argExp1));


#line 819 "parser.cog"
        DEREF(

#line 819 "parser.cog"
     exp).args = 

#line 819 "parser.cog"
                args;


#line 820 "parser.cog"
     return 

#line 820 "parser.cog"
            exp;
}


#line 823 "parser.cog"
 

#line 825 "parser.cog"
        Bool isInGenericClause(

#line 824 "parser.cog"
                   

#line 824 "parser.cog"
             Parser

#line 824 "parser.cog"
                   * parser)
{


#line 827 "parser.cog"
     return 

#line 827 "parser.cog"
                                                             

#line 827 "parser.cog"
            (

#line 827 "parser.cog"
                          

#line 827 "parser.cog"
                   DEREF(

#line 827 "parser.cog"
             parser).flags 

#line 827 "parser.cog"
                          & 

#line 827 "parser.cog"
                            kParserFlag_InsideGenericClause) 

#line 827 "parser.cog"
                                                             != 

#line 828 "parser.cog"
   

#line 827 "parser.cog"
                                                                0 

#line 828 "parser.cog"
   || 

#line 828 "parser.cog"
      (

#line 828 "parser.cog"
                           

#line 828 "parser.cog"
             DEREF(

#line 828 "parser.cog"
       parser).genericDepth 

#line 828 "parser.cog"
                           > 

#line 828 "parser.cog"
                             0);
}


#line 831 "parser.cog"
 

#line 833 "parser.cog"
        Exp parsePostfixExp(

#line 832 "parser.cog"
                   

#line 832 "parser.cog"
             Parser

#line 832 "parser.cog"
                   * parser)
{


#line 835 "parser.cog"
     

#line 835 "parser.cog"
     auto exp = 

#line 835 "parser.cog"
                             

#line 835 "parser.cog"
               parseAtomicExp(

#line 835 "parser.cog"
                              parser);


#line 836 "parser.cog"
     {
for(;;)
{
{


#line 838 "parser.cog"
         switch(

#line 838 "parser.cog"
                             

#line 838 "parser.cog"
                peekTokenCode(

#line 838 "parser.cog"
                              parser))
{
case 

#line 840 "parser.cog"
              kTokenCode_PostfixOperator:
{
{


#line 843 "parser.cog"
                 if(

#line 843 "parser.cog"
                                              

#line 843 "parser.cog"
                                     

#line 843 "parser.cog"
                    isInGenericClause(

#line 843 "parser.cog"
                                      parser) 

#line 843 "parser.cog"
                                              && 

#line 843 "parser.cog"
                                                                 

#line 843 "parser.cog"
                                                 peekGenericClose(

#line 843 "parser.cog"
                                                                  parser))
{


#line 844 "parser.cog"
                     return 

#line 844 "parser.cog"
                            exp;
}


#line 846 "parser.cog"
                 

#line 846 "parser.cog"
                 auto op = 

#line 846 "parser.cog"
                                      

#line 846 "parser.cog"
                          advanceToken(

#line 846 "parser.cog"
                                       parser);


#line 847 "parser.cog"
                 exp = 

#line 847 "parser.cog"
                                

#line 847 "parser.cog"
                       createApp(

#line 847 "parser.cog"
                                 parser, 

#line 847 "parser.cog"
                                                                 

#line 847 "parser.cog"
                                                     

#line 847 "parser.cog"
                                         createObject<

#line 847 "parser.cog"
                                                      PostfixExp> (), 

#line 847 "parser.cog"
                                                                     op, 

#line 847 "parser.cog"
                                                                         exp);
}
}
{


#line 849 "parser.cog"
             break;
}
case 

#line 851 "parser.cog"
              kTokenCode_LParen:
{
{


#line 853 "parser.cog"
                 

#line 853 "parser.cog"
                 auto lParen = 

#line 853 "parser.cog"
                                          

#line 853 "parser.cog"
                              advanceToken(

#line 853 "parser.cog"
                                           parser);


#line 854 "parser.cog"
                 

#line 854 "parser.cog"
                 auto args = 

#line 854 "parser.cog"
                                     

#line 854 "parser.cog"
                            parseArgs(

#line 854 "parser.cog"
                                      parser);


#line 855 "parser.cog"
                       

#line 855 "parser.cog"
                       

#line 855 "parser.cog"
                 expect(

#line 855 "parser.cog"
                        parser, 

#line 855 "parser.cog"
                                kTokenCode_RParen);


#line 857 "parser.cog"
                 

#line 857 "parser.cog"
                 auto app = 

#line 857 "parser.cog"
                                               

#line 857 "parser.cog"
                                       

#line 857 "parser.cog"
                           createObject<

#line 857 "parser.cog"
                                        AppExp> ();


#line 858 "parser.cog"
                    DEREF(

#line 858 "parser.cog"
                 app).loc = 

#line 858 "parser.cog"
                                        

#line 858 "parser.cog"
                                 DEREF(

#line 858 "parser.cog"
                           lParen).getLoc();


#line 859 "parser.cog"
                    DEREF(

#line 859 "parser.cog"
                 app).base = 

#line 859 "parser.cog"
                            exp;


#line 860 "parser.cog"
                    DEREF(

#line 860 "parser.cog"
                 app).args = 

#line 860 "parser.cog"
                            args;


#line 861 "parser.cog"
                 exp = 

#line 861 "parser.cog"
                       app;
}
}
{


#line 863 "parser.cog"
             break;
}
case 

#line 865 "parser.cog"
              kTokenCode_LSquare:
{
{


#line 867 "parser.cog"
                 

#line 867 "parser.cog"
                 auto lParen = 

#line 867 "parser.cog"
                                          

#line 867 "parser.cog"
                              advanceToken(

#line 867 "parser.cog"
                                           parser);


#line 868 "parser.cog"
                 

#line 868 "parser.cog"
                 auto args = 

#line 868 "parser.cog"
                                     

#line 868 "parser.cog"
                            parseArgs(

#line 868 "parser.cog"
                                      parser);


#line 869 "parser.cog"
                       

#line 869 "parser.cog"
                       

#line 869 "parser.cog"
                 expect(

#line 869 "parser.cog"
                        parser, 

#line 869 "parser.cog"
                                kTokenCode_RSquare);


#line 871 "parser.cog"
                 

#line 871 "parser.cog"
                 auto app = 

#line 871 "parser.cog"
                                                 

#line 871 "parser.cog"
                                       

#line 871 "parser.cog"
                           createObject<

#line 871 "parser.cog"
                                        IndexExp> ();


#line 872 "parser.cog"
                    DEREF(

#line 872 "parser.cog"
                 app).loc = 

#line 872 "parser.cog"
                                        

#line 872 "parser.cog"
                                 DEREF(

#line 872 "parser.cog"
                           lParen).getLoc();


#line 873 "parser.cog"
                    DEREF(

#line 873 "parser.cog"
                 app).base = 

#line 873 "parser.cog"
                            exp;


#line 874 "parser.cog"
                    DEREF(

#line 874 "parser.cog"
                 app).args = 

#line 874 "parser.cog"
                            args;


#line 875 "parser.cog"
                 exp = 

#line 875 "parser.cog"
                       app;
}
}
{


#line 877 "parser.cog"
             break;
}
case 

#line 879 "parser.cog"
              kTokenCode_Arrow:
{


#line 880 "parser.cog"
                     

#line 880 "parser.cog"
                     

#line 880 "parser.cog"
             diagnose(

#line 880 "parser.cog"
                             

#line 880 "parser.cog"
                      getSink(

#line 880 "parser.cog"
                              parser), 

#line 880 "parser.cog"
                                              

#line 880 "parser.cog"
                                       peekLoc(

#line 880 "parser.cog"
                                               parser), 

#line 880 "parser.cog"
                                                        kDiagnostic_youMeanDot);
}
case 

#line 881 "parser.cog"
              kTokenCode_Dot:
{
{


#line 883 "parser.cog"
                 

#line 883 "parser.cog"
                 auto dot = 

#line 883 "parser.cog"
                                       

#line 883 "parser.cog"
                           advanceToken(

#line 883 "parser.cog"
                                        parser);


#line 884 "parser.cog"
                 

#line 884 "parser.cog"
                 auto memberName = 

#line 884 "parser.cog"
                                                  

#line 884 "parser.cog"
                                  expectIdentifier(

#line 884 "parser.cog"
                                                   parser);


#line 886 "parser.cog"
                 

#line 886 "parser.cog"
                 auto memberExp = 

#line 886 "parser.cog"
                                                        

#line 886 "parser.cog"
                                             

#line 886 "parser.cog"
                                 createObject<

#line 886 "parser.cog"
                                              MemberExp> ();


#line 887 "parser.cog"
                          DEREF(

#line 887 "parser.cog"
                 memberExp).loc = 

#line 887 "parser.cog"
                                           

#line 887 "parser.cog"
                                    DEREF(

#line 887 "parser.cog"
                                 dot).getLoc();


#line 888 "parser.cog"
                          DEREF(

#line 888 "parser.cog"
                 memberExp).base = 

#line 888 "parser.cog"
                                  exp;


#line 889 "parser.cog"
                          DEREF(

#line 889 "parser.cog"
                 memberExp).memberName = 

#line 889 "parser.cog"
                                        memberName;


#line 891 "parser.cog"
                 exp = 

#line 891 "parser.cog"
                                           

#line 891 "parser.cog"
                       maybeParseGenericApp(

#line 891 "parser.cog"
                                            parser, 

#line 891 "parser.cog"
                                                    memberExp);
}
}
{


#line 893 "parser.cog"
             break;
}
default:
{


#line 896 "parser.cog"
             return 

#line 896 "parser.cog"
                    exp;
}
}
}
}}
}


#line 901 "parser.cog"
 

#line 903 "parser.cog"
        Exp parsePrefixExp(

#line 902 "parser.cog"
                   

#line 902 "parser.cog"
             Parser

#line 902 "parser.cog"
                   * parser)
{


#line 905 "parser.cog"
     if(

#line 905 "parser.cog"
                              

#line 905 "parser.cog"
                     

#line 905 "parser.cog"
        peekTokenCode(

#line 905 "parser.cog"
                      parser) 

#line 905 "parser.cog"
                              == 

#line 905 "parser.cog"
                                 kTokenCode_PrefixOperator)
{


#line 907 "parser.cog"
         

#line 907 "parser.cog"
         auto op = 

#line 907 "parser.cog"
                              

#line 907 "parser.cog"
                  advanceToken(

#line 907 "parser.cog"
                               parser);


#line 908 "parser.cog"
         

#line 908 "parser.cog"
         auto arg = 

#line 908 "parser.cog"
                                 

#line 908 "parser.cog"
                   parsePrefixExp(

#line 908 "parser.cog"
                                  parser);


#line 910 "parser.cog"
         return 

#line 910 "parser.cog"
                         

#line 910 "parser.cog"
                createApp(

#line 910 "parser.cog"
                          parser, 

#line 910 "parser.cog"
                                                         

#line 910 "parser.cog"
                                              

#line 910 "parser.cog"
                                  createObject<

#line 910 "parser.cog"
                                               PrefixExp> (), 

#line 910 "parser.cog"
                                                             op, 

#line 910 "parser.cog"
                                                                 arg);
}
else
{


#line 914 "parser.cog"
         return 

#line 914 "parser.cog"
                               

#line 914 "parser.cog"
                parsePostfixExp(

#line 914 "parser.cog"
                                parser);
}
}


#line 918 "parser.cog"
 

#line 920 "parser.cog"
        Exp parseInfixExp(

#line 919 "parser.cog"
                   

#line 919 "parser.cog"
             Parser

#line 919 "parser.cog"
                   * parser)
{


#line 922 "parser.cog"
     

#line 922 "parser.cog"
     auto left = 

#line 922 "parser.cog"
                              

#line 922 "parser.cog"
                parsePrefixExp(

#line 922 "parser.cog"
                               parser);


#line 923 "parser.cog"
     {
for(;;)
{
{


#line 925 "parser.cog"
         switch(

#line 925 "parser.cog"
                             

#line 925 "parser.cog"
                peekTokenCode(

#line 925 "parser.cog"
                              parser))
{
case 

#line 927 "parser.cog"
              kTokenCode_InfixOperator:
{
{


#line 930 "parser.cog"
                 if(

#line 930 "parser.cog"
                                              

#line 930 "parser.cog"
                                     

#line 930 "parser.cog"
                    isInGenericClause(

#line 930 "parser.cog"
                                      parser) 

#line 930 "parser.cog"
                                              && 

#line 930 "parser.cog"
                                                                 

#line 930 "parser.cog"
                                                 peekGenericClose(

#line 930 "parser.cog"
                                                                  parser))
{


#line 931 "parser.cog"
                     return 

#line 931 "parser.cog"
                            left;
}


#line 933 "parser.cog"
                 

#line 933 "parser.cog"
                 auto op = 

#line 933 "parser.cog"
                                      

#line 933 "parser.cog"
                          advanceToken(

#line 933 "parser.cog"
                                       parser);


#line 934 "parser.cog"
                 

#line 934 "parser.cog"
                 auto right = 

#line 934 "parser.cog"
                                          

#line 934 "parser.cog"
                             parseInfixExp(

#line 934 "parser.cog"
                                           parser);


#line 936 "parser.cog"
                 left = 

#line 936 "parser.cog"
                                 

#line 936 "parser.cog"
                        createApp(

#line 936 "parser.cog"
                                  parser, 

#line 936 "parser.cog"
                                                                

#line 936 "parser.cog"
                                                      

#line 936 "parser.cog"
                                          createObject<

#line 936 "parser.cog"
                                                       InfixExp> (), 

#line 936 "parser.cog"
                                                                    op, 

#line 936 "parser.cog"
                                                                        left, 

#line 936 "parser.cog"
                                                                              right);
}
}
{


#line 938 "parser.cog"
             break;
}
case 

#line 940 "parser.cog"
              kTokenCode_Assign:
{
{


#line 944 "parser.cog"
                 

#line 944 "parser.cog"
                 auto op = 

#line 944 "parser.cog"
                                      

#line 944 "parser.cog"
                          advanceToken(

#line 944 "parser.cog"
                                       parser);


#line 946 "parser.cog"
                 

#line 946 "parser.cog"
                 auto assign = 

#line 946 "parser.cog"
                                                     

#line 946 "parser.cog"
                                          

#line 946 "parser.cog"
                              createObject<

#line 946 "parser.cog"
                                           AssignExp> ();


#line 947 "parser.cog"
                       DEREF(

#line 947 "parser.cog"
                 assign).left = 

#line 947 "parser.cog"
                               left;


#line 948 "parser.cog"
                       DEREF(

#line 948 "parser.cog"
                 assign).right = 

#line 948 "parser.cog"
                                             

#line 948 "parser.cog"
                                parseInfixExp(

#line 948 "parser.cog"
                                              parser);


#line 950 "parser.cog"
                 left = 

#line 950 "parser.cog"
                        assign;
}
}
{


#line 952 "parser.cog"
             break;
}
default:
{


#line 955 "parser.cog"
             return 

#line 955 "parser.cog"
                    left;
}
}
}
}}


#line 958 "parser.cog"
     return 

#line 958 "parser.cog"
            left;
}


#line 961 "parser.cog"
 

#line 963 "parser.cog"
        Exp parseExp(

#line 962 "parser.cog"
                   

#line 962 "parser.cog"
             Parser

#line 962 "parser.cog"
                   * parser)
{


#line 965 "parser.cog"
     return 

#line 965 "parser.cog"
                         

#line 965 "parser.cog"
            parseInfixExp(

#line 965 "parser.cog"
                          parser);
}


#line 968 "parser.cog"
 

#line 970 "parser.cog"
        TypeExp parseType(

#line 969 "parser.cog"
                   

#line 969 "parser.cog"
             Parser

#line 969 "parser.cog"
                   * parser)
{


#line 972 "parser.cog"
     

#line 972 "parser.cog"
     auto exp = 

#line 972 "parser.cog"
                              

#line 972 "parser.cog"
               parsePostfixExp(

#line 972 "parser.cog"
                               parser);


#line 974 "parser.cog"
     

#line 974 "parser.cog"
     

#line 974 "parser.cog"
                   TypeExp typeExp;


#line 975 "parser.cog"
            DEREF(

#line 975 "parser.cog"
     typeExp).exp = 

#line 975 "parser.cog"
                   exp;


#line 976 "parser.cog"
     return 

#line 976 "parser.cog"
            typeExp;
}


#line 979 "parser.cog"
 

#line 981 "parser.cog"
        Decl parseDecl(

#line 980 "parser.cog"
                   

#line 980 "parser.cog"
             Parser

#line 980 "parser.cog"
                   * parser)
{


#line 983 "parser.cog"
     

#line 983 "parser.cog"
     

#line 983 "parser.cog"
                     

#line 983 "parser.cog"
                Array<

#line 983 "parser.cog"
                      Attr>  attrs;


#line 985 "parser.cog"
     {
for(;;)
{
{


#line 987 "parser.cog"
         switch(

#line 987 "parser.cog"
                             

#line 987 "parser.cog"
                peekTokenCode(

#line 987 "parser.cog"
                              parser))
{
case 

#line 989 "parser.cog"
              kTokenCode_Identifier:
{
{


#line 991 "parser.cog"
             

#line 991 "parser.cog"
             auto loc = 

#line 991 "parser.cog"
                              

#line 991 "parser.cog"
                       peekLoc(

#line 991 "parser.cog"
                               parser);


#line 994 "parser.cog"
             

#line 994 "parser.cog"
             auto name = 

#line 994 "parser.cog"
                                        

#line 994 "parser.cog"
                        expectIdentifier(

#line 994 "parser.cog"
                                         parser);


#line 995 "parser.cog"
             

#line 995 "parser.cog"
             auto result = 

#line 995 "parser.cog"
                                

#line 995 "parser.cog"
                          lookup(

#line 995 "parser.cog"
                                 parser, 

#line 995 "parser.cog"
                                         name);


#line 997 "parser.cog"
             if(auto syntax = 

#line 997 "parser.cog"
                                          

#line 997 "parser.cog"
                             getSyntaxDecl(

#line 997 "parser.cog"
                                           result))
{


#line 1000 "parser.cog"
                 

#line 1000 "parser.cog"
                 auto syntaxClass = 

#line 1000 "parser.cog"
                                         DEREF(

#line 1000 "parser.cog"
                                   syntax).syntaxClass;


#line 1001 "parser.cog"
                 if(

#line 1001 "parser.cog"
                              

#line 1001 "parser.cog"
                    isSubClass(

#line 1001 "parser.cog"
                               syntaxClass, 

#line 1001 "parser.cog"
                                                          

#line 1001 "parser.cog"
                                                    

#line 1001 "parser.cog"
                                            getClass<

#line 1001 "parser.cog"
                                                     Decl> ()))
{


#line 1004 "parser.cog"
                     

#line 1004 "parser.cog"
                     auto result = 

#line 1004 "parser.cog"
                                                 

#line 1004 "parser.cog"
                                        DEREF(

#line 1004 "parser.cog"
                                  syntax).callback(

#line 1004 "parser.cog"
                                                  parser);


#line 1005 "parser.cog"
                     

#line 1005 "parser.cog"
                     auto resultDecl = 

#line 1005 "parser.cog"
                                              

#line 1005 "parser.cog"
                                        

#line 1005 "parser.cog"
                                      as<

#line 1005 "parser.cog"
                                         Decl> (

#line 1005 "parser.cog"
                                               result);


#line 1008 "parser.cog"
                     if(auto genericDecl = 

#line 1008 "parser.cog"
                                                         

#line 1008 "parser.cog"
                                            

#line 1008 "parser.cog"
                                          as<

#line 1008 "parser.cog"
                                             GenericDecl> (

#line 1008 "parser.cog"
                                                          resultDecl))
{


#line 1011 "parser.cog"
                                          DEREF(

#line 1011 "parser.cog"
                                    DEREF(

#line 1011 "parser.cog"
                         genericDecl).inner).attrs = 

#line 1011 "parser.cog"
                                                   attrs;
}
else
{


#line 1015 "parser.cog"
                                   DEREF(

#line 1015 "parser.cog"
                         resultDecl).attrs = 

#line 1015 "parser.cog"
                                            attrs;
}


#line 1018 "parser.cog"
                               DEREF(

#line 1018 "parser.cog"
                     resultDecl).loc = 

#line 1018 "parser.cog"
                                      loc;


#line 1019 "parser.cog"
                     return 

#line 1019 "parser.cog"
                            resultDecl;
}
else
{


#line 1021 "parser.cog"
                      if(

#line 1021 "parser.cog"
                                   

#line 1021 "parser.cog"
                         isSubClass(

#line 1021 "parser.cog"
                                    syntaxClass, 

#line 1021 "parser.cog"
                                                               

#line 1021 "parser.cog"
                                                         

#line 1021 "parser.cog"
                                                 getClass<

#line 1021 "parser.cog"
                                                          Attr> ()))
{


#line 1023 "parser.cog"
                     

#line 1023 "parser.cog"
                     auto result = 

#line 1023 "parser.cog"
                                                 

#line 1023 "parser.cog"
                                        DEREF(

#line 1023 "parser.cog"
                                  syntax).callback(

#line 1023 "parser.cog"
                                                  parser);


#line 1024 "parser.cog"
                     

#line 1024 "parser.cog"
                     auto resultAttr = 

#line 1024 "parser.cog"
                                              

#line 1024 "parser.cog"
                                        

#line 1024 "parser.cog"
                                      as<

#line 1024 "parser.cog"
                                         Attr> (

#line 1024 "parser.cog"
                                               result);


#line 1025 "parser.cog"
                                 

#line 1025 "parser.cog"
                                 

#line 1025 "parser.cog"
                          DEREF(

#line 1025 "parser.cog"
                     attrs).append(

#line 1025 "parser.cog"
                                  resultAttr);


#line 1028 "parser.cog"
                     continue;
}
}
}
else
{


#line 1038 "parser.cog"
                         

#line 1038 "parser.cog"
                         

#line 1038 "parser.cog"
                 diagnose(

#line 1038 "parser.cog"
                                 

#line 1038 "parser.cog"
                          getSink(

#line 1038 "parser.cog"
                                  parser), 

#line 1038 "parser.cog"
                                                  

#line 1038 "parser.cog"
                                           peekLoc(

#line 1038 "parser.cog"
                                                   parser), 

#line 1038 "parser.cog"
                                                            kDiagnostic_unexpectedDeclName, 

#line 1038 "parser.cog"
                                                                                            name);


#line 1040 "parser.cog"
                          

#line 1040 "parser.cog"
                          

#line 1040 "parser.cog"
                 cogAssert(

#line 1040 "parser.cog"
                           false);


#line 1041 "parser.cog"
                 return 

#line 1041 "parser.cog"
                        0;
}
}
}
{


#line 1044 "parser.cog"
         break;
}
default:
{


#line 1048 "parser.cog"
                       

#line 1048 "parser.cog"
                       

#line 1048 "parser.cog"
             unexpected(

#line 1048 "parser.cog"
                        parser);
}
{


#line 1049 "parser.cog"
             return 

#line 1049 "parser.cog"
                    0;
}
}
}
}}
}


#line 1054 "parser.cog"
 

#line 1058 "parser.cog"
        ModuleDecl findOrImportModule(

#line 1055 "parser.cog"
              Session session, 

#line 1056 "parser.cog"
          SourceLoc loc, 

#line 1057 "parser.cog"
               

#line 1057 "parser.cog"
           Name

#line 1057 "parser.cog"
               * name)
{


#line 1062 "parser.cog"
     for(auto mm : 

#line 1062 "parser.cog"
                          DEREF(

#line 1062 "parser.cog"
                   session).loadedModules)
{
{


#line 1064 "parser.cog"
         if(

#line 1064 "parser.cog"
                    

#line 1064 "parser.cog"
              DEREF(

#line 1064 "parser.cog"
            mm).name 

#line 1064 "parser.cog"
                    == 

#line 1064 "parser.cog"
                       name)
{


#line 1066 "parser.cog"
             return 

#line 1066 "parser.cog"
                    mm;
}
}
}


#line 1072 "parser.cog"
     

#line 1072 "parser.cog"
     auto nameText = 

#line 1072 "parser.cog"
                           

#line 1072 "parser.cog"
                    getText(

#line 1072 "parser.cog"
                            name);


#line 1074 "parser.cog"
     

#line 1074 "parser.cog"
     

#line 1074 "parser.cog"
                              

#line 1074 "parser.cog"
                FixedSizeArray<

#line 1074 "parser.cog"
                               1024, 

#line 1074 "parser.cog"
                                     Char>  path;


#line 1075 "parser.cog"
            

#line 1075 "parser.cog"
            

#line 1075 "parser.cog"
     sprintf(

#line 1075 "parser.cog"
             path, 

#line 1075 "parser.cog"
                   "../../source/%.*s/%.*s.cog", 

#line 1076 "parser.cog"
              

#line 1076 "parser.cog"
         (

#line 1076 "parser.cog"
          int)(

#line 1076 "parser.cog"
                            

#line 1076 "parser.cog"
                       DEREF(

#line 1076 "parser.cog"
               nameText).end 

#line 1076 "parser.cog"
                            - 

#line 1076 "parser.cog"
                                      DEREF(

#line 1076 "parser.cog"
                              nameText).begin), 

#line 1077 "parser.cog"
                 DEREF(

#line 1077 "parser.cog"
         nameText).begin, 

#line 1078 "parser.cog"
              

#line 1078 "parser.cog"
         (

#line 1078 "parser.cog"
          int)(

#line 1078 "parser.cog"
                            

#line 1078 "parser.cog"
                       DEREF(

#line 1078 "parser.cog"
               nameText).end 

#line 1078 "parser.cog"
                            - 

#line 1078 "parser.cog"
                                      DEREF(

#line 1078 "parser.cog"
                              nameText).begin), 

#line 1079 "parser.cog"
                 DEREF(

#line 1079 "parser.cog"
         nameText).begin);


#line 1081 "parser.cog"
     

#line 1081 "parser.cog"
     

#line 1081 "parser.cog"
                         

#line 1081 "parser.cog"
               SourceFile

#line 1081 "parser.cog"
                         * file = 

#line 1081 "parser.cog"
                                          

#line 1081 "parser.cog"
                             getSourceFile(

#line 1081 "parser.cog"
                                           session, 

#line 1081 "parser.cog"
                                                                        

#line 1081 "parser.cog"
                                                    TerminatedStringSpan(

#line 1081 "parser.cog"
                                                                         path));


#line 1082 "parser.cog"
     if(

#line 1082 "parser.cog"
        

#line 1082 "parser.cog"
        !

#line 1082 "parser.cog"
         file)
{


#line 1084 "parser.cog"
                

#line 1084 "parser.cog"
                

#line 1084 "parser.cog"
         sprintf(

#line 1084 "parser.cog"
                 path, 

#line 1084 "parser.cog"
                       "source/%.*s/%.*s.cog", 

#line 1085 "parser.cog"
         

#line 1085 "parser.cog"
    (

#line 1085 "parser.cog"
     int)(

#line 1085 "parser.cog"
                       

#line 1085 "parser.cog"
                  DEREF(

#line 1085 "parser.cog"
          nameText).end 

#line 1085 "parser.cog"
                       - 

#line 1085 "parser.cog"
                                 DEREF(

#line 1085 "parser.cog"
                         nameText).begin), 

#line 1086 "parser.cog"
            DEREF(

#line 1086 "parser.cog"
    nameText).begin, 

#line 1087 "parser.cog"
         

#line 1087 "parser.cog"
    (

#line 1087 "parser.cog"
     int)(

#line 1087 "parser.cog"
                       

#line 1087 "parser.cog"
                  DEREF(

#line 1087 "parser.cog"
          nameText).end 

#line 1087 "parser.cog"
                       - 

#line 1087 "parser.cog"
                                 DEREF(

#line 1087 "parser.cog"
                         nameText).begin), 

#line 1088 "parser.cog"
            DEREF(

#line 1088 "parser.cog"
    nameText).begin);


#line 1089 "parser.cog"
         file = 

#line 1089 "parser.cog"
                             

#line 1089 "parser.cog"
                getSourceFile(

#line 1089 "parser.cog"
                              session, 

#line 1089 "parser.cog"
                                                           

#line 1089 "parser.cog"
                                       TerminatedStringSpan(

#line 1089 "parser.cog"
                                                            path));
}


#line 1091 "parser.cog"
     if(

#line 1091 "parser.cog"
        

#line 1091 "parser.cog"
        !

#line 1091 "parser.cog"
         file)
{


#line 1093 "parser.cog"
                

#line 1093 "parser.cog"
                

#line 1093 "parser.cog"
         sprintf(

#line 1093 "parser.cog"
                 path, 

#line 1093 "parser.cog"
                       "../../source/thetalib/%.*s.cog", 

#line 1093 "parser.cog"
                                                              

#line 1093 "parser.cog"
                                                         (

#line 1093 "parser.cog"
                                                          int)(

#line 1093 "parser.cog"
                                                                            

#line 1093 "parser.cog"
                                                                       DEREF(

#line 1093 "parser.cog"
                                                               nameText).end 

#line 1093 "parser.cog"
                                                                            - 

#line 1093 "parser.cog"
                                                                                      DEREF(

#line 1093 "parser.cog"
                                                                              nameText).begin), 

#line 1093 "parser.cog"
                                                                                                       DEREF(

#line 1093 "parser.cog"
                                                                                               nameText).begin);


#line 1094 "parser.cog"
         file = 

#line 1094 "parser.cog"
                             

#line 1094 "parser.cog"
                getSourceFile(

#line 1094 "parser.cog"
                              session, 

#line 1094 "parser.cog"
                                                           

#line 1094 "parser.cog"
                                       TerminatedStringSpan(

#line 1094 "parser.cog"
                                                            path));
}


#line 1096 "parser.cog"
     if(

#line 1096 "parser.cog"
        

#line 1096 "parser.cog"
        !

#line 1096 "parser.cog"
         file)
{


#line 1098 "parser.cog"
                

#line 1098 "parser.cog"
                

#line 1098 "parser.cog"
         sprintf(

#line 1098 "parser.cog"
                 path, 

#line 1098 "parser.cog"
                       "source/thetalib/%.*s.cog", 

#line 1098 "parser.cog"
                                                        

#line 1098 "parser.cog"
                                                   (

#line 1098 "parser.cog"
                                                    int)(

#line 1098 "parser.cog"
                                                                      

#line 1098 "parser.cog"
                                                                 DEREF(

#line 1098 "parser.cog"
                                                         nameText).end 

#line 1098 "parser.cog"
                                                                      - 

#line 1098 "parser.cog"
                                                                                DEREF(

#line 1098 "parser.cog"
                                                                        nameText).begin), 

#line 1098 "parser.cog"
                                                                                                 DEREF(

#line 1098 "parser.cog"
                                                                                         nameText).begin);


#line 1099 "parser.cog"
         file = 

#line 1099 "parser.cog"
                             

#line 1099 "parser.cog"
                getSourceFile(

#line 1099 "parser.cog"
                              session, 

#line 1099 "parser.cog"
                                                           

#line 1099 "parser.cog"
                                       TerminatedStringSpan(

#line 1099 "parser.cog"
                                                            path));
}


#line 1101 "parser.cog"
     if(

#line 1101 "parser.cog"
        

#line 1101 "parser.cog"
        !

#line 1101 "parser.cog"
         file)
{


#line 1103 "parser.cog"
              

#line 1103 "parser.cog"
              

#line 1103 "parser.cog"
     cogAssert(

#line 1103 "parser.cog"
               

#line 1103 "parser.cog"
               !

#line 1103 "parser.cog"
                "unimplemented");
}


#line 1107 "parser.cog"
     

#line 1107 "parser.cog"
     auto moduleDecl = 

#line 1107 "parser.cog"
                                              

#line 1107 "parser.cog"
                                  

#line 1107 "parser.cog"
                      createObject<

#line 1107 "parser.cog"
                                   ModuleDecl> ();


#line 1108 "parser.cog"
               DEREF(

#line 1108 "parser.cog"
     moduleDecl).name = 

#line 1108 "parser.cog"
                       name;


#line 1110 "parser.cog"
                        

#line 1110 "parser.cog"
                        

#line 1110 "parser.cog"
     parseFileIntoModule(

#line 1110 "parser.cog"
                         session, 

#line 1110 "parser.cog"
                                  file, 

#line 1110 "parser.cog"
                                        moduleDecl);


#line 1116 "parser.cog"
                              

#line 1116 "parser.cog"
                              

#line 1116 "parser.cog"
                       DEREF(

#line 1116 "parser.cog"
         DEREF(

#line 1116 "parser.cog"
  session).loadedModules).append(

#line 1116 "parser.cog"
                               moduleDecl);


#line 1119 "parser.cog"
                

#line 1119 "parser.cog"
                

#line 1119 "parser.cog"
     checkModule(

#line 1119 "parser.cog"
                 session, 

#line 1119 "parser.cog"
                          moduleDecl);


#line 1121 "parser.cog"
     return 

#line 1121 "parser.cog"
            moduleDecl;
}


#line 1124 "parser.cog"
 

#line 1126 "parser.cog"
             

#line 1126 "parser.cog"
        Array<

#line 1126 "parser.cog"
              Decl>  parseDeclsInBody(

#line 1125 "parser.cog"
                   

#line 1125 "parser.cog"
             Parser

#line 1125 "parser.cog"
                   * parser)
{


#line 1128 "parser.cog"
     

#line 1128 "parser.cog"
     auto savedScope = 

#line 1128 "parser.cog"
                            DEREF(

#line 1128 "parser.cog"
                      parser).scope;


#line 1130 "parser.cog"
     

#line 1130 "parser.cog"
     

#line 1130 "parser.cog"
                     

#line 1130 "parser.cog"
                Array<

#line 1130 "parser.cog"
                      Decl>  decls;


#line 1131 "parser.cog"
     while(

#line 1131 "parser.cog"
           

#line 1131 "parser.cog"
           !

#line 1131 "parser.cog"
                   

#line 1131 "parser.cog"
            isAtEnd(

#line 1131 "parser.cog"
                    parser))
{
{


#line 1133 "parser.cog"
         switch(

#line 1133 "parser.cog"
                             

#line 1133 "parser.cog"
                peekTokenCode(

#line 1133 "parser.cog"
                              parser))
{
case 

#line 1135 "parser.cog"
              kTokenCode_RParen:
case 

#line 1136 "parser.cog"
              kTokenCode_RCurly:
case 

#line 1137 "parser.cog"
              kTokenCode_EndOfFile:
{


#line 1138 "parser.cog"
             return 

#line 1138 "parser.cog"
                    decls;
}
default:
{


#line 1141 "parser.cog"
             break;
}
}


#line 1144 "parser.cog"
         

#line 1144 "parser.cog"
         auto decl = 

#line 1144 "parser.cog"
                             

#line 1144 "parser.cog"
                    parseDecl(

#line 1144 "parser.cog"
                              parser);


#line 1145 "parser.cog"
         if(

#line 1145 "parser.cog"
            decl)
{


#line 1147 "parser.cog"
                 DEREF(

#line 1147 "parser.cog"
             decl).parent = 

#line 1147 "parser.cog"
                                                  DEREF(

#line 1147 "parser.cog"
                                       DEREF(

#line 1147 "parser.cog"
                                 DEREF(

#line 1147 "parser.cog"
                           parser).scope).directLink).container;


#line 1148 "parser.cog"
                         

#line 1148 "parser.cog"
                         

#line 1148 "parser.cog"
                  DEREF(

#line 1148 "parser.cog"
             decls).append(

#line 1148 "parser.cog"
                          decl);
}


#line 1152 "parser.cog"
                     

#line 1152 "parser.cog"
                     

#line 1152 "parser.cog"
         restoreScope(

#line 1152 "parser.cog"
                      parser, 

#line 1152 "parser.cog"
                              savedScope);


#line 1154 "parser.cog"
                   

#line 1154 "parser.cog"
                   

#line 1154 "parser.cog"
         tryRecover(

#line 1154 "parser.cog"
                    parser);
}
}


#line 1156 "parser.cog"
     return 

#line 1156 "parser.cog"
            decls;
}


#line 1159 "parser.cog"
 

#line 1161 "parser.cog"
             

#line 1161 "parser.cog"
        Array<

#line 1161 "parser.cog"
              Decl>  parseDeclBody(

#line 1160 "parser.cog"
                   

#line 1160 "parser.cog"
             Parser

#line 1160 "parser.cog"
                   * parser)
{


#line 1163 "parser.cog"
           

#line 1163 "parser.cog"
           

#line 1163 "parser.cog"
     expect(

#line 1163 "parser.cog"
            parser, 

#line 1163 "parser.cog"
                    kTokenCode_LCurly);


#line 1164 "parser.cog"
     

#line 1164 "parser.cog"
     auto decls = 

#line 1164 "parser.cog"
                                 

#line 1164 "parser.cog"
                 parseDeclsInBody(

#line 1164 "parser.cog"
                                  parser);


#line 1165 "parser.cog"
           

#line 1165 "parser.cog"
           

#line 1165 "parser.cog"
     expect(

#line 1165 "parser.cog"
            parser, 

#line 1165 "parser.cog"
                    kTokenCode_RCurly);


#line 1166 "parser.cog"
     return 

#line 1166 "parser.cog"
            decls;
}


#line 1169 "parser.cog"
 void parseDeclBody(

#line 1170 "parser.cog"
                   

#line 1170 "parser.cog"
             Parser

#line 1170 "parser.cog"
                   * parser, 

#line 1171 "parser.cog"
           ContainerDecl decl)
{


#line 1173 "parser.cog"
              

#line 1173 "parser.cog"
              

#line 1173 "parser.cog"
     pushScope(

#line 1173 "parser.cog"
               parser, 

#line 1173 "parser.cog"
                       decl);


#line 1174 "parser.cog"
                  

#line 1174 "parser.cog"
         DEREF(

#line 1174 "parser.cog"
     decl).getDecls() = 

#line 1174 "parser.cog"
                                    

#line 1174 "parser.cog"
                       parseDeclBody(

#line 1174 "parser.cog"
                                     parser);


#line 1176 "parser.cog"
     for(auto dd : 

#line 1176 "parser.cog"
                                

#line 1176 "parser.cog"
                       DEREF(

#line 1176 "parser.cog"
                   decl).getDecls())
{
{


#line 1178 "parser.cog"
           DEREF(

#line 1178 "parser.cog"
         dd).parent = 

#line 1178 "parser.cog"
                     decl;
}
}


#line 1181 "parser.cog"
             

#line 1181 "parser.cog"
             

#line 1181 "parser.cog"
     popScope(

#line 1181 "parser.cog"
              parser);
}


#line 1184 "parser.cog"
 

#line 1186 "parser.cog"
        Stmt parseExpStmt(

#line 1185 "parser.cog"
                   

#line 1185 "parser.cog"
             Parser

#line 1185 "parser.cog"
                   * parser)
{


#line 1188 "parser.cog"
     

#line 1188 "parser.cog"
     auto exp = 

#line 1188 "parser.cog"
                       

#line 1188 "parser.cog"
               parseExp(

#line 1188 "parser.cog"
                        parser);


#line 1189 "parser.cog"
           

#line 1189 "parser.cog"
           

#line 1189 "parser.cog"
     expect(

#line 1189 "parser.cog"
            parser, 

#line 1189 "parser.cog"
                    kTokenCode_Semi);


#line 1190 "parser.cog"
     return 

#line 1190 "parser.cog"
            exp;
}


#line 1193 "parser.cog"
 

#line 1195 "parser.cog"
        Stmt parseStmt(

#line 1194 "parser.cog"
                   

#line 1194 "parser.cog"
             Parser

#line 1194 "parser.cog"
                   * parser)
{


#line 1197 "parser.cog"
     switch(

#line 1197 "parser.cog"
                         

#line 1197 "parser.cog"
            peekTokenCode(

#line 1197 "parser.cog"
                          parser))
{
case 

#line 1199 "parser.cog"
          kTokenCode_Identifier:
{
{


#line 1202 "parser.cog"
             

#line 1202 "parser.cog"
             auto loc = 

#line 1202 "parser.cog"
                              

#line 1202 "parser.cog"
                       peekLoc(

#line 1202 "parser.cog"
                               parser);


#line 1203 "parser.cog"
             

#line 1203 "parser.cog"
             auto name = 

#line 1203 "parser.cog"
                        cast<

#line 1203 "parser.cog"
                                

#line 1203 "parser.cog"
                             Ptr<

#line 1203 "parser.cog"
                                 Name> >(

#line 1203 "parser.cog"
                                                     DEREF(

#line 1203 "parser.cog"
                                               DEREF(

#line 1203 "parser.cog"
                                         parser).token).rawData);


#line 1204 "parser.cog"
             

#line 1204 "parser.cog"
             auto result = 

#line 1204 "parser.cog"
                                

#line 1204 "parser.cog"
                          lookup(

#line 1204 "parser.cog"
                                 parser, 

#line 1204 "parser.cog"
                                         name);


#line 1206 "parser.cog"
             if(auto syntax = 

#line 1206 "parser.cog"
                                          

#line 1206 "parser.cog"
                             getSyntaxDecl(

#line 1206 "parser.cog"
                                           result))
{


#line 1208 "parser.cog"
                 if(

#line 1208 "parser.cog"
                              

#line 1208 "parser.cog"
                    isSubClass(

#line 1208 "parser.cog"
                                     DEREF(

#line 1208 "parser.cog"
                               syntax).syntaxClass, 

#line 1208 "parser.cog"
                                                                

#line 1208 "parser.cog"
                                                           

#line 1208 "parser.cog"
                                                   getClass<

#line 1208 "parser.cog"
                                                            Exp> ()))
{
}
else
{


#line 1212 "parser.cog"
                      if(

#line 1212 "parser.cog"
                                   

#line 1212 "parser.cog"
                         isSubClass(

#line 1212 "parser.cog"
                                          DEREF(

#line 1212 "parser.cog"
                                    syntax).syntaxClass, 

#line 1212 "parser.cog"
                                                                      

#line 1212 "parser.cog"
                                                                

#line 1212 "parser.cog"
                                                        getClass<

#line 1212 "parser.cog"
                                                                 Stmt> ()))
{


#line 1214 "parser.cog"
                                 

#line 1214 "parser.cog"
                                 

#line 1214 "parser.cog"
                     advanceToken(

#line 1214 "parser.cog"
                                  parser);


#line 1221 "parser.cog"
                     

#line 1221 "parser.cog"
                     auto result = 

#line 1221 "parser.cog"
                                                 

#line 1221 "parser.cog"
                                        DEREF(

#line 1221 "parser.cog"
                                  syntax).callback(

#line 1221 "parser.cog"
                                                  parser);


#line 1222 "parser.cog"
                     

#line 1222 "parser.cog"
                     auto resultStmt = 

#line 1222 "parser.cog"
                                              

#line 1222 "parser.cog"
                                        

#line 1222 "parser.cog"
                                      as<

#line 1222 "parser.cog"
                                         Stmt> (

#line 1222 "parser.cog"
                                               result);


#line 1226 "parser.cog"
                               DEREF(

#line 1226 "parser.cog"
                     resultStmt).loc = 

#line 1226 "parser.cog"
                                      loc;


#line 1228 "parser.cog"
                     return 

#line 1228 "parser.cog"
                            resultStmt;
}
}
}


#line 1233 "parser.cog"
             return 

#line 1233 "parser.cog"
                                

#line 1233 "parser.cog"
                    parseExpStmt(

#line 1233 "parser.cog"
                                 parser);
}
}
{


#line 1235 "parser.cog"
         break;
}
case 

#line 1237 "parser.cog"
          kTokenCode_LCurly:
{


#line 1238 "parser.cog"
         return 

#line 1238 "parser.cog"
                             

#line 1238 "parser.cog"
                parseStmtBody(

#line 1238 "parser.cog"
                              parser);
}
case 

#line 1240 "parser.cog"
          kTokenCode_PrefixOperator:
{


#line 1241 "parser.cog"
         return 

#line 1241 "parser.cog"
                            

#line 1241 "parser.cog"
                parseExpStmt(

#line 1241 "parser.cog"
                             parser);
}
default:
{


#line 1245 "parser.cog"
                   

#line 1245 "parser.cog"
                   

#line 1245 "parser.cog"
         unexpected(

#line 1245 "parser.cog"
                    parser);
}
{


#line 1246 "parser.cog"
         return 

#line 1246 "parser.cog"
                0;
}
}
}


#line 1250 "parser.cog"
 

#line 1252 "parser.cog"
             

#line 1252 "parser.cog"
        Array<

#line 1252 "parser.cog"
              Stmt>  parseStmtsInBody(

#line 1251 "parser.cog"
                   

#line 1251 "parser.cog"
             Parser

#line 1251 "parser.cog"
                   * parser)
{


#line 1254 "parser.cog"
     

#line 1254 "parser.cog"
     

#line 1254 "parser.cog"
                     

#line 1254 "parser.cog"
                Array<

#line 1254 "parser.cog"
                      Stmt>  stmts;


#line 1255 "parser.cog"
     while(

#line 1255 "parser.cog"
           

#line 1255 "parser.cog"
           !

#line 1255 "parser.cog"
                   

#line 1255 "parser.cog"
            isAtEnd(

#line 1255 "parser.cog"
                    parser))
{
{


#line 1257 "parser.cog"
         switch(

#line 1257 "parser.cog"
                             

#line 1257 "parser.cog"
                peekTokenCode(

#line 1257 "parser.cog"
                              parser))
{
case 

#line 1259 "parser.cog"
              kTokenCode_RParen:
case 

#line 1260 "parser.cog"
              kTokenCode_RCurly:
case 

#line 1261 "parser.cog"
              kTokenCode_EndOfFile:
{


#line 1262 "parser.cog"
             return 

#line 1262 "parser.cog"
                    stmts;
}
default:
{


#line 1265 "parser.cog"
             break;
}
}


#line 1268 "parser.cog"
         

#line 1268 "parser.cog"
         auto stmt = 

#line 1268 "parser.cog"
                             

#line 1268 "parser.cog"
                    parseStmt(

#line 1268 "parser.cog"
                              parser);


#line 1269 "parser.cog"
         if(

#line 1269 "parser.cog"
            stmt)
{


#line 1271 "parser.cog"
                         

#line 1271 "parser.cog"
                         

#line 1271 "parser.cog"
                  DEREF(

#line 1271 "parser.cog"
             stmts).append(

#line 1271 "parser.cog"
                          stmt);
}


#line 1274 "parser.cog"
                   

#line 1274 "parser.cog"
                   

#line 1274 "parser.cog"
         tryRecover(

#line 1274 "parser.cog"
                    parser);
}
}


#line 1276 "parser.cog"
     return 

#line 1276 "parser.cog"
            stmts;
}


#line 1279 "parser.cog"
 

#line 1281 "parser.cog"
        Stmt parseStmtBody(

#line 1280 "parser.cog"
                   

#line 1280 "parser.cog"
             Parser

#line 1280 "parser.cog"
                   * parser)
{


#line 1283 "parser.cog"
     

#line 1283 "parser.cog"
     auto stmt = 

#line 1283 "parser.cog"
                                       

#line 1283 "parser.cog"
                            

#line 1283 "parser.cog"
                createObject<

#line 1283 "parser.cog"
                             BlockStmt> ();


#line 1285 "parser.cog"
              

#line 1285 "parser.cog"
              

#line 1285 "parser.cog"
     pushScope(

#line 1285 "parser.cog"
               parser, 

#line 1285 "parser.cog"
                       stmt);


#line 1286 "parser.cog"
           

#line 1286 "parser.cog"
           

#line 1286 "parser.cog"
     expect(

#line 1286 "parser.cog"
            parser, 

#line 1286 "parser.cog"
                    kTokenCode_LCurly);


#line 1287 "parser.cog"
     

#line 1287 "parser.cog"
     auto stmts = 

#line 1287 "parser.cog"
                                 

#line 1287 "parser.cog"
                 parseStmtsInBody(

#line 1287 "parser.cog"
                                  parser);


#line 1288 "parser.cog"
           

#line 1288 "parser.cog"
           

#line 1288 "parser.cog"
     expect(

#line 1288 "parser.cog"
            parser, 

#line 1288 "parser.cog"
                    kTokenCode_RCurly);


#line 1289 "parser.cog"
             

#line 1289 "parser.cog"
             

#line 1289 "parser.cog"
     popScope(

#line 1289 "parser.cog"
              parser);


#line 1291 "parser.cog"
         DEREF(

#line 1291 "parser.cog"
     stmt).stmts = 

#line 1291 "parser.cog"
                  stmts;


#line 1293 "parser.cog"
     return 

#line 1293 "parser.cog"
            stmt;
}


#line 1296 "parser.cog"
 

#line 1296 "parser.cog"
                                           Bool peekGenericClose(

#line 1296 "parser.cog"
                                     

#line 1296 "parser.cog"
                               Parser

#line 1296 "parser.cog"
                                     * parser)
{


#line 1298 "parser.cog"
     switch(

#line 1298 "parser.cog"
                         

#line 1298 "parser.cog"
            peekTokenCode(

#line 1298 "parser.cog"
                          parser))
{
default:
{


#line 1302 "parser.cog"
         return 

#line 1302 "parser.cog"
                false;
}
case 

#line 1304 "parser.cog"
          kTokenCode_InfixOperator:
case 

#line 1305 "parser.cog"
          kTokenCode_PrefixOperator:
case 

#line 1306 "parser.cog"
          kTokenCode_PostfixOperator:
{


#line 1307 "parser.cog"
         break;
}
}


#line 1310 "parser.cog"
     

#line 1310 "parser.cog"
     auto name = 

#line 1310 "parser.cog"
                cast<

#line 1310 "parser.cog"
                        

#line 1310 "parser.cog"
                     Ptr<

#line 1310 "parser.cog"
                         Name> >(

#line 1310 "parser.cog"
                                              DEREF(

#line 1310 "parser.cog"
                                        DEREF(

#line 1310 "parser.cog"
                                  parser).token).rawData);


#line 1311 "parser.cog"
     

#line 1311 "parser.cog"
     auto nameText = 

#line 1311 "parser.cog"
                           

#line 1311 "parser.cog"
                    getText(

#line 1311 "parser.cog"
                            name);


#line 1314 "parser.cog"
     if(

#line 1314 "parser.cog"
                 

#line 1314 "parser.cog"
        nameText 

#line 1314 "parser.cog"
                 != 

#line 1314 "parser.cog"
                                        

#line 1314 "parser.cog"
                    TerminatedStringSpan(

#line 1314 "parser.cog"
                                         ">"))
{


#line 1315 "parser.cog"
         return 

#line 1315 "parser.cog"
                false;
}


#line 1317 "parser.cog"
     return 

#line 1317 "parser.cog"
            true;
}


#line 1320 "parser.cog"
 

#line 1320 "parser.cog"
                                               Bool tryParseGenericClose(

#line 1320 "parser.cog"
                                         

#line 1320 "parser.cog"
                                   Parser

#line 1320 "parser.cog"
                                         * parser)
{


#line 1322 "parser.cog"
     if(

#line 1322 "parser.cog"
        

#line 1322 "parser.cog"
        !

#line 1322 "parser.cog"
                         

#line 1322 "parser.cog"
         peekGenericClose(

#line 1322 "parser.cog"
                          parser))
{


#line 1323 "parser.cog"
         return 

#line 1323 "parser.cog"
                false;
}


#line 1326 "parser.cog"
                 

#line 1326 "parser.cog"
                 

#line 1326 "parser.cog"
     advanceToken(

#line 1326 "parser.cog"
                  parser);


#line 1327 "parser.cog"
     return 

#line 1327 "parser.cog"
            true;
}


#line 1330 "parser.cog"
 void expectGenericClose(

#line 1330 "parser.cog"
                                       

#line 1330 "parser.cog"
                                 Parser

#line 1330 "parser.cog"
                                       * parser)
{


#line 1332 "parser.cog"
     if(

#line 1332 "parser.cog"
        

#line 1332 "parser.cog"
        !

#line 1332 "parser.cog"
                             

#line 1332 "parser.cog"
         tryParseGenericClose(

#line 1332 "parser.cog"
                              parser))
{


#line 1335 "parser.cog"
                   

#line 1335 "parser.cog"
                   

#line 1335 "parser.cog"
         unexpected(

#line 1335 "parser.cog"
                    parser);
}
}


#line 1339 "parser.cog"
 

#line 1339 "parser.cog"
                                            Decl parseGenericParam(

#line 1339 "parser.cog"
                                      

#line 1339 "parser.cog"
                                Parser

#line 1339 "parser.cog"
                                      * parser)
{


#line 1341 "parser.cog"
  if(

#line 1341 "parser.cog"
                           

#line 1341 "parser.cog"
                  

#line 1341 "parser.cog"
     peekTokenCode(

#line 1341 "parser.cog"
                   parser) 

#line 1341 "parser.cog"
                           != 

#line 1341 "parser.cog"
                              kTokenCode_Identifier)
{


#line 1342 "parser.cog"
   return 

#line 1342 "parser.cog"
          nullptr;
}


#line 1344 "parser.cog"
     

#line 1344 "parser.cog"
     auto loc = 

#line 1344 "parser.cog"
                      

#line 1344 "parser.cog"
               peekLoc(

#line 1344 "parser.cog"
                       parser);


#line 1345 "parser.cog"
     

#line 1345 "parser.cog"
     auto name = 

#line 1345 "parser.cog"
                                

#line 1345 "parser.cog"
                expectIdentifier(

#line 1345 "parser.cog"
                                 parser);


#line 1347 "parser.cog"
     

#line 1347 "parser.cog"
     auto decl = 

#line 1347 "parser.cog"
                                              

#line 1347 "parser.cog"
                            

#line 1347 "parser.cog"
                createObject<

#line 1347 "parser.cog"
                             GenericParamDecl> ();


#line 1348 "parser.cog"
         DEREF(

#line 1348 "parser.cog"
     decl).loc = 

#line 1348 "parser.cog"
                loc;


#line 1349 "parser.cog"
         DEREF(

#line 1349 "parser.cog"
     decl).name = 

#line 1349 "parser.cog"
                 name;


#line 1352 "parser.cog"
  if(

#line 1352 "parser.cog"
              

#line 1352 "parser.cog"
     advanceIf(

#line 1352 "parser.cog"
               parser, 

#line 1352 "parser.cog"
                       kTokenCode_Colon))
{


#line 1354 "parser.cog"
       DEREF(

#line 1354 "parser.cog"
   decl).bound = 

#line 1354 "parser.cog"
                         

#line 1354 "parser.cog"
                parseType(

#line 1354 "parser.cog"
                          parser);
}


#line 1357 "parser.cog"
     return 

#line 1357 "parser.cog"
            decl;
}


#line 1360 "parser.cog"
 void parseGenericParams(

#line 1360 "parser.cog"
                                       

#line 1360 "parser.cog"
                                 Parser

#line 1360 "parser.cog"
                                       * parser, 

#line 1360 "parser.cog"
                                                      

#line 1360 "parser.cog"
                                                   Ptr<

#line 1360 "parser.cog"
                                                            

#line 1360 "parser.cog"
                                                       Array<

#line 1360 "parser.cog"
                                                             Decl> >  ioDecls)
{


#line 1363 "parser.cog"
     

#line 1363 "parser.cog"
     

#line 1363 "parser.cog"
                         

#line 1363 "parser.cog"
                 ConstRef<

#line 1363 "parser.cog"
                               

#line 1363 "parser.cog"
                          Array<

#line 1363 "parser.cog"
                                Decl> >  decls = 

#line 1363 "parser.cog"
                                          

#line 1363 "parser.cog"
                                          *

#line 1363 "parser.cog"
                                           ioDecls;


#line 1365 "parser.cog"
     if(

#line 1365 "parser.cog"
                        

#line 1365 "parser.cog"
        peekGenericClose(

#line 1365 "parser.cog"
                         parser))
{


#line 1366 "parser.cog"
         return;
}


#line 1368 "parser.cog"
     {
for(;;)
{
{


#line 1370 "parser.cog"
         

#line 1370 "parser.cog"
         auto decl = 

#line 1370 "parser.cog"
                                     

#line 1370 "parser.cog"
                    parseGenericParam(

#line 1370 "parser.cog"
                                      parser);


#line 1371 "parser.cog"
         if(

#line 1371 "parser.cog"
            decl)
{


#line 1373 "parser.cog"
                         

#line 1373 "parser.cog"
                         

#line 1373 "parser.cog"
                  DEREF(

#line 1373 "parser.cog"
             decls).append(

#line 1373 "parser.cog"
                          decl);
}
else
{


#line 1377 "parser.cog"
    break;
}


#line 1380 "parser.cog"
         if(

#line 1380 "parser.cog"
                            

#line 1380 "parser.cog"
            peekGenericClose(

#line 1380 "parser.cog"
                             parser))
{


#line 1381 "parser.cog"
             return;
}


#line 1383 "parser.cog"
               

#line 1383 "parser.cog"
               

#line 1383 "parser.cog"
         expect(

#line 1383 "parser.cog"
                parser, 

#line 1383 "parser.cog"
                        kTokenCode_Comma);
}
}}
}


#line 1387 "parser.cog"
 

#line 1387 "parser.cog"
                                              Bool tryParseGenericOpen(

#line 1387 "parser.cog"
                                        

#line 1387 "parser.cog"
                                  Parser

#line 1387 "parser.cog"
                                        * parser)
{


#line 1389 "parser.cog"
     switch(

#line 1389 "parser.cog"
                         

#line 1389 "parser.cog"
            peekTokenCode(

#line 1389 "parser.cog"
                          parser))
{
default:
{


#line 1394 "parser.cog"
         return 

#line 1394 "parser.cog"
                false;
}
case 

#line 1396 "parser.cog"
          kTokenCode_InfixOperator:
case 

#line 1397 "parser.cog"
          kTokenCode_PrefixOperator:
case 

#line 1398 "parser.cog"
          kTokenCode_PostfixOperator:
{


#line 1399 "parser.cog"
         break;
}
}


#line 1402 "parser.cog"
     

#line 1402 "parser.cog"
     auto name = 

#line 1402 "parser.cog"
                cast<

#line 1402 "parser.cog"
                        

#line 1402 "parser.cog"
                     Ptr<

#line 1402 "parser.cog"
                         Name> >(

#line 1402 "parser.cog"
                                             DEREF(

#line 1402 "parser.cog"
                                       DEREF(

#line 1402 "parser.cog"
                                 parser).token).rawData);


#line 1403 "parser.cog"
     

#line 1403 "parser.cog"
     auto nameText = 

#line 1403 "parser.cog"
                           

#line 1403 "parser.cog"
                    getText(

#line 1403 "parser.cog"
                            name);


#line 1406 "parser.cog"
     if(

#line 1406 "parser.cog"
                 

#line 1406 "parser.cog"
        nameText 

#line 1406 "parser.cog"
                 != 

#line 1406 "parser.cog"
                                        

#line 1406 "parser.cog"
                    TerminatedStringSpan(

#line 1406 "parser.cog"
                                         "<"))
{


#line 1407 "parser.cog"
         return 

#line 1407 "parser.cog"
                false;
}


#line 1410 "parser.cog"
                 

#line 1410 "parser.cog"
                 

#line 1410 "parser.cog"
     advanceToken(

#line 1410 "parser.cog"
                  parser);


#line 1412 "parser.cog"
     return 

#line 1412 "parser.cog"
            true;
}


#line 1415 "parser.cog"
 

#line 1415 "parser.cog"
                                                             Decl maybeParseGenericParams(

#line 1415 "parser.cog"
                                            

#line 1415 "parser.cog"
                                      Parser

#line 1415 "parser.cog"
                                            * parser, 

#line 1415 "parser.cog"
                                                    Decl decl)
{


#line 1417 "parser.cog"
     if(

#line 1417 "parser.cog"
        

#line 1417 "parser.cog"
        !

#line 1417 "parser.cog"
                            

#line 1417 "parser.cog"
         tryParseGenericOpen(

#line 1417 "parser.cog"
                             parser))
{


#line 1418 "parser.cog"
         return 

#line 1418 "parser.cog"
                decl;
}


#line 1420 "parser.cog"
                     

#line 1420 "parser.cog"
                     

#line 1420 "parser.cog"
        DEREF(

#line 1420 "parser.cog"
  parser).genericDepth

#line 1420 "parser.cog"
                     ++;


#line 1422 "parser.cog"
     

#line 1422 "parser.cog"
     auto genericDecl = 

#line 1422 "parser.cog"
                                                

#line 1422 "parser.cog"
                                   

#line 1422 "parser.cog"
                       createObject<

#line 1422 "parser.cog"
                                    GenericDecl> ();


#line 1424 "parser.cog"
     

#line 1424 "parser.cog"
     

#line 1424 "parser.cog"
                     

#line 1424 "parser.cog"
                Array<

#line 1424 "parser.cog"
                      Decl>  decls;


#line 1425 "parser.cog"
                       

#line 1425 "parser.cog"
                       

#line 1425 "parser.cog"
     parseGenericParams(

#line 1425 "parser.cog"
                        parser, 

#line 1425 "parser.cog"
                                

#line 1425 "parser.cog"
                                &

#line 1425 "parser.cog"
                                 decls);


#line 1427 "parser.cog"
                DEREF(

#line 1427 "parser.cog"
     genericDecl).name = 

#line 1427 "parser.cog"
                            DEREF(

#line 1427 "parser.cog"
                        decl).name;


#line 1428 "parser.cog"
                         

#line 1428 "parser.cog"
                DEREF(

#line 1428 "parser.cog"
     genericDecl).getDecls() = 

#line 1428 "parser.cog"
                              decls;


#line 1429 "parser.cog"
                DEREF(

#line 1429 "parser.cog"
     genericDecl).inner = 

#line 1429 "parser.cog"
                         decl;


#line 1431 "parser.cog"
         DEREF(

#line 1431 "parser.cog"
     decl).parent = 

#line 1431 "parser.cog"
                   genericDecl;


#line 1433 "parser.cog"
              

#line 1433 "parser.cog"
              

#line 1433 "parser.cog"
     pushScope(

#line 1433 "parser.cog"
               parser, 

#line 1433 "parser.cog"
                       genericDecl);


#line 1435 "parser.cog"
                     

#line 1435 "parser.cog"
                     

#line 1435 "parser.cog"
        DEREF(

#line 1435 "parser.cog"
  parser).genericDepth

#line 1435 "parser.cog"
                     --;


#line 1437 "parser.cog"
                       

#line 1437 "parser.cog"
                       

#line 1437 "parser.cog"
     expectGenericClose(

#line 1437 "parser.cog"
                        parser);


#line 1438 "parser.cog"
     return 

#line 1438 "parser.cog"
            genericDecl;
}


#line 1441 "parser.cog"
 

#line 1441 "parser.cog"
                                                                    Decl parseAggTypeDeclCommon(

#line 1441 "parser.cog"
                                           

#line 1441 "parser.cog"
                                     Parser

#line 1441 "parser.cog"
                                           * parser, 

#line 1441 "parser.cog"
                                                    AggTypeDecl decl)
{


#line 1443 "parser.cog"
         DEREF(

#line 1443 "parser.cog"
     decl).name = 

#line 1443 "parser.cog"
                                 

#line 1443 "parser.cog"
                 expectIdentifier(

#line 1443 "parser.cog"
                                  parser);


#line 1446 "parser.cog"
     

#line 1446 "parser.cog"
     auto result = 

#line 1446 "parser.cog"
                                         

#line 1446 "parser.cog"
                  maybeParseGenericParams(

#line 1446 "parser.cog"
                                          parser, 

#line 1446 "parser.cog"
                                                  decl);


#line 1449 "parser.cog"
     if(

#line 1449 "parser.cog"
               

#line 1449 "parser.cog"
        result 

#line 1449 "parser.cog"
               != 

#line 1449 "parser.cog"
                  decl)
{
}


#line 1455 "parser.cog"
     if(

#line 1455 "parser.cog"
                 

#line 1455 "parser.cog"
        advanceIf(

#line 1455 "parser.cog"
                  parser, 

#line 1455 "parser.cog"
                          kTokenCode_Colon))
{


#line 1457 "parser.cog"
             DEREF(

#line 1457 "parser.cog"
         decl).base = 

#line 1457 "parser.cog"
                              

#line 1457 "parser.cog"
                     parseType(

#line 1457 "parser.cog"
                               parser);
}


#line 1461 "parser.cog"
                  

#line 1461 "parser.cog"
                  

#line 1461 "parser.cog"
     parseDeclBody(

#line 1461 "parser.cog"
                   parser, 

#line 1461 "parser.cog"
                           decl);


#line 1463 "parser.cog"
     if(

#line 1463 "parser.cog"
               

#line 1463 "parser.cog"
        result 

#line 1463 "parser.cog"
               != 

#line 1463 "parser.cog"
                  decl)
{
}


#line 1468 "parser.cog"
     return 

#line 1468 "parser.cog"
            result;
}


#line 1471 "parser.cog"
 

#line 1471 "parser.cog"
                                         Syntax parseClassDecl(

#line 1471 "parser.cog"
                                   

#line 1471 "parser.cog"
                             Parser

#line 1471 "parser.cog"
                                   * parser)
{


#line 1473 "parser.cog"
     

#line 1473 "parser.cog"
     auto decl = 

#line 1473 "parser.cog"
                                       

#line 1473 "parser.cog"
                            

#line 1473 "parser.cog"
                createObject<

#line 1473 "parser.cog"
                             ClassDecl> ();


#line 1474 "parser.cog"
     return 

#line 1474 "parser.cog"
                                  

#line 1474 "parser.cog"
            parseAggTypeDeclCommon(

#line 1474 "parser.cog"
                                   parser, 

#line 1474 "parser.cog"
                                           decl);
}


#line 1477 "parser.cog"
 

#line 1477 "parser.cog"
                                          Syntax parseStructDecl(

#line 1477 "parser.cog"
                                    

#line 1477 "parser.cog"
                              Parser

#line 1477 "parser.cog"
                                    * parser)
{


#line 1479 "parser.cog"
     

#line 1479 "parser.cog"
     auto decl = 

#line 1479 "parser.cog"
                                        

#line 1479 "parser.cog"
                            

#line 1479 "parser.cog"
                createObject<

#line 1479 "parser.cog"
                             StructDecl> ();


#line 1480 "parser.cog"
     return 

#line 1480 "parser.cog"
                                  

#line 1480 "parser.cog"
            parseAggTypeDeclCommon(

#line 1480 "parser.cog"
                                   parser, 

#line 1480 "parser.cog"
                                           decl);
}


#line 1483 "parser.cog"
 

#line 1483 "parser.cog"
                                             

#line 1483 "parser.cog"
                                        Array<

#line 1483 "parser.cog"
                                              Decl>  parseEnumTags(

#line 1483 "parser.cog"
                                  

#line 1483 "parser.cog"
                            Parser

#line 1483 "parser.cog"
                                  * parser)
{


#line 1485 "parser.cog"
     

#line 1485 "parser.cog"
     

#line 1485 "parser.cog"
                     

#line 1485 "parser.cog"
                Array<

#line 1485 "parser.cog"
                      Decl>  decls;


#line 1486 "parser.cog"
     {
for(;;)
{
{


#line 1488 "parser.cog"
         switch(

#line 1488 "parser.cog"
                              

#line 1488 "parser.cog"
                 peekTokenCode(

#line 1488 "parser.cog"
                               parser))
{
case 

#line 1490 "parser.cog"
              kTokenCode_RCurly:
case 

#line 1491 "parser.cog"
              kTokenCode_RParen:
case 

#line 1492 "parser.cog"
              kTokenCode_EndOfFile:
{


#line 1493 "parser.cog"
             return 

#line 1493 "parser.cog"
                    decls;
}
default:
{


#line 1496 "parser.cog"
             break;
}
}


#line 1500 "parser.cog"
         

#line 1500 "parser.cog"
         auto tag = 

#line 1500 "parser.cog"
                                            

#line 1500 "parser.cog"
                               

#line 1500 "parser.cog"
                   createObject<

#line 1500 "parser.cog"
                                EnumTagDecl> ();


#line 1501 "parser.cog"
            DEREF(

#line 1501 "parser.cog"
         tag).name = 

#line 1501 "parser.cog"
                                    

#line 1501 "parser.cog"
                    expectIdentifier(

#line 1501 "parser.cog"
                                     parser);


#line 1502 "parser.cog"
         if(

#line 1502 "parser.cog"
                      

#line 1502 "parser.cog"
             advanceIf(

#line 1502 "parser.cog"
                       parser, 

#line 1502 "parser.cog"
                               kTokenCode_Assign))
{


#line 1504 "parser.cog"
                DEREF(

#line 1504 "parser.cog"
             tag).init = 

#line 1504 "parser.cog"
                                

#line 1504 "parser.cog"
                        parseExp(

#line 1504 "parser.cog"
                                 parser);
}


#line 1507 "parser.cog"
                     

#line 1507 "parser.cog"
                     

#line 1507 "parser.cog"
              DEREF(

#line 1507 "parser.cog"
         decls).append(

#line 1507 "parser.cog"
                      tag);


#line 1509 "parser.cog"
         switch(

#line 1509 "parser.cog"
                              

#line 1509 "parser.cog"
                 peekTokenCode(

#line 1509 "parser.cog"
                               parser))
{
case 

#line 1511 "parser.cog"
              kTokenCode_RCurly:
case 

#line 1512 "parser.cog"
              kTokenCode_RParen:
case 

#line 1513 "parser.cog"
              kTokenCode_EndOfFile:
{


#line 1514 "parser.cog"
             return 

#line 1514 "parser.cog"
                    decls;
}
default:
{


#line 1517 "parser.cog"
             break;
}
}


#line 1520 "parser.cog"
               

#line 1520 "parser.cog"
               

#line 1520 "parser.cog"
         expect(

#line 1520 "parser.cog"
                parser, 

#line 1520 "parser.cog"
                        kTokenCode_Comma);
}
}}
}


#line 1524 "parser.cog"
 

#line 1524 "parser.cog"
                                        Syntax parseEnumDecl(

#line 1524 "parser.cog"
                                  

#line 1524 "parser.cog"
                            Parser

#line 1524 "parser.cog"
                                  * parser)
{


#line 1526 "parser.cog"
     

#line 1526 "parser.cog"
     auto decl = 

#line 1526 "parser.cog"
                                      

#line 1526 "parser.cog"
                            

#line 1526 "parser.cog"
                createObject<

#line 1526 "parser.cog"
                             EnumDecl> ();


#line 1528 "parser.cog"
         DEREF(

#line 1528 "parser.cog"
     decl).name = 

#line 1528 "parser.cog"
                                 

#line 1528 "parser.cog"
                 expectIdentifier(

#line 1528 "parser.cog"
                                  parser);


#line 1531 "parser.cog"
     

#line 1531 "parser.cog"
     auto result = 

#line 1531 "parser.cog"
                                         

#line 1531 "parser.cog"
                  maybeParseGenericParams(

#line 1531 "parser.cog"
                                          parser, 

#line 1531 "parser.cog"
                                                  decl);


#line 1535 "parser.cog"
     if(

#line 1535 "parser.cog"
                  

#line 1535 "parser.cog"
         advanceIf(

#line 1535 "parser.cog"
                   parser, 

#line 1535 "parser.cog"
                           kTokenCode_Colon))
{


#line 1537 "parser.cog"
             DEREF(

#line 1537 "parser.cog"
         decl).base = 

#line 1537 "parser.cog"
                              

#line 1537 "parser.cog"
                     parseType(

#line 1537 "parser.cog"
                               parser);
}


#line 1540 "parser.cog"
           

#line 1540 "parser.cog"
           

#line 1540 "parser.cog"
     expect(

#line 1540 "parser.cog"
            parser, 

#line 1540 "parser.cog"
                    kTokenCode_LCurly);


#line 1541 "parser.cog"
     

#line 1541 "parser.cog"
     auto decls = 

#line 1541 "parser.cog"
                              

#line 1541 "parser.cog"
                 parseEnumTags(

#line 1541 "parser.cog"
                               parser);


#line 1542 "parser.cog"
           

#line 1542 "parser.cog"
           

#line 1542 "parser.cog"
     expect(

#line 1542 "parser.cog"
            parser, 

#line 1542 "parser.cog"
                    kTokenCode_RCurly);


#line 1544 "parser.cog"
         DEREF(

#line 1544 "parser.cog"
     decl).stmts = 

#line 1544 "parser.cog"
                  

#line 1544 "parser.cog"
                  *

#line 1544 "parser.cog"
                   cast<

#line 1544 "parser.cog"
                           

#line 1544 "parser.cog"
                        Ptr<

#line 1544 "parser.cog"
                                 

#line 1544 "parser.cog"
                            Array<

#line 1544 "parser.cog"
                                  Stmt> > >(

#line 1544 "parser.cog"
                                            

#line 1544 "parser.cog"
                                            &

#line 1544 "parser.cog"
                                             decls);


#line 1546 "parser.cog"
     return 

#line 1546 "parser.cog"
            result;
}


#line 1549 "parser.cog"
 

#line 1549 "parser.cog"
                                          Syntax parseImportDecl(

#line 1549 "parser.cog"
                                    

#line 1549 "parser.cog"
                              Parser

#line 1549 "parser.cog"
                                    * parser)
{


#line 1551 "parser.cog"
     

#line 1551 "parser.cog"
     auto decl = 

#line 1551 "parser.cog"
                                        

#line 1551 "parser.cog"
                            

#line 1551 "parser.cog"
                createObject<

#line 1551 "parser.cog"
                             ImportDecl> ();


#line 1552 "parser.cog"
         DEREF(

#line 1552 "parser.cog"
     decl).scope = 

#line 1552 "parser.cog"
                        DEREF(

#line 1552 "parser.cog"
                  parser).scope;


#line 1553 "parser.cog"
         DEREF(

#line 1553 "parser.cog"
     decl).name = 

#line 1553 "parser.cog"
                                 

#line 1553 "parser.cog"
                 expectIdentifier(

#line 1553 "parser.cog"
                                  parser);


#line 1554 "parser.cog"
           

#line 1554 "parser.cog"
           

#line 1554 "parser.cog"
     expect(

#line 1554 "parser.cog"
            parser, 

#line 1554 "parser.cog"
                    kTokenCode_Semi);


#line 1555 "parser.cog"
     return 

#line 1555 "parser.cog"
            decl;
}


#line 1559 "parser.cog"
 void parseVarDeclCommon(

#line 1559 "parser.cog"
                                       

#line 1559 "parser.cog"
                                 Parser

#line 1559 "parser.cog"
                                       * parser, 

#line 1559 "parser.cog"
                                                VarDeclBase decl)
{


#line 1561 "parser.cog"
         DEREF(

#line 1561 "parser.cog"
     decl).name = 

#line 1561 "parser.cog"
                                 

#line 1561 "parser.cog"
                 expectIdentifier(

#line 1561 "parser.cog"
                                  parser);


#line 1564 "parser.cog"
     if(

#line 1564 "parser.cog"
                 

#line 1564 "parser.cog"
        advanceIf(

#line 1564 "parser.cog"
                  parser, 

#line 1564 "parser.cog"
                          kTokenCode_Colon))
{


#line 1566 "parser.cog"
             DEREF(

#line 1566 "parser.cog"
         decl).type = 

#line 1566 "parser.cog"
                              

#line 1566 "parser.cog"
                     parseType(

#line 1566 "parser.cog"
                               parser);
}


#line 1570 "parser.cog"
     if(

#line 1570 "parser.cog"
                 

#line 1570 "parser.cog"
        advanceIf(

#line 1570 "parser.cog"
                  parser, 

#line 1570 "parser.cog"
                          kTokenCode_Assign))
{


#line 1572 "parser.cog"
             DEREF(

#line 1572 "parser.cog"
         decl).init = 

#line 1572 "parser.cog"
                             

#line 1572 "parser.cog"
                     parseExp(

#line 1572 "parser.cog"
                              parser);
}
}


#line 1576 "parser.cog"
 

#line 1576 "parser.cog"
                                       Syntax parseVarDecl(

#line 1576 "parser.cog"
                                 

#line 1576 "parser.cog"
                           Parser

#line 1576 "parser.cog"
                                 * parser)
{


#line 1578 "parser.cog"
     

#line 1578 "parser.cog"
     auto decl = 

#line 1578 "parser.cog"
                                     

#line 1578 "parser.cog"
                            

#line 1578 "parser.cog"
                createObject<

#line 1578 "parser.cog"
                             VarDecl> ();


#line 1579 "parser.cog"
                       

#line 1579 "parser.cog"
                       

#line 1579 "parser.cog"
     parseVarDeclCommon(

#line 1579 "parser.cog"
                        parser, 

#line 1579 "parser.cog"
                                decl);


#line 1580 "parser.cog"
           

#line 1580 "parser.cog"
           

#line 1580 "parser.cog"
     expect(

#line 1580 "parser.cog"
            parser, 

#line 1580 "parser.cog"
                    kTokenCode_Semi);


#line 1581 "parser.cog"
     return 

#line 1581 "parser.cog"
            decl;
}


#line 1584 "parser.cog"
 

#line 1584 "parser.cog"
                                       Syntax parseLetDecl(

#line 1584 "parser.cog"
                                 

#line 1584 "parser.cog"
                           Parser

#line 1584 "parser.cog"
                                 * parser)
{


#line 1586 "parser.cog"
     

#line 1586 "parser.cog"
     auto decl = 

#line 1586 "parser.cog"
                                     

#line 1586 "parser.cog"
                            

#line 1586 "parser.cog"
                createObject<

#line 1586 "parser.cog"
                             LetDecl> ();


#line 1587 "parser.cog"
                       

#line 1587 "parser.cog"
                       

#line 1587 "parser.cog"
     parseVarDeclCommon(

#line 1587 "parser.cog"
                        parser, 

#line 1587 "parser.cog"
                                decl);


#line 1588 "parser.cog"
           

#line 1588 "parser.cog"
           

#line 1588 "parser.cog"
     expect(

#line 1588 "parser.cog"
            parser, 

#line 1588 "parser.cog"
                    kTokenCode_Semi);


#line 1589 "parser.cog"
     return 

#line 1589 "parser.cog"
            decl;
}


#line 1592 "parser.cog"
 void parseTypeVarDeclSuffixCommon(

#line 1592 "parser.cog"
                                                 

#line 1592 "parser.cog"
                                           Parser

#line 1592 "parser.cog"
                                                 * parser, 

#line 1592 "parser.cog"
                                                          TypeVarDecl decl)
{


#line 1595 "parser.cog"
     if(

#line 1595 "parser.cog"
                 

#line 1595 "parser.cog"
        advanceIf(

#line 1595 "parser.cog"
                  parser, 

#line 1595 "parser.cog"
                          kTokenCode_Colon))
{


#line 1597 "parser.cog"
             DEREF(

#line 1597 "parser.cog"
         decl).bound = 

#line 1597 "parser.cog"
                               

#line 1597 "parser.cog"
                      parseType(

#line 1597 "parser.cog"
                                parser);
}


#line 1601 "parser.cog"
     if(

#line 1601 "parser.cog"
                 

#line 1601 "parser.cog"
        advanceIf(

#line 1601 "parser.cog"
                  parser, 

#line 1601 "parser.cog"
                          kTokenCode_Assign))
{


#line 1603 "parser.cog"
             DEREF(

#line 1603 "parser.cog"
         decl).init = 

#line 1603 "parser.cog"
                              

#line 1603 "parser.cog"
                     parseType(

#line 1603 "parser.cog"
                               parser);
}
}


#line 1607 "parser.cog"
 void parseTypeVarDeclCommon(

#line 1607 "parser.cog"
                                           

#line 1607 "parser.cog"
                                     Parser

#line 1607 "parser.cog"
                                           * parser, 

#line 1607 "parser.cog"
                                                    TypeVarDecl decl)
{


#line 1609 "parser.cog"
         DEREF(

#line 1609 "parser.cog"
     decl).name = 

#line 1609 "parser.cog"
                                 

#line 1609 "parser.cog"
                 expectIdentifier(

#line 1609 "parser.cog"
                                  parser);


#line 1610 "parser.cog"
                                 

#line 1610 "parser.cog"
                                 

#line 1610 "parser.cog"
     parseTypeVarDeclSuffixCommon(

#line 1610 "parser.cog"
                                  parser, 

#line 1610 "parser.cog"
                                          decl);
}


#line 1613 "parser.cog"
 

#line 1613 "parser.cog"
                                                         

#line 1613 "parser.cog"
                                                     Name

#line 1613 "parser.cog"
                                                         * expectOperatorOrIdentifier(

#line 1613 "parser.cog"
                                               

#line 1613 "parser.cog"
                                         Parser

#line 1613 "parser.cog"
                                               * parser)
{


#line 1615 "parser.cog"
     switch(

#line 1615 "parser.cog"
                         

#line 1615 "parser.cog"
            peekTokenCode(

#line 1615 "parser.cog"
                          parser))
{
default:
{


#line 1618 "parser.cog"
         return 

#line 1618 "parser.cog"
                                

#line 1618 "parser.cog"
                expectIdentifier(

#line 1618 "parser.cog"
                                 parser);
}
case 

#line 1620 "parser.cog"
          kTokenCode_Identifier:
case 

#line 1621 "parser.cog"
          kTokenCode_InfixOperator:
case 

#line 1622 "parser.cog"
          kTokenCode_PrefixOperator:
case 

#line 1623 "parser.cog"
          kTokenCode_PostfixOperator:
{


#line 1624 "parser.cog"
         return 

#line 1624 "parser.cog"
                cast<

#line 1624 "parser.cog"
                        

#line 1624 "parser.cog"
                     Ptr<

#line 1624 "parser.cog"
                         Name> >(

#line 1624 "parser.cog"
                                                     DEREF(

#line 1624 "parser.cog"
                                             

#line 1624 "parser.cog"
                                 advanceToken(

#line 1624 "parser.cog"
                                              parser)).rawData);
}
}
}


#line 1628 "parser.cog"
 

#line 1628 "parser.cog"
                                             Syntax parseTypeAliasDecl(

#line 1628 "parser.cog"
                                       

#line 1628 "parser.cog"
                                 Parser

#line 1628 "parser.cog"
                                       * parser)
{


#line 1630 "parser.cog"
     

#line 1630 "parser.cog"
     auto decl = 

#line 1630 "parser.cog"
                                           

#line 1630 "parser.cog"
                            

#line 1630 "parser.cog"
                createObject<

#line 1630 "parser.cog"
                             TypeAliasDecl> ();


#line 1632 "parser.cog"
         DEREF(

#line 1632 "parser.cog"
     decl).name = 

#line 1632 "parser.cog"
                                           

#line 1632 "parser.cog"
                 expectOperatorOrIdentifier(

#line 1632 "parser.cog"
                                            parser);


#line 1633 "parser.cog"
     

#line 1633 "parser.cog"
     auto result = 

#line 1633 "parser.cog"
                                         

#line 1633 "parser.cog"
                  maybeParseGenericParams(

#line 1633 "parser.cog"
                                          parser, 

#line 1633 "parser.cog"
                                                  decl);


#line 1635 "parser.cog"
                                 

#line 1635 "parser.cog"
                                 

#line 1635 "parser.cog"
     parseTypeVarDeclSuffixCommon(

#line 1635 "parser.cog"
                                  parser, 

#line 1635 "parser.cog"
                                          decl);


#line 1636 "parser.cog"
           

#line 1636 "parser.cog"
           

#line 1636 "parser.cog"
     expect(

#line 1636 "parser.cog"
            parser, 

#line 1636 "parser.cog"
                    kTokenCode_Semi);


#line 1637 "parser.cog"
     return 

#line 1637 "parser.cog"
            result;
}


#line 1640 "parser.cog"
 

#line 1640 "parser.cog"
                                      Syntax parseIfStmt(

#line 1640 "parser.cog"
                                

#line 1640 "parser.cog"
                          Parser

#line 1640 "parser.cog"
                                * parser)
{


#line 1642 "parser.cog"
           

#line 1642 "parser.cog"
           

#line 1642 "parser.cog"
     expect(

#line 1642 "parser.cog"
            parser, 

#line 1642 "parser.cog"
                    kTokenCode_LParen);


#line 1645 "parser.cog"
     if(

#line 1645 "parser.cog"
                  

#line 1645 "parser.cog"
         advanceIf(

#line 1645 "parser.cog"
                   parser, 

#line 1645 "parser.cog"
                                               

#line 1645 "parser.cog"
                           TerminatedStringSpan(

#line 1645 "parser.cog"
                                                "let")))
{


#line 1647 "parser.cog"
         

#line 1647 "parser.cog"
         auto stmt = 

#line 1647 "parser.cog"
                                           

#line 1647 "parser.cog"
                                

#line 1647 "parser.cog"
                    createObject<

#line 1647 "parser.cog"
                                 IfLetStmt> ();


#line 1648 "parser.cog"
             DEREF(

#line 1648 "parser.cog"
         stmt).name = 

#line 1648 "parser.cog"
                                     

#line 1648 "parser.cog"
                     expectIdentifier(

#line 1648 "parser.cog"
                                      parser);


#line 1649 "parser.cog"
               

#line 1649 "parser.cog"
               

#line 1649 "parser.cog"
         expect(

#line 1649 "parser.cog"
                parser, 

#line 1649 "parser.cog"
                        kTokenCode_Assign);


#line 1650 "parser.cog"
             DEREF(

#line 1650 "parser.cog"
         stmt).init = 

#line 1650 "parser.cog"
                             

#line 1650 "parser.cog"
                     parseExp(

#line 1650 "parser.cog"
                              parser);


#line 1651 "parser.cog"
               

#line 1651 "parser.cog"
               

#line 1651 "parser.cog"
         expect(

#line 1651 "parser.cog"
                parser, 

#line 1651 "parser.cog"
                        kTokenCode_RParen);


#line 1652 "parser.cog"
             DEREF(

#line 1652 "parser.cog"
         stmt).thenStmt = 

#line 1652 "parser.cog"
                                  

#line 1652 "parser.cog"
                         parseStmt(

#line 1652 "parser.cog"
                                   parser);


#line 1653 "parser.cog"
         if(

#line 1653 "parser.cog"
                      

#line 1653 "parser.cog"
             advanceIf(

#line 1653 "parser.cog"
                       parser, 

#line 1653 "parser.cog"
                                                   

#line 1653 "parser.cog"
                               TerminatedStringSpan(

#line 1653 "parser.cog"
                                                    "else")))
{


#line 1655 "parser.cog"
                 DEREF(

#line 1655 "parser.cog"
             stmt).elseStmt = 

#line 1655 "parser.cog"
                                      

#line 1655 "parser.cog"
                             parseStmt(

#line 1655 "parser.cog"
                                       parser);
}


#line 1657 "parser.cog"
         return 

#line 1657 "parser.cog"
                stmt;
}
else
{


#line 1661 "parser.cog"
         

#line 1661 "parser.cog"
         auto stmt = 

#line 1661 "parser.cog"
                                        

#line 1661 "parser.cog"
                                

#line 1661 "parser.cog"
                    createObject<

#line 1661 "parser.cog"
                                 IfStmt> ();


#line 1662 "parser.cog"
             DEREF(

#line 1662 "parser.cog"
         stmt).condition = 

#line 1662 "parser.cog"
                                  

#line 1662 "parser.cog"
                          parseExp(

#line 1662 "parser.cog"
                                   parser);


#line 1663 "parser.cog"
               

#line 1663 "parser.cog"
               

#line 1663 "parser.cog"
         expect(

#line 1663 "parser.cog"
                parser, 

#line 1663 "parser.cog"
                        kTokenCode_RParen);


#line 1664 "parser.cog"
             DEREF(

#line 1664 "parser.cog"
         stmt).thenStmt = 

#line 1664 "parser.cog"
                                  

#line 1664 "parser.cog"
                         parseStmt(

#line 1664 "parser.cog"
                                   parser);


#line 1665 "parser.cog"
         if(

#line 1665 "parser.cog"
                      

#line 1665 "parser.cog"
             advanceIf(

#line 1665 "parser.cog"
                       parser, 

#line 1665 "parser.cog"
                                                   

#line 1665 "parser.cog"
                               TerminatedStringSpan(

#line 1665 "parser.cog"
                                                    "else")))
{


#line 1667 "parser.cog"
                 DEREF(

#line 1667 "parser.cog"
             stmt).elseStmt = 

#line 1667 "parser.cog"
                                      

#line 1667 "parser.cog"
                             parseStmt(

#line 1667 "parser.cog"
                                       parser);
}


#line 1669 "parser.cog"
         return 

#line 1669 "parser.cog"
                stmt;
}
}


#line 1673 "parser.cog"
 

#line 1673 "parser.cog"
                                         Syntax parseWhileStmt(

#line 1673 "parser.cog"
                                   

#line 1673 "parser.cog"
                             Parser

#line 1673 "parser.cog"
                                   * parser)
{


#line 1675 "parser.cog"
     

#line 1675 "parser.cog"
     auto stmt = 

#line 1675 "parser.cog"
                                       

#line 1675 "parser.cog"
                            

#line 1675 "parser.cog"
                createObject<

#line 1675 "parser.cog"
                             WhileStmt> ();


#line 1676 "parser.cog"
           

#line 1676 "parser.cog"
           

#line 1676 "parser.cog"
     expect(

#line 1676 "parser.cog"
            parser, 

#line 1676 "parser.cog"
                    kTokenCode_LParen);


#line 1677 "parser.cog"
         DEREF(

#line 1677 "parser.cog"
     stmt).condition = 

#line 1677 "parser.cog"
                              

#line 1677 "parser.cog"
                      parseExp(

#line 1677 "parser.cog"
                               parser);


#line 1678 "parser.cog"
           

#line 1678 "parser.cog"
           

#line 1678 "parser.cog"
     expect(

#line 1678 "parser.cog"
            parser, 

#line 1678 "parser.cog"
                    kTokenCode_RParen);


#line 1679 "parser.cog"
         DEREF(

#line 1679 "parser.cog"
     stmt).body = 

#line 1679 "parser.cog"
                          

#line 1679 "parser.cog"
                 parseStmt(

#line 1679 "parser.cog"
                           parser);


#line 1680 "parser.cog"
     return 

#line 1680 "parser.cog"
            stmt;
}


#line 1683 "parser.cog"
 

#line 1683 "parser.cog"
                                       Syntax parseForStmt(

#line 1683 "parser.cog"
                                 

#line 1683 "parser.cog"
                           Parser

#line 1683 "parser.cog"
                                 * parser)
{


#line 1685 "parser.cog"
     

#line 1685 "parser.cog"
     auto stmt = 

#line 1685 "parser.cog"
                                     

#line 1685 "parser.cog"
                            

#line 1685 "parser.cog"
                createObject<

#line 1685 "parser.cog"
                             ForStmt> ();


#line 1686 "parser.cog"
           

#line 1686 "parser.cog"
           

#line 1686 "parser.cog"
     expect(

#line 1686 "parser.cog"
            parser, 

#line 1686 "parser.cog"
                    kTokenCode_LParen);


#line 1689 "parser.cog"
     switch(

#line 1689 "parser.cog"
                          

#line 1689 "parser.cog"
             peekTokenCode(

#line 1689 "parser.cog"
                           parser))
{
case 

#line 1691 "parser.cog"
          kTokenCode_Semi:
{


#line 1692 "parser.cog"
                     

#line 1692 "parser.cog"
                     

#line 1692 "parser.cog"
         advanceToken(

#line 1692 "parser.cog"
                      parser);
}
{


#line 1693 "parser.cog"
         break;
}
default:
{


#line 1697 "parser.cog"
             DEREF(

#line 1697 "parser.cog"
         stmt).init = 

#line 1697 "parser.cog"
                              

#line 1697 "parser.cog"
                     parseStmt(

#line 1697 "parser.cog"
                               parser);
}
{


#line 1698 "parser.cog"
                    

#line 1698 "parser.cog"
                    

#line 1698 "parser.cog"
             DEREF(

#line 1698 "parser.cog"
       DEREF(

#line 1698 "parser.cog"
   stmt).stmts).append(

#line 1698 "parser.cog"
                         DEREF(

#line 1698 "parser.cog"
                     stmt).init);
}
{


#line 1699 "parser.cog"
         break;
}
}


#line 1703 "parser.cog"
     switch(

#line 1703 "parser.cog"
                          

#line 1703 "parser.cog"
             peekTokenCode(

#line 1703 "parser.cog"
                           parser))
{
case 

#line 1705 "parser.cog"
          kTokenCode_Semi:
{


#line 1706 "parser.cog"
                     

#line 1706 "parser.cog"
                     

#line 1706 "parser.cog"
         advanceToken(

#line 1706 "parser.cog"
                      parser);
}
{


#line 1707 "parser.cog"
         break;
}
default:
{


#line 1712 "parser.cog"
             DEREF(

#line 1712 "parser.cog"
         stmt).condition = 

#line 1712 "parser.cog"
                                  

#line 1712 "parser.cog"
                          parseExp(

#line 1712 "parser.cog"
                                   parser);
}
{


#line 1713 "parser.cog"
               

#line 1713 "parser.cog"
               

#line 1713 "parser.cog"
         expect(

#line 1713 "parser.cog"
                parser, 

#line 1713 "parser.cog"
                        kTokenCode_Semi);
}
{


#line 1714 "parser.cog"
         break;
}
}


#line 1718 "parser.cog"
     switch(

#line 1718 "parser.cog"
                          

#line 1718 "parser.cog"
             peekTokenCode(

#line 1718 "parser.cog"
                           parser))
{
case 

#line 1720 "parser.cog"
          kTokenCode_RParen:
{


#line 1721 "parser.cog"
         break;
}
default:
{


#line 1724 "parser.cog"
             DEREF(

#line 1724 "parser.cog"
         stmt).iter = 

#line 1724 "parser.cog"
                             

#line 1724 "parser.cog"
                     parseExp(

#line 1724 "parser.cog"
                              parser);
}
{


#line 1725 "parser.cog"
         break;
}
}


#line 1728 "parser.cog"
           

#line 1728 "parser.cog"
           

#line 1728 "parser.cog"
     expect(

#line 1728 "parser.cog"
            parser, 

#line 1728 "parser.cog"
                    kTokenCode_RParen);


#line 1729 "parser.cog"
         DEREF(

#line 1729 "parser.cog"
     stmt).body = 

#line 1729 "parser.cog"
                          

#line 1729 "parser.cog"
                 parseStmt(

#line 1729 "parser.cog"
                           parser);


#line 1730 "parser.cog"
     return 

#line 1730 "parser.cog"
            stmt;
}


#line 1733 "parser.cog"
 

#line 1733 "parser.cog"
                                           Syntax parseForEachStmt(

#line 1733 "parser.cog"
                                     

#line 1733 "parser.cog"
                               Parser

#line 1733 "parser.cog"
                                     * parser)
{


#line 1735 "parser.cog"
     

#line 1735 "parser.cog"
     auto stmt = 

#line 1735 "parser.cog"
                                         

#line 1735 "parser.cog"
                            

#line 1735 "parser.cog"
                createObject<

#line 1735 "parser.cog"
                             ForEachStmt> ();


#line 1736 "parser.cog"
           

#line 1736 "parser.cog"
           

#line 1736 "parser.cog"
     expect(

#line 1736 "parser.cog"
            parser, 

#line 1736 "parser.cog"
                    kTokenCode_LParen);


#line 1738 "parser.cog"
         DEREF(

#line 1738 "parser.cog"
     stmt).name = 

#line 1738 "parser.cog"
                                 

#line 1738 "parser.cog"
                 expectIdentifier(

#line 1738 "parser.cog"
                                  parser);


#line 1740 "parser.cog"
     if(

#line 1740 "parser.cog"
         

#line 1740 "parser.cog"
         !

#line 1740 "parser.cog"
                   

#line 1740 "parser.cog"
          advanceIf(

#line 1740 "parser.cog"
                    parser, 

#line 1740 "parser.cog"
                                                

#line 1740 "parser.cog"
                            TerminatedStringSpan(

#line 1740 "parser.cog"
                                                 "in")))
{


#line 1742 "parser.cog"
               

#line 1742 "parser.cog"
               

#line 1742 "parser.cog"
         expect(

#line 1742 "parser.cog"
                parser, 

#line 1742 "parser.cog"
                        kTokenCode_Colon);
}


#line 1745 "parser.cog"
         DEREF(

#line 1745 "parser.cog"
     stmt).exp = 

#line 1745 "parser.cog"
                        

#line 1745 "parser.cog"
                parseExp(

#line 1745 "parser.cog"
                         parser);


#line 1747 "parser.cog"
           

#line 1747 "parser.cog"
           

#line 1747 "parser.cog"
     expect(

#line 1747 "parser.cog"
            parser, 

#line 1747 "parser.cog"
                    kTokenCode_RParen);


#line 1748 "parser.cog"
         DEREF(

#line 1748 "parser.cog"
     stmt).body = 

#line 1748 "parser.cog"
                          

#line 1748 "parser.cog"
                 parseStmt(

#line 1748 "parser.cog"
                           parser);


#line 1749 "parser.cog"
     return 

#line 1749 "parser.cog"
            stmt;
}


#line 1752 "parser.cog"
 

#line 1752 "parser.cog"
                                          Syntax parseSwitchStmt(

#line 1752 "parser.cog"
                                    

#line 1752 "parser.cog"
                              Parser

#line 1752 "parser.cog"
                                    * parser)
{


#line 1754 "parser.cog"
     

#line 1754 "parser.cog"
     auto stmt = 

#line 1754 "parser.cog"
                                        

#line 1754 "parser.cog"
                            

#line 1754 "parser.cog"
                createObject<

#line 1754 "parser.cog"
                             SwitchStmt> ();


#line 1755 "parser.cog"
           

#line 1755 "parser.cog"
           

#line 1755 "parser.cog"
     expect(

#line 1755 "parser.cog"
            parser, 

#line 1755 "parser.cog"
                    kTokenCode_LParen);


#line 1756 "parser.cog"
         DEREF(

#line 1756 "parser.cog"
     stmt).condition = 

#line 1756 "parser.cog"
                              

#line 1756 "parser.cog"
                      parseExp(

#line 1756 "parser.cog"
                               parser);


#line 1757 "parser.cog"
           

#line 1757 "parser.cog"
           

#line 1757 "parser.cog"
     expect(

#line 1757 "parser.cog"
            parser, 

#line 1757 "parser.cog"
                    kTokenCode_RParen);


#line 1759 "parser.cog"
           

#line 1759 "parser.cog"
           

#line 1759 "parser.cog"
     expect(

#line 1759 "parser.cog"
            parser, 

#line 1759 "parser.cog"
                    kTokenCode_LCurly);


#line 1761 "parser.cog"
     {
for(;;)
{
{


#line 1763 "parser.cog"
         switch(

#line 1763 "parser.cog"
                              

#line 1763 "parser.cog"
                 peekTokenCode(

#line 1763 "parser.cog"
                               parser))
{
case 

#line 1765 "parser.cog"
              kTokenCode_RCurly:
case 

#line 1766 "parser.cog"
              kTokenCode_RParen:
case 

#line 1767 "parser.cog"
              kTokenCode_EndOfFile:
{


#line 1768 "parser.cog"
                   

#line 1768 "parser.cog"
                   

#line 1768 "parser.cog"
             expect(

#line 1768 "parser.cog"
                    parser, 

#line 1768 "parser.cog"
                            kTokenCode_RCurly);
}
{


#line 1769 "parser.cog"
             return 

#line 1769 "parser.cog"
                    stmt;
}
default:
{


#line 1772 "parser.cog"
             break;
}
}


#line 1775 "parser.cog"
         

#line 1775 "parser.cog"
         auto caseStart = 

#line 1775 "parser.cog"
                                

#line 1775 "parser.cog"
                         peekLoc(

#line 1775 "parser.cog"
                                 parser);


#line 1776 "parser.cog"
         

#line 1776 "parser.cog"
         auto c = 

#line 1776 "parser.cog"
                                         

#line 1776 "parser.cog"
                             

#line 1776 "parser.cog"
                 createObject<

#line 1776 "parser.cog"
                              SwitchCase> ();


#line 1777 "parser.cog"
          DEREF(

#line 1777 "parser.cog"
         c).loc = 

#line 1777 "parser.cog"
                 caseStart;


#line 1780 "parser.cog"
         {
for(;;)
{
{


#line 1782 "parser.cog"
             

#line 1782 "parser.cog"
             

#line 1782 "parser.cog"
                       Arg arg = 

#line 1782 "parser.cog"
                             nullptr;


#line 1783 "parser.cog"
             if(

#line 1783 "parser.cog"
                          

#line 1783 "parser.cog"
                 advanceIf(

#line 1783 "parser.cog"
                           parser, 

#line 1783 "parser.cog"
                                                       

#line 1783 "parser.cog"
                                   TerminatedStringSpan(

#line 1783 "parser.cog"
                                                        "case")))
{


#line 1785 "parser.cog"
                 arg = 

#line 1785 "parser.cog"
                                        

#line 1785 "parser.cog"
                                   

#line 1785 "parser.cog"
                       createObject<

#line 1785 "parser.cog"
                                    Arg> ();


#line 1786 "parser.cog"
                    DEREF(

#line 1786 "parser.cog"
                 arg).exp = 

#line 1786 "parser.cog"
                                   

#line 1786 "parser.cog"
                           parseExp(

#line 1786 "parser.cog"
                                    parser);


#line 1787 "parser.cog"
                       

#line 1787 "parser.cog"
                       

#line 1787 "parser.cog"
                 expect(

#line 1787 "parser.cog"
                        parser, 

#line 1787 "parser.cog"
                                kTokenCode_Colon);
}
else
{


#line 1789 "parser.cog"
                  if(

#line 1789 "parser.cog"
                               

#line 1789 "parser.cog"
                      advanceIf(

#line 1789 "parser.cog"
                                parser, 

#line 1789 "parser.cog"
                                                            

#line 1789 "parser.cog"
                                        TerminatedStringSpan(

#line 1789 "parser.cog"
                                                             "default")))
{


#line 1791 "parser.cog"
                 arg = 

#line 1791 "parser.cog"
                                        

#line 1791 "parser.cog"
                                   

#line 1791 "parser.cog"
                       createObject<

#line 1791 "parser.cog"
                                    Arg> ();


#line 1792 "parser.cog"
                    DEREF(

#line 1792 "parser.cog"
                 arg).exp = 

#line 1792 "parser.cog"
                           nullptr;


#line 1793 "parser.cog"
                       

#line 1793 "parser.cog"
                       

#line 1793 "parser.cog"
                 expect(

#line 1793 "parser.cog"
                        parser, 

#line 1793 "parser.cog"
                                kTokenCode_Colon);
}
else
{


#line 1798 "parser.cog"
                 break;
}
}


#line 1801 "parser.cog"
                   

#line 1801 "parser.cog"
                   

#line 1801 "parser.cog"
            DEREF(

#line 1801 "parser.cog"
     DEREF(

#line 1801 "parser.cog"
    c).values).append(

#line 1801 "parser.cog"
                    arg);
}
}}


#line 1804 "parser.cog"
         if(

#line 1804 "parser.cog"
                                 

#line 1804 "parser.cog"
                              

#line 1804 "parser.cog"
                     DEREF(

#line 1804 "parser.cog"
              DEREF(

#line 1804 "parser.cog"
             c).values).getCount() 

#line 1804 "parser.cog"
                                 == 

#line 1804 "parser.cog"
                                    0)
{
}


#line 1811 "parser.cog"
          DEREF(

#line 1811 "parser.cog"
         c).body = 

#line 1811 "parser.cog"
                           

#line 1811 "parser.cog"
                  parseStmt(

#line 1811 "parser.cog"
                            parser);


#line 1813 "parser.cog"
                    

#line 1813 "parser.cog"
                    

#line 1813 "parser.cog"
             DEREF(

#line 1813 "parser.cog"
       DEREF(

#line 1813 "parser.cog"
   stmt).cases).append(

#line 1813 "parser.cog"
                     c);


#line 1815 "parser.cog"
                   

#line 1815 "parser.cog"
                   

#line 1815 "parser.cog"
         tryRecover(

#line 1815 "parser.cog"
                    parser);
}
}}
}


#line 1819 "parser.cog"
 

#line 1819 "parser.cog"
                                          Syntax parseReturnStmt(

#line 1819 "parser.cog"
                                    

#line 1819 "parser.cog"
                              Parser

#line 1819 "parser.cog"
                                    * parser)
{


#line 1821 "parser.cog"
     

#line 1821 "parser.cog"
     auto stmt = 

#line 1821 "parser.cog"
                                        

#line 1821 "parser.cog"
                            

#line 1821 "parser.cog"
                createObject<

#line 1821 "parser.cog"
                             ReturnStmt> ();


#line 1822 "parser.cog"
     if(

#line 1822 "parser.cog"
                              

#line 1822 "parser.cog"
                     

#line 1822 "parser.cog"
        peekTokenCode(

#line 1822 "parser.cog"
                      parser) 

#line 1822 "parser.cog"
                              != 

#line 1822 "parser.cog"
                                 kTokenCode_Semi)
{


#line 1824 "parser.cog"
             DEREF(

#line 1824 "parser.cog"
         stmt).value = 

#line 1824 "parser.cog"
                              

#line 1824 "parser.cog"
                      parseExp(

#line 1824 "parser.cog"
                               parser);
}


#line 1826 "parser.cog"
           

#line 1826 "parser.cog"
           

#line 1826 "parser.cog"
     expect(

#line 1826 "parser.cog"
            parser, 

#line 1826 "parser.cog"
                    kTokenCode_Semi);


#line 1827 "parser.cog"
     return 

#line 1827 "parser.cog"
            stmt;
}


#line 1830 "parser.cog"
 

#line 1830 "parser.cog"
                                         Syntax parseBreakStmt(

#line 1830 "parser.cog"
                                   

#line 1830 "parser.cog"
                             Parser

#line 1830 "parser.cog"
                                   * parser)
{


#line 1832 "parser.cog"
     

#line 1832 "parser.cog"
     auto stmt = 

#line 1832 "parser.cog"
                                       

#line 1832 "parser.cog"
                            

#line 1832 "parser.cog"
                createObject<

#line 1832 "parser.cog"
                             BreakStmt> ();


#line 1833 "parser.cog"
           

#line 1833 "parser.cog"
           

#line 1833 "parser.cog"
     expect(

#line 1833 "parser.cog"
            parser, 

#line 1833 "parser.cog"
                    kTokenCode_Semi);


#line 1834 "parser.cog"
     return 

#line 1834 "parser.cog"
            stmt;
}


#line 1837 "parser.cog"
 

#line 1837 "parser.cog"
                                            Syntax parseContinueStmt(

#line 1837 "parser.cog"
                                      

#line 1837 "parser.cog"
                                Parser

#line 1837 "parser.cog"
                                      * parser)
{


#line 1839 "parser.cog"
     

#line 1839 "parser.cog"
     auto stmt = 

#line 1839 "parser.cog"
                                          

#line 1839 "parser.cog"
                            

#line 1839 "parser.cog"
                createObject<

#line 1839 "parser.cog"
                             ContinueStmt> ();


#line 1840 "parser.cog"
           

#line 1840 "parser.cog"
           

#line 1840 "parser.cog"
     expect(

#line 1840 "parser.cog"
            parser, 

#line 1840 "parser.cog"
                    kTokenCode_Semi);


#line 1841 "parser.cog"
     return 

#line 1841 "parser.cog"
            stmt;
}


#line 1844 "parser.cog"
 

#line 1844 "parser.cog"
                                           Syntax parseBuiltinAttr(

#line 1844 "parser.cog"
                                     

#line 1844 "parser.cog"
                               Parser

#line 1844 "parser.cog"
                                     * parser)
{


#line 1846 "parser.cog"
     

#line 1846 "parser.cog"
     auto attr = 

#line 1846 "parser.cog"
                                         

#line 1846 "parser.cog"
                            

#line 1846 "parser.cog"
                createObject<

#line 1846 "parser.cog"
                             BuiltinAttr> ();


#line 1847 "parser.cog"
           

#line 1847 "parser.cog"
           

#line 1847 "parser.cog"
     expect(

#line 1847 "parser.cog"
            parser, 

#line 1847 "parser.cog"
                    kTokenCode_LParen);


#line 1848 "parser.cog"
         DEREF(

#line 1848 "parser.cog"
     attr).name = 

#line 1848 "parser.cog"
                                 

#line 1848 "parser.cog"
                 expectIdentifier(

#line 1848 "parser.cog"
                                  parser);


#line 1849 "parser.cog"
           

#line 1849 "parser.cog"
           

#line 1849 "parser.cog"
     expect(

#line 1849 "parser.cog"
            parser, 

#line 1849 "parser.cog"
                    kTokenCode_RParen);


#line 1850 "parser.cog"
     return 

#line 1850 "parser.cog"
            attr;
}


#line 1853 "parser.cog"
 

#line 1853 "parser.cog"
                                                Syntax parseDeclRefClassAttr(

#line 1853 "parser.cog"
                                          

#line 1853 "parser.cog"
                                    Parser

#line 1853 "parser.cog"
                                          * parser)
{


#line 1855 "parser.cog"
     

#line 1855 "parser.cog"
     auto attr = 

#line 1855 "parser.cog"
                                              

#line 1855 "parser.cog"
                            

#line 1855 "parser.cog"
                createObject<

#line 1855 "parser.cog"
                             DeclRefClassAttr> ();


#line 1856 "parser.cog"
           

#line 1856 "parser.cog"
           

#line 1856 "parser.cog"
     expect(

#line 1856 "parser.cog"
            parser, 

#line 1856 "parser.cog"
                    kTokenCode_LParen);


#line 1858 "parser.cog"
  

#line 1858 "parser.cog"
  auto name = 

#line 1858 "parser.cog"
                             

#line 1858 "parser.cog"
             expectIdentifier(

#line 1858 "parser.cog"
                              parser);


#line 1860 "parser.cog"
      DEREF(

#line 1860 "parser.cog"
  attr).syntaxClass = 

#line 1860 "parser.cog"
                                    

#line 1860 "parser.cog"
                     findClassByName(

#line 1860 "parser.cog"
                                                  DEREF(

#line 1860 "parser.cog"
                                            

#line 1860 "parser.cog"
                                     getText(

#line 1860 "parser.cog"
                                             name)).begin);


#line 1862 "parser.cog"
           

#line 1862 "parser.cog"
           

#line 1862 "parser.cog"
     expect(

#line 1862 "parser.cog"
            parser, 

#line 1862 "parser.cog"
                    kTokenCode_RParen);


#line 1863 "parser.cog"
     return 

#line 1863 "parser.cog"
            attr;
}


#line 1866 "parser.cog"
 

#line 1866 "parser.cog"
                                     ParamDecl parseParam(

#line 1866 "parser.cog"
                               

#line 1866 "parser.cog"
                         Parser

#line 1866 "parser.cog"
                               * parser)
{


#line 1868 "parser.cog"
     

#line 1868 "parser.cog"
     auto decl = 

#line 1868 "parser.cog"
                                       

#line 1868 "parser.cog"
                            

#line 1868 "parser.cog"
                createObject<

#line 1868 "parser.cog"
                             ParamDecl> ();


#line 1869 "parser.cog"
                       

#line 1869 "parser.cog"
                       

#line 1869 "parser.cog"
     parseVarDeclCommon(

#line 1869 "parser.cog"
                        parser, 

#line 1869 "parser.cog"
                                decl);


#line 1870 "parser.cog"
     return 

#line 1870 "parser.cog"
            decl;
}


#line 1873 "parser.cog"
 void parseParams(

#line 1873 "parser.cog"
                                

#line 1873 "parser.cog"
                          Parser

#line 1873 "parser.cog"
                                * parser, 

#line 1873 "parser.cog"
                                         ContainerDecl decl)
{


#line 1875 "parser.cog"
     

#line 1875 "parser.cog"
     

#line 1875 "parser.cog"
                      

#line 1875 "parser.cog"
                 Array<

#line 1875 "parser.cog"
                       Decl>  params;


#line 1877 "parser.cog"
     switch(

#line 1877 "parser.cog"
                         

#line 1877 "parser.cog"
            peekTokenCode(

#line 1877 "parser.cog"
                          parser))
{
case 

#line 1879 "parser.cog"
          kTokenCode_RCurly:
case 

#line 1880 "parser.cog"
          kTokenCode_RParen:
case 

#line 1881 "parser.cog"
          kTokenCode_EndOfFile:
{


#line 1882 "parser.cog"
         return;
}
default:
{


#line 1885 "parser.cog"
         break;
}
}


#line 1889 "parser.cog"
     {
for(;;)
{
{


#line 1891 "parser.cog"
         

#line 1891 "parser.cog"
         auto param = 

#line 1891 "parser.cog"
                               

#line 1891 "parser.cog"
                     parseParam(

#line 1891 "parser.cog"
                                parser);


#line 1892 "parser.cog"
         if(

#line 1892 "parser.cog"
            param)
{


#line 1894 "parser.cog"
                          

#line 1894 "parser.cog"
                          

#line 1894 "parser.cog"
                   DEREF(

#line 1894 "parser.cog"
             params).append(

#line 1894 "parser.cog"
                           param);
}


#line 1897 "parser.cog"
                   

#line 1897 "parser.cog"
                   

#line 1897 "parser.cog"
         tryRecover(

#line 1897 "parser.cog"
                    parser);


#line 1899 "parser.cog"
         switch(

#line 1899 "parser.cog"
                             

#line 1899 "parser.cog"
                peekTokenCode(

#line 1899 "parser.cog"
                              parser))
{
case 

#line 1901 "parser.cog"
              kTokenCode_RCurly:
case 

#line 1902 "parser.cog"
              kTokenCode_RParen:
case 

#line 1903 "parser.cog"
              kTokenCode_EndOfFile:
{
{


#line 1905 "parser.cog"
                              

#line 1905 "parser.cog"
                     DEREF(

#line 1905 "parser.cog"
                 decl).getDecls() = 

#line 1905 "parser.cog"
                                   params;
}
}
{


#line 1907 "parser.cog"
             return;
}
default:
{


#line 1910 "parser.cog"
             break;
}
}


#line 1913 "parser.cog"
               

#line 1913 "parser.cog"
               

#line 1913 "parser.cog"
         expect(

#line 1913 "parser.cog"
                parser, 

#line 1913 "parser.cog"
                        kTokenCode_Comma);
}
}}


#line 1917 "parser.cog"
                  

#line 1917 "parser.cog"
         DEREF(

#line 1917 "parser.cog"
     decl).getDecls() = 

#line 1917 "parser.cog"
                       params;
}


#line 1922 "parser.cog"
 

#line 1922 "parser.cog"
                                        Syntax parseFuncDecl(

#line 1922 "parser.cog"
                                  

#line 1922 "parser.cog"
                            Parser

#line 1922 "parser.cog"
                                  * parser)
{


#line 1924 "parser.cog"
     

#line 1924 "parser.cog"
     auto decl = 

#line 1924 "parser.cog"
                                      

#line 1924 "parser.cog"
                            

#line 1924 "parser.cog"
                createObject<

#line 1924 "parser.cog"
                             FuncDecl> ();


#line 1925 "parser.cog"
         DEREF(

#line 1925 "parser.cog"
     decl).loc = 

#line 1925 "parser.cog"
                       

#line 1925 "parser.cog"
                peekLoc(

#line 1925 "parser.cog"
                        parser);


#line 1927 "parser.cog"
         DEREF(

#line 1927 "parser.cog"
     decl).name = 

#line 1927 "parser.cog"
                                           

#line 1927 "parser.cog"
                 expectOperatorOrIdentifier(

#line 1927 "parser.cog"
                                            parser);


#line 1930 "parser.cog"
     

#line 1930 "parser.cog"
     auto result = 

#line 1930 "parser.cog"
                                         

#line 1930 "parser.cog"
                  maybeParseGenericParams(

#line 1930 "parser.cog"
                                          parser, 

#line 1930 "parser.cog"
                                                  decl);


#line 1932 "parser.cog"
              

#line 1932 "parser.cog"
              

#line 1932 "parser.cog"
     pushScope(

#line 1932 "parser.cog"
               parser, 

#line 1932 "parser.cog"
                       decl);


#line 1934 "parser.cog"
     if(

#line 1934 "parser.cog"
              

#line 1934 "parser.cog"
        expect(

#line 1934 "parser.cog"
               parser, 

#line 1934 "parser.cog"
                       kTokenCode_LParen))
{


#line 1936 "parser.cog"
                    

#line 1936 "parser.cog"
                    

#line 1936 "parser.cog"
         parseParams(

#line 1936 "parser.cog"
                     parser, 

#line 1936 "parser.cog"
                             decl);
}


#line 1938 "parser.cog"
           

#line 1938 "parser.cog"
           

#line 1938 "parser.cog"
     expect(

#line 1938 "parser.cog"
            parser, 

#line 1938 "parser.cog"
                    kTokenCode_RParen);


#line 1940 "parser.cog"
     if(

#line 1940 "parser.cog"
                 

#line 1940 "parser.cog"
        advanceIf(

#line 1940 "parser.cog"
                  parser, 

#line 1940 "parser.cog"
                          kTokenCode_Arrow))
{


#line 1942 "parser.cog"
             DEREF(

#line 1942 "parser.cog"
         decl).resultType = 

#line 1942 "parser.cog"
                                    

#line 1942 "parser.cog"
                           parseType(

#line 1942 "parser.cog"
                                     parser);
}


#line 1945 "parser.cog"
     if(

#line 1945 "parser.cog"
                     

#line 1945 "parser.cog"
        peekTokenCode(

#line 1945 "parser.cog"
                      parser, 

#line 1945 "parser.cog"
                              kTokenCode_LCurly))
{


#line 1947 "parser.cog"
             DEREF(

#line 1947 "parser.cog"
         decl).body = 

#line 1947 "parser.cog"
                                  

#line 1947 "parser.cog"
                     parseStmtBody(

#line 1947 "parser.cog"
                                   parser);
}
else
{


#line 1951 "parser.cog"
               

#line 1951 "parser.cog"
               

#line 1951 "parser.cog"
         expect(

#line 1951 "parser.cog"
                parser, 

#line 1951 "parser.cog"
                        kTokenCode_Semi);
}


#line 1954 "parser.cog"
             

#line 1954 "parser.cog"
             

#line 1954 "parser.cog"
     popScope(

#line 1954 "parser.cog"
              parser);


#line 1956 "parser.cog"
     return 

#line 1956 "parser.cog"
            result;
}


#line 1959 "parser.cog"
 

#line 1959 "parser.cog"
                                             Syntax parseSubscriptDecl(

#line 1959 "parser.cog"
                                       

#line 1959 "parser.cog"
                                 Parser

#line 1959 "parser.cog"
                                       * parser)
{


#line 1961 "parser.cog"
     

#line 1961 "parser.cog"
     auto decl = 

#line 1961 "parser.cog"
                                           

#line 1961 "parser.cog"
                            

#line 1961 "parser.cog"
                createObject<

#line 1961 "parser.cog"
                             SubscriptDecl> ();


#line 1963 "parser.cog"
              

#line 1963 "parser.cog"
              

#line 1963 "parser.cog"
     pushScope(

#line 1963 "parser.cog"
               parser, 

#line 1963 "parser.cog"
                       decl);


#line 1965 "parser.cog"
     if(

#line 1965 "parser.cog"
              

#line 1965 "parser.cog"
        expect(

#line 1965 "parser.cog"
               parser, 

#line 1965 "parser.cog"
                       kTokenCode_LParen))
{


#line 1967 "parser.cog"
                    

#line 1967 "parser.cog"
                    

#line 1967 "parser.cog"
         parseParams(

#line 1967 "parser.cog"
                     parser, 

#line 1967 "parser.cog"
                             decl);
}


#line 1969 "parser.cog"
           

#line 1969 "parser.cog"
           

#line 1969 "parser.cog"
     expect(

#line 1969 "parser.cog"
            parser, 

#line 1969 "parser.cog"
                    kTokenCode_RParen);


#line 1971 "parser.cog"
     if(

#line 1971 "parser.cog"
                 

#line 1971 "parser.cog"
        advanceIf(

#line 1971 "parser.cog"
                  parser, 

#line 1971 "parser.cog"
                          kTokenCode_Arrow))
{


#line 1973 "parser.cog"
             DEREF(

#line 1973 "parser.cog"
         decl).resultType = 

#line 1973 "parser.cog"
                                    

#line 1973 "parser.cog"
                           parseType(

#line 1973 "parser.cog"
                                     parser);
}


#line 1976 "parser.cog"
     if(

#line 1976 "parser.cog"
                     

#line 1976 "parser.cog"
        peekTokenCode(

#line 1976 "parser.cog"
                      parser, 

#line 1976 "parser.cog"
                              kTokenCode_LCurly))
{


#line 1978 "parser.cog"
             DEREF(

#line 1978 "parser.cog"
         decl).body = 

#line 1978 "parser.cog"
                                  

#line 1978 "parser.cog"
                     parseStmtBody(

#line 1978 "parser.cog"
                                   parser);
}
else
{


#line 1982 "parser.cog"
               

#line 1982 "parser.cog"
               

#line 1982 "parser.cog"
         expect(

#line 1982 "parser.cog"
                parser, 

#line 1982 "parser.cog"
                        kTokenCode_Semi);
}


#line 1985 "parser.cog"
             

#line 1985 "parser.cog"
             

#line 1985 "parser.cog"
     popScope(

#line 1985 "parser.cog"
              parser);


#line 1987 "parser.cog"
     return 

#line 1987 "parser.cog"
            decl;
}


#line 1990 "parser.cog"
 

#line 1990 "parser.cog"
                                               Syntax parseInitializerDecl(

#line 1990 "parser.cog"
                                         

#line 1990 "parser.cog"
                                   Parser

#line 1990 "parser.cog"
                                         * parser)
{


#line 1992 "parser.cog"
     

#line 1992 "parser.cog"
     auto decl = 

#line 1992 "parser.cog"
                                             

#line 1992 "parser.cog"
                            

#line 1992 "parser.cog"
                createObject<

#line 1992 "parser.cog"
                             InitializerDecl> ();


#line 1994 "parser.cog"
              

#line 1994 "parser.cog"
              

#line 1994 "parser.cog"
     pushScope(

#line 1994 "parser.cog"
               parser, 

#line 1994 "parser.cog"
                       decl);


#line 1996 "parser.cog"
     if(

#line 1996 "parser.cog"
              

#line 1996 "parser.cog"
        expect(

#line 1996 "parser.cog"
               parser, 

#line 1996 "parser.cog"
                       kTokenCode_LParen))
{


#line 1998 "parser.cog"
                    

#line 1998 "parser.cog"
                    

#line 1998 "parser.cog"
         parseParams(

#line 1998 "parser.cog"
                     parser, 

#line 1998 "parser.cog"
                             decl);
}


#line 2000 "parser.cog"
           

#line 2000 "parser.cog"
           

#line 2000 "parser.cog"
     expect(

#line 2000 "parser.cog"
            parser, 

#line 2000 "parser.cog"
                    kTokenCode_RParen);


#line 2003 "parser.cog"
     if(

#line 2003 "parser.cog"
                 

#line 2003 "parser.cog"
        advanceIf(

#line 2003 "parser.cog"
                  parser, 

#line 2003 "parser.cog"
                          kTokenCode_Arrow))
{


#line 2005 "parser.cog"
             DEREF(

#line 2005 "parser.cog"
         decl).resultType = 

#line 2005 "parser.cog"
                                    

#line 2005 "parser.cog"
                           parseType(

#line 2005 "parser.cog"
                                     parser);
}


#line 2008 "parser.cog"
     if(

#line 2008 "parser.cog"
                     

#line 2008 "parser.cog"
        peekTokenCode(

#line 2008 "parser.cog"
                      parser, 

#line 2008 "parser.cog"
                              kTokenCode_LCurly))
{


#line 2010 "parser.cog"
             DEREF(

#line 2010 "parser.cog"
         decl).body = 

#line 2010 "parser.cog"
                                  

#line 2010 "parser.cog"
                     parseStmtBody(

#line 2010 "parser.cog"
                                   parser);
}
else
{


#line 2014 "parser.cog"
               

#line 2014 "parser.cog"
               

#line 2014 "parser.cog"
         expect(

#line 2014 "parser.cog"
                parser, 

#line 2014 "parser.cog"
                        kTokenCode_Semi);
}


#line 2017 "parser.cog"
             

#line 2017 "parser.cog"
             

#line 2017 "parser.cog"
     popScope(

#line 2017 "parser.cog"
              parser);


#line 2019 "parser.cog"
     return 

#line 2019 "parser.cog"
            decl;
}


#line 2022 "parser.cog"
 

#line 2022 "parser.cog"
                                        Syntax parseThisExpr(

#line 2022 "parser.cog"
                                  

#line 2022 "parser.cog"
                            Parser

#line 2022 "parser.cog"
                                  * parser)
{


#line 2024 "parser.cog"
     

#line 2024 "parser.cog"
     auto expr = 

#line 2024 "parser.cog"
                                      

#line 2024 "parser.cog"
                            

#line 2024 "parser.cog"
                createObject<

#line 2024 "parser.cog"
                             ThisExpr> ();


#line 2025 "parser.cog"
         DEREF(

#line 2025 "parser.cog"
     expr).scope = 

#line 2025 "parser.cog"
                        DEREF(

#line 2025 "parser.cog"
                  parser).scope;


#line 2026 "parser.cog"
     return 

#line 2026 "parser.cog"
            expr;
}


#line 2029 "parser.cog"
 

#line 2029 "parser.cog"
                                        Syntax parseCastExpr(

#line 2029 "parser.cog"
                                  

#line 2029 "parser.cog"
                            Parser

#line 2029 "parser.cog"
                                  * parser)
{


#line 2031 "parser.cog"
                        

#line 2031 "parser.cog"
                        

#line 2031 "parser.cog"
     tryParseGenericOpen(

#line 2031 "parser.cog"
                         parser);


#line 2032 "parser.cog"
     

#line 2032 "parser.cog"
     auto args = 

#line 2032 "parser.cog"
                                

#line 2032 "parser.cog"
                parseGenericArgs(

#line 2032 "parser.cog"
                                 parser);


#line 2033 "parser.cog"
                       

#line 2033 "parser.cog"
                       

#line 2033 "parser.cog"
     expectGenericClose(

#line 2033 "parser.cog"
                        parser);


#line 2035 "parser.cog"
     

#line 2035 "parser.cog"
     auto expr = 

#line 2035 "parser.cog"
                                      

#line 2035 "parser.cog"
                            

#line 2035 "parser.cog"
                createObject<

#line 2035 "parser.cog"
                             CastExpr> ();


#line 2036 "parser.cog"
                DEREF(

#line 2036 "parser.cog"
         DEREF(

#line 2036 "parser.cog"
     expr).toType).exp = 

#line 2036 "parser.cog"
                              DEREF(

#line 2036 "parser.cog"
                           

#line 2036 "parser.cog"
                       args[

#line 2036 "parser.cog"
                            0]).exp;


#line 2037 "parser.cog"
           

#line 2037 "parser.cog"
           

#line 2037 "parser.cog"
     expect(

#line 2037 "parser.cog"
            parser, 

#line 2037 "parser.cog"
                    kTokenCode_LParen);


#line 2038 "parser.cog"
         DEREF(

#line 2038 "parser.cog"
     expr).arg = 

#line 2038 "parser.cog"
                        

#line 2038 "parser.cog"
                parseExp(

#line 2038 "parser.cog"
                         parser);


#line 2039 "parser.cog"
           

#line 2039 "parser.cog"
           

#line 2039 "parser.cog"
     expect(

#line 2039 "parser.cog"
            parser, 

#line 2039 "parser.cog"
                    kTokenCode_RParen);


#line 2041 "parser.cog"
     return 

#line 2041 "parser.cog"
            expr;
}


#line 2044 "parser.cog"
 

#line 2044 "parser.cog"
                                        Syntax parseNullExpr(

#line 2044 "parser.cog"
                                  

#line 2044 "parser.cog"
                            Parser

#line 2044 "parser.cog"
                                  * parser)
{


#line 2046 "parser.cog"
     

#line 2046 "parser.cog"
     auto expr = 

#line 2046 "parser.cog"
                                         

#line 2046 "parser.cog"
                            

#line 2046 "parser.cog"
                createObject<

#line 2046 "parser.cog"
                             NullLitExpr> ();


#line 2047 "parser.cog"
     return 

#line 2047 "parser.cog"
            expr;
}


#line 2050 "parser.cog"
 

#line 2055 "parser.cog"
        SyntaxDecl createSyntaxDecl(

#line 2051 "parser.cog"
              Session session, 

#line 2052 "parser.cog"
                   

#line 2052 "parser.cog"
           ConstPtr<

#line 2052 "parser.cog"
                    Char>  name, 

#line 2053 "parser.cog"
               SyntaxCallback callback, 

#line 2054 "parser.cog"
                       

#line 2054 "parser.cog"
                  Class

#line 2054 "parser.cog"
                       * syntaxClass)
{


#line 2057 "parser.cog"
     

#line 2057 "parser.cog"
     auto syntaxDecl = 

#line 2057 "parser.cog"
                                              

#line 2057 "parser.cog"
                                  

#line 2057 "parser.cog"
                      createObject<

#line 2057 "parser.cog"
                                   SyntaxDecl> ();


#line 2058 "parser.cog"
               DEREF(

#line 2058 "parser.cog"
     syntaxDecl).name = 

#line 2058 "parser.cog"
                              

#line 2058 "parser.cog"
                       getName(

#line 2058 "parser.cog"
                               session, 

#line 2058 "parser.cog"
                                               

#line 2058 "parser.cog"
                                        UNCONST(

#line 2058 "parser.cog"
                                                name));


#line 2059 "parser.cog"
               DEREF(

#line 2059 "parser.cog"
     syntaxDecl).syntaxClass = 

#line 2059 "parser.cog"
                              syntaxClass;


#line 2060 "parser.cog"
               DEREF(

#line 2060 "parser.cog"
     syntaxDecl).callback = 

#line 2060 "parser.cog"
                           callback;


#line 2061 "parser.cog"
     return 

#line 2061 "parser.cog"
            syntaxDecl;
}


#line 2064 "parser.cog"
 

#line 2064 "parser.cog"
      template<typename T > 

#line 2068 "parser.cog"
        SyntaxDecl createSyntaxDecl(

#line 2065 "parser.cog"
              Session session, 

#line 2066 "parser.cog"
                   

#line 2066 "parser.cog"
           ConstPtr<

#line 2066 "parser.cog"
                    Char>  name, 

#line 2067 "parser.cog"
               SyntaxCallback callback)
{


#line 2070 "parser.cog"
     return 

#line 2070 "parser.cog"
                            

#line 2070 "parser.cog"
            createSyntaxDecl(

#line 2070 "parser.cog"
                             session, 

#line 2070 "parser.cog"
                                      name, 

#line 2070 "parser.cog"
                                            callback, 

#line 2070 "parser.cog"
                                                                 

#line 2070 "parser.cog"
                                                              

#line 2070 "parser.cog"
                                                      getClass<

#line 2070 "parser.cog"
                                                               T> ());
}


#line 2073 "parser.cog"
 void parseFileIntoModule(

#line 2074 "parser.cog"
              Session session, 

#line 2075 "parser.cog"
                     

#line 2075 "parser.cog"
           SourceFile

#line 2075 "parser.cog"
                     * file, 

#line 2076 "parser.cog"
                 ModuleDecl moduleDecl)
{


#line 2078 "parser.cog"
     

#line 2078 "parser.cog"
     

#line 2078 "parser.cog"
                 Parser parser;


#line 2079 "parser.cog"
                     

#line 2079 "parser.cog"
                     

#line 2079 "parser.cog"
     initializeParser(

#line 2079 "parser.cog"
                      

#line 2079 "parser.cog"
                      &

#line 2079 "parser.cog"
                       parser, 

#line 2079 "parser.cog"
                               session, 

#line 2079 "parser.cog"
                                        file);


#line 2085 "parser.cog"
     

#line 2085 "parser.cog"
     auto globals = 

#line 2085 "parser.cog"
                                              

#line 2085 "parser.cog"
                               

#line 2085 "parser.cog"
                   createObject<

#line 2085 "parser.cog"
                                ContainerDecl> ();


#line 2086 "parser.cog"
     

#line 2086 "parser.cog"
     

#line 2086 "parser.cog"
                           

#line 2086 "parser.cog"
                      Array<

#line 2086 "parser.cog"
                            Decl>  globalDecls;


#line 2089 "parser.cog"
                       

#line 2089 "parser.cog"
                       

#line 2089 "parser.cog"
                DEREF(

#line 2089 "parser.cog"
     globalDecls).append(

#line 2089 "parser.cog"
                                              

#line 2089 "parser.cog"
                                        

#line 2089 "parser.cog"
                        createSyntaxDecl<

#line 2089 "parser.cog"
                                         Decl> (

#line 2089 "parser.cog"
                                               session, 

#line 2089 "parser.cog"
                                                        "import", 

#line 2089 "parser.cog"
                                                                  

#line 2089 "parser.cog"
                                                                  &

#line 2089 "parser.cog"
                                                                   parseImportDecl));


#line 2090 "parser.cog"
                       

#line 2090 "parser.cog"
                       

#line 2090 "parser.cog"
                DEREF(

#line 2090 "parser.cog"
     globalDecls).append(

#line 2090 "parser.cog"
                                              

#line 2090 "parser.cog"
                                        

#line 2090 "parser.cog"
                        createSyntaxDecl<

#line 2090 "parser.cog"
                                         Decl> (

#line 2090 "parser.cog"
                                               session, 

#line 2090 "parser.cog"
                                                        "class", 

#line 2090 "parser.cog"
                                                                 

#line 2090 "parser.cog"
                                                                 &

#line 2090 "parser.cog"
                                                                  parseClassDecl));


#line 2091 "parser.cog"
                       

#line 2091 "parser.cog"
                       

#line 2091 "parser.cog"
                DEREF(

#line 2091 "parser.cog"
     globalDecls).append(

#line 2091 "parser.cog"
                                              

#line 2091 "parser.cog"
                                        

#line 2091 "parser.cog"
                        createSyntaxDecl<

#line 2091 "parser.cog"
                                         Decl> (

#line 2091 "parser.cog"
                                               session, 

#line 2091 "parser.cog"
                                                        "struct", 

#line 2091 "parser.cog"
                                                                  

#line 2091 "parser.cog"
                                                                  &

#line 2091 "parser.cog"
                                                                   parseStructDecl));


#line 2092 "parser.cog"
                       

#line 2092 "parser.cog"
                       

#line 2092 "parser.cog"
                DEREF(

#line 2092 "parser.cog"
     globalDecls).append(

#line 2092 "parser.cog"
                                              

#line 2092 "parser.cog"
                                        

#line 2092 "parser.cog"
                        createSyntaxDecl<

#line 2092 "parser.cog"
                                         Decl> (

#line 2092 "parser.cog"
                                               session, 

#line 2092 "parser.cog"
                                                        "enum", 

#line 2092 "parser.cog"
                                                                

#line 2092 "parser.cog"
                                                                &

#line 2092 "parser.cog"
                                                                 parseEnumDecl));


#line 2093 "parser.cog"
                       

#line 2093 "parser.cog"
                       

#line 2093 "parser.cog"
                DEREF(

#line 2093 "parser.cog"
     globalDecls).append(

#line 2093 "parser.cog"
                                              

#line 2093 "parser.cog"
                                        

#line 2093 "parser.cog"
                        createSyntaxDecl<

#line 2093 "parser.cog"
                                         Decl> (

#line 2093 "parser.cog"
                                               session, 

#line 2093 "parser.cog"
                                                        "var", 

#line 2093 "parser.cog"
                                                               

#line 2093 "parser.cog"
                                                               &

#line 2093 "parser.cog"
                                                                parseVarDecl));


#line 2094 "parser.cog"
                       

#line 2094 "parser.cog"
                       

#line 2094 "parser.cog"
                DEREF(

#line 2094 "parser.cog"
     globalDecls).append(

#line 2094 "parser.cog"
                                              

#line 2094 "parser.cog"
                                        

#line 2094 "parser.cog"
                        createSyntaxDecl<

#line 2094 "parser.cog"
                                         Decl> (

#line 2094 "parser.cog"
                                               session, 

#line 2094 "parser.cog"
                                                        "let", 

#line 2094 "parser.cog"
                                                               

#line 2094 "parser.cog"
                                                               &

#line 2094 "parser.cog"
                                                                parseLetDecl));


#line 2095 "parser.cog"
                       

#line 2095 "parser.cog"
                       

#line 2095 "parser.cog"
                DEREF(

#line 2095 "parser.cog"
     globalDecls).append(

#line 2095 "parser.cog"
                                              

#line 2095 "parser.cog"
                                        

#line 2095 "parser.cog"
                        createSyntaxDecl<

#line 2095 "parser.cog"
                                         Decl> (

#line 2095 "parser.cog"
                                               session, 

#line 2095 "parser.cog"
                                                        "func", 

#line 2095 "parser.cog"
                                                                

#line 2095 "parser.cog"
                                                                &

#line 2095 "parser.cog"
                                                                 parseFuncDecl));


#line 2096 "parser.cog"
                       

#line 2096 "parser.cog"
                       

#line 2096 "parser.cog"
                DEREF(

#line 2096 "parser.cog"
     globalDecls).append(

#line 2096 "parser.cog"
                                              

#line 2096 "parser.cog"
                                        

#line 2096 "parser.cog"
                        createSyntaxDecl<

#line 2096 "parser.cog"
                                         Decl> (

#line 2096 "parser.cog"
                                               session, 

#line 2096 "parser.cog"
                                                        "subscript", 

#line 2096 "parser.cog"
                                                                     

#line 2096 "parser.cog"
                                                                     &

#line 2096 "parser.cog"
                                                                      parseSubscriptDecl));


#line 2097 "parser.cog"
                       

#line 2097 "parser.cog"
                       

#line 2097 "parser.cog"
                DEREF(

#line 2097 "parser.cog"
     globalDecls).append(

#line 2097 "parser.cog"
                                              

#line 2097 "parser.cog"
                                        

#line 2097 "parser.cog"
                        createSyntaxDecl<

#line 2097 "parser.cog"
                                         Decl> (

#line 2097 "parser.cog"
                                               session, 

#line 2097 "parser.cog"
                                                        "init", 

#line 2097 "parser.cog"
                                                                

#line 2097 "parser.cog"
                                                                &

#line 2097 "parser.cog"
                                                                 parseInitializerDecl));


#line 2098 "parser.cog"
                       

#line 2098 "parser.cog"
                       

#line 2098 "parser.cog"
                DEREF(

#line 2098 "parser.cog"
     globalDecls).append(

#line 2098 "parser.cog"
                                              

#line 2098 "parser.cog"
                                        

#line 2098 "parser.cog"
                        createSyntaxDecl<

#line 2098 "parser.cog"
                                         Decl> (

#line 2098 "parser.cog"
                                               session, 

#line 2098 "parser.cog"
                                                        "typealias", 

#line 2098 "parser.cog"
                                                                     

#line 2098 "parser.cog"
                                                                     &

#line 2098 "parser.cog"
                                                                      parseTypeAliasDecl));


#line 2099 "parser.cog"
                       

#line 2099 "parser.cog"
                       

#line 2099 "parser.cog"
                DEREF(

#line 2099 "parser.cog"
     globalDecls).append(

#line 2099 "parser.cog"
                                              

#line 2099 "parser.cog"
                                        

#line 2099 "parser.cog"
                        createSyntaxDecl<

#line 2099 "parser.cog"
                                         Stmt> (

#line 2099 "parser.cog"
                                               session, 

#line 2099 "parser.cog"
                                                        "if", 

#line 2099 "parser.cog"
                                                              

#line 2099 "parser.cog"
                                                              &

#line 2099 "parser.cog"
                                                               parseIfStmt));


#line 2100 "parser.cog"
                       

#line 2100 "parser.cog"
                       

#line 2100 "parser.cog"
                DEREF(

#line 2100 "parser.cog"
     globalDecls).append(

#line 2100 "parser.cog"
                                              

#line 2100 "parser.cog"
                                        

#line 2100 "parser.cog"
                        createSyntaxDecl<

#line 2100 "parser.cog"
                                         Stmt> (

#line 2100 "parser.cog"
                                               session, 

#line 2100 "parser.cog"
                                                        "while", 

#line 2100 "parser.cog"
                                                                 

#line 2100 "parser.cog"
                                                                 &

#line 2100 "parser.cog"
                                                                  parseWhileStmt));


#line 2101 "parser.cog"
                       

#line 2101 "parser.cog"
                       

#line 2101 "parser.cog"
                DEREF(

#line 2101 "parser.cog"
     globalDecls).append(

#line 2101 "parser.cog"
                                              

#line 2101 "parser.cog"
                                        

#line 2101 "parser.cog"
                        createSyntaxDecl<

#line 2101 "parser.cog"
                                         Stmt> (

#line 2101 "parser.cog"
                                               session, 

#line 2101 "parser.cog"
                                                        "for", 

#line 2101 "parser.cog"
                                                               

#line 2101 "parser.cog"
                                                               &

#line 2101 "parser.cog"
                                                                parseForStmt));


#line 2102 "parser.cog"
                       

#line 2102 "parser.cog"
                       

#line 2102 "parser.cog"
                DEREF(

#line 2102 "parser.cog"
     globalDecls).append(

#line 2102 "parser.cog"
                                              

#line 2102 "parser.cog"
                                        

#line 2102 "parser.cog"
                        createSyntaxDecl<

#line 2102 "parser.cog"
                                         Stmt> (

#line 2102 "parser.cog"
                                               session, 

#line 2102 "parser.cog"
                                                        "foreach", 

#line 2102 "parser.cog"
                                                                   

#line 2102 "parser.cog"
                                                                   &

#line 2102 "parser.cog"
                                                                    parseForEachStmt));


#line 2103 "parser.cog"
                       

#line 2103 "parser.cog"
                       

#line 2103 "parser.cog"
                DEREF(

#line 2103 "parser.cog"
     globalDecls).append(

#line 2103 "parser.cog"
                                              

#line 2103 "parser.cog"
                                        

#line 2103 "parser.cog"
                        createSyntaxDecl<

#line 2103 "parser.cog"
                                         Stmt> (

#line 2103 "parser.cog"
                                               session, 

#line 2103 "parser.cog"
                                                        "return", 

#line 2103 "parser.cog"
                                                                  

#line 2103 "parser.cog"
                                                                  &

#line 2103 "parser.cog"
                                                                   parseReturnStmt));


#line 2104 "parser.cog"
                       

#line 2104 "parser.cog"
                       

#line 2104 "parser.cog"
                DEREF(

#line 2104 "parser.cog"
     globalDecls).append(

#line 2104 "parser.cog"
                                              

#line 2104 "parser.cog"
                                        

#line 2104 "parser.cog"
                        createSyntaxDecl<

#line 2104 "parser.cog"
                                         Stmt> (

#line 2104 "parser.cog"
                                               session, 

#line 2104 "parser.cog"
                                                        "break", 

#line 2104 "parser.cog"
                                                                 

#line 2104 "parser.cog"
                                                                 &

#line 2104 "parser.cog"
                                                                  parseBreakStmt));


#line 2105 "parser.cog"
                       

#line 2105 "parser.cog"
                       

#line 2105 "parser.cog"
                DEREF(

#line 2105 "parser.cog"
     globalDecls).append(

#line 2105 "parser.cog"
                                              

#line 2105 "parser.cog"
                                        

#line 2105 "parser.cog"
                        createSyntaxDecl<

#line 2105 "parser.cog"
                                         Stmt> (

#line 2105 "parser.cog"
                                               session, 

#line 2105 "parser.cog"
                                                        "continue", 

#line 2105 "parser.cog"
                                                                    

#line 2105 "parser.cog"
                                                                    &

#line 2105 "parser.cog"
                                                                     parseContinueStmt));


#line 2106 "parser.cog"
                       

#line 2106 "parser.cog"
                       

#line 2106 "parser.cog"
                DEREF(

#line 2106 "parser.cog"
     globalDecls).append(

#line 2106 "parser.cog"
                                              

#line 2106 "parser.cog"
                                        

#line 2106 "parser.cog"
                        createSyntaxDecl<

#line 2106 "parser.cog"
                                         Stmt> (

#line 2106 "parser.cog"
                                               session, 

#line 2106 "parser.cog"
                                                        "switch", 

#line 2106 "parser.cog"
                                                                  

#line 2106 "parser.cog"
                                                                  &

#line 2106 "parser.cog"
                                                                   parseSwitchStmt));


#line 2107 "parser.cog"
                       

#line 2107 "parser.cog"
                       

#line 2107 "parser.cog"
                DEREF(

#line 2107 "parser.cog"
     globalDecls).append(

#line 2107 "parser.cog"
                                              

#line 2107 "parser.cog"
                                        

#line 2107 "parser.cog"
                        createSyntaxDecl<

#line 2107 "parser.cog"
                                         Attr> (

#line 2107 "parser.cog"
                                               session, 

#line 2107 "parser.cog"
                                                        "@__builtin", 

#line 2107 "parser.cog"
                                                                      

#line 2107 "parser.cog"
                                                                      &

#line 2107 "parser.cog"
                                                                       parseBuiltinAttr));


#line 2108 "parser.cog"
                       

#line 2108 "parser.cog"
                       

#line 2108 "parser.cog"
                DEREF(

#line 2108 "parser.cog"
     globalDecls).append(

#line 2108 "parser.cog"
                                              

#line 2108 "parser.cog"
                                        

#line 2108 "parser.cog"
                        createSyntaxDecl<

#line 2108 "parser.cog"
                                         Attr> (

#line 2108 "parser.cog"
                                               session, 

#line 2108 "parser.cog"
                                                        "@__declRefClass", 

#line 2108 "parser.cog"
                                                                           

#line 2108 "parser.cog"
                                                                           &

#line 2108 "parser.cog"
                                                                            parseDeclRefClassAttr));


#line 2110 "parser.cog"
                       

#line 2110 "parser.cog"
                       

#line 2110 "parser.cog"
                DEREF(

#line 2110 "parser.cog"
     globalDecls).append(

#line 2110 "parser.cog"
                                             

#line 2110 "parser.cog"
                                        

#line 2110 "parser.cog"
                        createSyntaxDecl<

#line 2110 "parser.cog"
                                         Exp> (

#line 2110 "parser.cog"
                                              session, 

#line 2110 "parser.cog"
                                                       "this", 

#line 2110 "parser.cog"
                                                               

#line 2110 "parser.cog"
                                                               &

#line 2110 "parser.cog"
                                                                parseThisExpr));


#line 2111 "parser.cog"
                       

#line 2111 "parser.cog"
                       

#line 2111 "parser.cog"
                DEREF(

#line 2111 "parser.cog"
     globalDecls).append(

#line 2111 "parser.cog"
                                             

#line 2111 "parser.cog"
                                        

#line 2111 "parser.cog"
                        createSyntaxDecl<

#line 2111 "parser.cog"
                                         Exp> (

#line 2111 "parser.cog"
                                              session, 

#line 2111 "parser.cog"
                                                       "cast", 

#line 2111 "parser.cog"
                                                               

#line 2111 "parser.cog"
                                                               &

#line 2111 "parser.cog"
                                                                parseCastExpr));


#line 2112 "parser.cog"
                       

#line 2112 "parser.cog"
                       

#line 2112 "parser.cog"
                DEREF(

#line 2112 "parser.cog"
     globalDecls).append(

#line 2112 "parser.cog"
                                             

#line 2112 "parser.cog"
                                        

#line 2112 "parser.cog"
                        createSyntaxDecl<

#line 2112 "parser.cog"
                                         Exp> (

#line 2112 "parser.cog"
                                              session, 

#line 2112 "parser.cog"
                                                       "null", 

#line 2112 "parser.cog"
                                                               

#line 2112 "parser.cog"
                                                               &

#line 2112 "parser.cog"
                                                                parseNullExpr));


#line 2114 "parser.cog"
                     

#line 2114 "parser.cog"
            DEREF(

#line 2114 "parser.cog"
     globals).getDecls() = 

#line 2114 "parser.cog"
                          globalDecls;


#line 2116 "parser.cog"
     

#line 2116 "parser.cog"
     auto globalScope = 

#line 2116 "parser.cog"
                                   

#line 2116 "parser.cog"
                            

#line 2116 "parser.cog"
                       alloc<

#line 2116 "parser.cog"
                             Scope> ();


#line 2117 "parser.cog"
                DEREF(

#line 2117 "parser.cog"
     globalScope).parent = 

#line 2117 "parser.cog"
                          0;


#line 2118 "parser.cog"
                           DEREF(

#line 2118 "parser.cog"
                DEREF(

#line 2118 "parser.cog"
     globalScope).directLink).container = 

#line 2118 "parser.cog"
                                        globals;


#line 2120 "parser.cog"
           DEREF(

#line 2120 "parser.cog"
     parser).scope = 

#line 2120 "parser.cog"
                    globalScope;


#line 2126 "parser.cog"
              

#line 2126 "parser.cog"
              

#line 2126 "parser.cog"
     pushScope(

#line 2126 "parser.cog"
               

#line 2126 "parser.cog"
               &

#line 2126 "parser.cog"
                parser, 

#line 2126 "parser.cog"
                        moduleDecl);


#line 2127 "parser.cog"
     

#line 2127 "parser.cog"
     auto fileDecls = 

#line 2127 "parser.cog"
                                     

#line 2127 "parser.cog"
                     parseDeclsInBody(

#line 2127 "parser.cog"
                                      

#line 2127 "parser.cog"
                                      &

#line 2127 "parser.cog"
                                       parser);


#line 2128 "parser.cog"
     for(auto dd : 

#line 2128 "parser.cog"
                   fileDecls)
{


#line 2129 "parser.cog"
           DEREF(

#line 2129 "parser.cog"
         dd).parent = 

#line 2129 "parser.cog"
                     moduleDecl;
}


#line 2130 "parser.cog"
             

#line 2130 "parser.cog"
             

#line 2130 "parser.cog"
     popScope(

#line 2130 "parser.cog"
              

#line 2130 "parser.cog"
              &

#line 2130 "parser.cog"
               parser);


#line 2132 "parser.cog"
           

#line 2132 "parser.cog"
           

#line 2132 "parser.cog"
     expect(

#line 2132 "parser.cog"
            

#line 2132 "parser.cog"
            &

#line 2132 "parser.cog"
             parser, 

#line 2132 "parser.cog"
                     kTokenCode_EndOfFile);


#line 2134 "parser.cog"
                              

#line 2134 "parser.cog"
                              

#line 2134 "parser.cog"
                       DEREF(

#line 2134 "parser.cog"
                     

#line 2134 "parser.cog"
            DEREF(

#line 2134 "parser.cog"
  moduleDecl).getDecls()).append(

#line 2134 "parser.cog"
                               fileDecls);


#line 2136 "parser.cog"
                   

#line 2136 "parser.cog"
                   

#line 2136 "parser.cog"
     finalizeParser(

#line 2136 "parser.cog"
                    

#line 2136 "parser.cog"
                    &

#line 2136 "parser.cog"
                     parser);
}


#line 2139 "parser.cog"
 void parseFile(

#line 2140 "parser.cog"
              Session session, 

#line 2141 "parser.cog"
                     

#line 2141 "parser.cog"
           SourceFile

#line 2141 "parser.cog"
                     * file)
{


#line 2146 "parser.cog"
     

#line 2146 "parser.cog"
     auto moduleDecl = 

#line 2146 "parser.cog"
                             DEREF(

#line 2146 "parser.cog"
                      session).moduleDecl;


#line 2147 "parser.cog"
     if(

#line 2147 "parser.cog"
        

#line 2147 "parser.cog"
        !

#line 2147 "parser.cog"
         moduleDecl)
{


#line 2149 "parser.cog"
         moduleDecl = 

#line 2149 "parser.cog"
                                              

#line 2149 "parser.cog"
                                  

#line 2149 "parser.cog"
                      createObject<

#line 2149 "parser.cog"
                                   ModuleDecl> ();


#line 2150 "parser.cog"
                   DEREF(

#line 2150 "parser.cog"
         moduleDecl).name = 

#line 2150 "parser.cog"
                                        

#line 2150 "parser.cog"
                           getModuleName(

#line 2150 "parser.cog"
                                         session);


#line 2151 "parser.cog"
                DEREF(

#line 2151 "parser.cog"
         session).moduleDecl = 

#line 2151 "parser.cog"
                              moduleDecl;
}


#line 2154 "parser.cog"
                        

#line 2154 "parser.cog"
                        

#line 2154 "parser.cog"
     parseFileIntoModule(

#line 2154 "parser.cog"
                         session, 

#line 2154 "parser.cog"
                                  file, 

#line 2154 "parser.cog"
                                        moduleDecl);
}


#line 3 "scope.cog"
 

#line 17 "scope.cog"
 void lookupDirectImpl(

#line 18 "scope.cog"
             ContainerStmt container, 

#line 19 "scope.cog"
           

#line 19 "scope.cog"
        Ptr<

#line 19 "scope.cog"
            Name>  name, 

#line 20 "scope.cog"
               

#line 20 "scope.cog"
            Ptr<

#line 20 "scope.cog"
                LookupResult>  ioResult)
{


#line 25 "scope.cog"
     for(auto dd : 

#line 25 "scope.cog"
                                     

#line 25 "scope.cog"
                            DEREF(

#line 25 "scope.cog"
                   container).getDecls())
{
{


#line 27 "scope.cog"
         if(

#line 27 "scope.cog"
                    

#line 27 "scope.cog"
              DEREF(

#line 27 "scope.cog"
            dd).name 

#line 27 "scope.cog"
                    == 

#line 27 "scope.cog"
                       name)
{


#line 29 "scope.cog"
                                  

#line 29 "scope.cog"
                                  

#line 29 "scope.cog"
                           DEREF(

#line 29 "scope.cog"
                     DEREF(

#line 29 "scope.cog"
             ioResult).items).append(

#line 29 "scope.cog"
                                                   

#line 29 "scope.cog"
                                   LookupResultItem(

#line 29 "scope.cog"
                                                    dd));
}
}
}
}


#line 34 "scope.cog"
 

#line 37 "scope.cog"
     LookupResult lookupDirect(

#line 35 "scope.cog"
             ContainerStmt container, 

#line 36 "scope.cog"
           

#line 36 "scope.cog"
        Ptr<

#line 36 "scope.cog"
            Name>  name)
{


#line 39 "scope.cog"
     

#line 39 "scope.cog"
     

#line 39 "scope.cog"
                  LookupResult result;


#line 40 "scope.cog"
                     

#line 40 "scope.cog"
                     

#line 40 "scope.cog"
     lookupDirectImpl(

#line 40 "scope.cog"
                      container, 

#line 40 "scope.cog"
                                 name, 

#line 40 "scope.cog"
                                       

#line 40 "scope.cog"
                                       &

#line 40 "scope.cog"
                                        result);


#line 41 "scope.cog"
     return 

#line 41 "scope.cog"
            result;
}


#line 44 "scope.cog"
 

#line 47 "scope.cog"
     LookupResult lookupDirect(

#line 45 "scope.cog"
            

#line 45 "scope.cog"
         Ptr<

#line 45 "scope.cog"
             Scope>  scope, 

#line 46 "scope.cog"
           

#line 46 "scope.cog"
        Ptr<

#line 46 "scope.cog"
            Name>  name)
{


#line 49 "scope.cog"
     

#line 49 "scope.cog"
     

#line 49 "scope.cog"
                  LookupResult result;


#line 50 "scope.cog"
     {


#line 50 "scope.cog"
         

#line 50 "scope.cog"
         auto ll = 

#line 50 "scope.cog"
                  

#line 50 "scope.cog"
                  &

#line 50 "scope.cog"
                        DEREF(

#line 50 "scope.cog"
                   scope).directLink;
for(;

#line 50 "scope.cog"
                                     ll;

#line 50 "scope.cog"
                                         ll = 

#line 50 "scope.cog"
                                                DEREF(

#line 50 "scope.cog"
                                              ll).next)
{
{


#line 52 "scope.cog"
                         

#line 52 "scope.cog"
                         

#line 52 "scope.cog"
         lookupDirectImpl(

#line 53 "scope.cog"
               DEREF(

#line 53 "scope.cog"
             ll).container, 

#line 54 "scope.cog"
             name, 

#line 55 "scope.cog"
             

#line 55 "scope.cog"
             &

#line 55 "scope.cog"
              result);
}
}}


#line 57 "scope.cog"
     return 

#line 57 "scope.cog"
            result;
}


#line 60 "scope.cog"
 

#line 63 "scope.cog"
     LookupResult lookup(

#line 61 "scope.cog"
            

#line 61 "scope.cog"
         Ptr<

#line 61 "scope.cog"
             Scope>  scope, 

#line 62 "scope.cog"
           

#line 62 "scope.cog"
        Ptr<

#line 62 "scope.cog"
            Name>  name)
{


#line 65 "scope.cog"
  {


#line 65 "scope.cog"
      

#line 65 "scope.cog"
      auto ss = 

#line 65 "scope.cog"
               scope;
for(;

#line 65 "scope.cog"
                      ss;

#line 65 "scope.cog"
                          ss = 

#line 65 "scope.cog"
                                 DEREF(

#line 65 "scope.cog"
                               ss).parent)
{
{


#line 67 "scope.cog"
         

#line 67 "scope.cog"
         auto result = 

#line 67 "scope.cog"
                                  

#line 67 "scope.cog"
                      lookupDirect(

#line 67 "scope.cog"
                                   ss, 

#line 67 "scope.cog"
                                       name);


#line 70 "scope.cog"
         if(

#line 70 "scope.cog"
            

#line 70 "scope.cog"
            !

#line 70 "scope.cog"
                           

#line 70 "scope.cog"
                   DEREF(

#line 70 "scope.cog"
             result).isEmpty())
{


#line 71 "scope.cog"
             return 

#line 71 "scope.cog"
                    result;
}
}
}}


#line 74 "scope.cog"
     return 

#line 74 "scope.cog"
                        

#line 74 "scope.cog"
            LookupResult();
}


#line 3 "session.cog"
 

#line 5 "session.cog"
 

#line 22 "session.cog"
 

#line 22 "session.cog"
                         Session createSession()
{


#line 24 "session.cog"
  

#line 24 "session.cog"
  auto session = 

#line 24 "session.cog"
                                     

#line 24 "session.cog"
                            

#line 24 "session.cog"
                createObject<

#line 24 "session.cog"
                             Session> ();


#line 25 "session.cog"
              DEREF(

#line 25 "session.cog"
         DEREF(

#line 25 "session.cog"
  session).sink).session = 

#line 25 "session.cog"
                         session;


#line 26 "session.cog"
  return 

#line 26 "session.cog"
         session;
}


#line 29 "session.cog"
 void destroySession(

#line 29 "session.cog"
                              Session session)
{


#line 31 "session.cog"
      

#line 31 "session.cog"
      

#line 31 "session.cog"
  free(

#line 31 "session.cog"
       session);
}


#line 34 "session.cog"
 void setModulePath(

#line 35 "session.cog"
           Session session, 

#line 36 "session.cog"
         StringSpan path)
{


#line 38 "session.cog"
         DEREF(

#line 38 "session.cog"
  session).modulePath2 = 

#line 38 "session.cog"
                               

#line 38 "session.cog"
                        getName(

#line 38 "session.cog"
                                session, 

#line 38 "session.cog"
                                         path);


#line 40 "session.cog"
  

#line 40 "session.cog"
  auto name = 

#line 40 "session.cog"
             path;


#line 41 "session.cog"
  name = 

#line 41 "session.cog"
                             

#line 41 "session.cog"
             DEREF(

#line 41 "session.cog"
         name).suffixAfterLast(

#line 41 "session.cog"
                              '/');


#line 42 "session.cog"
  name = 

#line 42 "session.cog"
                             

#line 42 "session.cog"
             DEREF(

#line 42 "session.cog"
         name).suffixAfterLast(

#line 42 "session.cog"
                              '\\');


#line 43 "session.cog"
         DEREF(

#line 43 "session.cog"
  session).moduleName2 = 

#line 43 "session.cog"
                               

#line 43 "session.cog"
                        getName(

#line 43 "session.cog"
                                session, 

#line 43 "session.cog"
                                         name);
}


#line 46 "session.cog"
 void setModulePath(

#line 47 "session.cog"
           Session session, 

#line 48 "session.cog"
        TerminatedStringSpan path)
{


#line 50 "session.cog"
               

#line 50 "session.cog"
               

#line 50 "session.cog"
  setModulePath(

#line 50 "session.cog"
                session, 

#line 50 "session.cog"
                                   

#line 50 "session.cog"
                         StringSpan(

#line 50 "session.cog"
                                    path));
}


#line 53 "session.cog"
 

#line 55 "session.cog"
        

#line 55 "session.cog"
     Ptr<

#line 55 "session.cog"
         Name>  getModulePath(

#line 54 "session.cog"
           Session session)
{


#line 57 "session.cog"
  return 

#line 57 "session.cog"
                DEREF(

#line 57 "session.cog"
         session).modulePath2;
}


#line 60 "session.cog"
 

#line 62 "session.cog"
        

#line 62 "session.cog"
     Ptr<

#line 62 "session.cog"
         Name>  getModuleName(

#line 61 "session.cog"
           Session session)
{


#line 64 "session.cog"
  return 

#line 64 "session.cog"
                DEREF(

#line 64 "session.cog"
         session).moduleName2;
}


#line 67 "session.cog"
 void setEvaluate(

#line 68 "session.cog"
           Session session)
{


#line 70 "session.cog"
         DEREF(

#line 70 "session.cog"
  session).eval = 

#line 70 "session.cog"
                 true;
}


#line 73 "session.cog"
 void loadSourceFile(

#line 74 "session.cog"
           Session session, 

#line 75 "session.cog"
        TerminatedStringSpan path)
{


#line 77 "session.cog"
  

#line 77 "session.cog"
  auto file = 

#line 77 "session.cog"
                          

#line 77 "session.cog"
             getSourceFile(

#line 77 "session.cog"
                           session, 

#line 77 "session.cog"
                                    path);


#line 78 "session.cog"
  if(

#line 78 "session.cog"
     

#line 78 "session.cog"
     !

#line 78 "session.cog"
      file)
{


#line 78 "session.cog"
            return;
}


#line 80 "session.cog"
           

#line 80 "session.cog"
           

#line 80 "session.cog"
  parseFile(

#line 80 "session.cog"
            session, 

#line 80 "session.cog"
                     file);
}


#line 83 "session.cog"
 

#line 85 "session.cog"
     Int getErrorCount(

#line 84 "session.cog"
           Session session)
{


#line 87 "session.cog"
     return 

#line 87 "session.cog"
                        DEREF(

#line 87 "session.cog"
                   DEREF(

#line 87 "session.cog"
            session).sink).errorCount;
}


#line 3 "source.cog"
 

#line 17 "source.cog"
 

#line 19 "source.cog"
 

#line 42 "source.cog"
 

#line 45 "source.cog"
        

#line 45 "source.cog"
     Ptr<

#line 45 "source.cog"
         SourceFile>  getSourceFile(

#line 43 "source.cog"
           Session session, 

#line 44 "source.cog"
        TerminatedStringSpan path)
{


#line 50 "source.cog"
  

#line 50 "source.cog"
  auto file = 

#line 50 "source.cog"
                  

#line 50 "source.cog"
             fopen(

#line 50 "source.cog"
                       DEREF(

#line 50 "source.cog"
                   path).begin, 

#line 50 "source.cog"
                               "rb");


#line 51 "source.cog"
  if(

#line 51 "source.cog"
     

#line 51 "source.cog"
     !

#line 51 "source.cog"
      file)
{


#line 55 "source.cog"
           

#line 55 "source.cog"
           

#line 55 "source.cog"
   diagnose(

#line 55 "source.cog"
            

#line 55 "source.cog"
            &

#line 55 "source.cog"
                    DEREF(

#line 55 "source.cog"
             session).sink, 

#line 55 "source.cog"
                                    

#line 55 "source.cog"
                           SourceLoc(

#line 55 "source.cog"
                                     0), 

#line 55 "source.cog"
                                         kDiagnostic_unimplemented, 

#line 55 "source.cog"
                                                                    path);


#line 57 "source.cog"
   return 

#line 57 "source.cog"
          0;
}


#line 61 "source.cog"
       

#line 61 "source.cog"
       

#line 61 "source.cog"
  fseek(

#line 61 "source.cog"
        file, 

#line 61 "source.cog"
              0, 

#line 61 "source.cog"
                 SEEK_END);


#line 62 "source.cog"
  

#line 62 "source.cog"
  auto fileSize = 

#line 62 "source.cog"
                      

#line 62 "source.cog"
                 ftell(

#line 62 "source.cog"
                       file);


#line 63 "source.cog"
       

#line 63 "source.cog"
       

#line 63 "source.cog"
  fseek(

#line 63 "source.cog"
        file, 

#line 63 "source.cog"
              0, 

#line 63 "source.cog"
                 SEEK_SET);


#line 68 "source.cog"
  

#line 68 "source.cog"
  auto pathSize = 

#line 68 "source.cog"
                          

#line 68 "source.cog"
                     DEREF(

#line 68 "source.cog"
                 path).end 

#line 68 "source.cog"
                          - 

#line 68 "source.cog"
                                DEREF(

#line 68 "source.cog"
                            path).begin;


#line 70 "source.cog"
  

#line 70 "source.cog"
  auto sourceFile = 

#line 70 "source.cog"
                   cast<

#line 70 "source.cog"
                           

#line 70 "source.cog"
                        Ptr<

#line 70 "source.cog"
                            SourceFile> >(

#line 71 "source.cog"
         

#line 71 "source.cog"
   malloc(

#line 73 "source.cog"
   

#line 72 "source.cog"
                     

#line 72 "source.cog"
         

#line 72 "source.cog"
   sizeOf<

#line 72 "source.cog"
          SourceFile> () 

#line 73 "source.cog"
   + 

#line 73 "source.cog"
              

#line 73 "source.cog"
     pathSize 

#line 73 "source.cog"
              + 

#line 74 "source.cog"
   

#line 73 "source.cog"
                1 

#line 74 "source.cog"
   + 

#line 74 "source.cog"
              

#line 74 "source.cog"
     fileSize 

#line 74 "source.cog"
              + 

#line 74 "source.cog"
                1));


#line 75 "source.cog"
     

#line 75 "source.cog"
     auto pathData = 

#line 75 "source.cog"
                    cast<

#line 75 "source.cog"
                            

#line 75 "source.cog"
                         Ptr<

#line 75 "source.cog"
                             Char> >(

#line 75 "source.cog"
                                                

#line 75 "source.cog"
                                     sourceFile 

#line 75 "source.cog"
                                                + 

#line 75 "source.cog"
                                                  1);


#line 76 "source.cog"
  

#line 76 "source.cog"
  auto fileData = 

#line 76 "source.cog"
                          

#line 76 "source.cog"
                 pathData 

#line 76 "source.cog"
                          + 

#line 76 "source.cog"
                                     

#line 76 "source.cog"
                            pathSize 

#line 76 "source.cog"
                                     + 

#line 76 "source.cog"
                                       1;


#line 78 "source.cog"
        

#line 78 "source.cog"
        

#line 78 "source.cog"
  memcpy(

#line 78 "source.cog"
         pathData, 

#line 78 "source.cog"
                       DEREF(

#line 78 "source.cog"
                   path).begin, 

#line 78 "source.cog"
                               pathSize);


#line 79 "source.cog"
          

#line 79 "source.cog"
  pathData[

#line 79 "source.cog"
           pathSize] = 

#line 79 "source.cog"
                       0;


#line 81 "source.cog"
       

#line 81 "source.cog"
       

#line 81 "source.cog"
  fread(

#line 81 "source.cog"
        fileData, 

#line 81 "source.cog"
                  fileSize, 

#line 81 "source.cog"
                            1, 

#line 81 "source.cog"
                               file);


#line 82 "source.cog"
           

#line 82 "source.cog"
           

#line 82 "source.cog"
     fclose(

#line 82 "source.cog"
            file);


#line 83 "source.cog"
          

#line 83 "source.cog"
  fileData[

#line 83 "source.cog"
           fileSize] = 

#line 83 "source.cog"
                       0;


#line 86 "source.cog"
            DEREF(

#line 86 "source.cog"
  sourceFile).path = 

#line 86 "source.cog"
                                        

#line 86 "source.cog"
                    TerminatedStringSpan(

#line 86 "source.cog"
                                         pathData, 

#line 86 "source.cog"
                                                            

#line 86 "source.cog"
                                                   pathData 

#line 86 "source.cog"
                                                            + 

#line 86 "source.cog"
                                                              pathSize);


#line 87 "source.cog"
            DEREF(

#line 87 "source.cog"
  sourceFile).text = 

#line 87 "source.cog"
                                        

#line 87 "source.cog"
                    TerminatedStringSpan(

#line 87 "source.cog"
                                         fileData, 

#line 87 "source.cog"
                                                            

#line 87 "source.cog"
                                                   fileData 

#line 87 "source.cog"
                                                            + 

#line 87 "source.cog"
                                                              fileSize);


#line 88 "source.cog"
                     DEREF(

#line 88 "source.cog"
            DEREF(

#line 88 "source.cog"
  sourceFile).firstLoc).raw = 

#line 88 "source.cog"
                                                  

#line 88 "source.cog"
                                   DEREF(

#line 88 "source.cog"
                            session).lastSourceLoc 

#line 88 "source.cog"
                                                  + 

#line 88 "source.cog"
                                                    1;


#line 89 "source.cog"
                    DEREF(

#line 89 "source.cog"
            DEREF(

#line 89 "source.cog"
  sourceFile).lastLoc).raw = 

#line 89 "source.cog"
                                                   

#line 89 "source.cog"
                                              DEREF(

#line 89 "source.cog"
                                     DEREF(

#line 89 "source.cog"
                           sourceFile).firstLoc).raw 

#line 89 "source.cog"
                                                   + 

#line 89 "source.cog"
                                                              

#line 89 "source.cog"
                                                     fileSize 

#line 89 "source.cog"
                                                              + 

#line 89 "source.cog"
                                                                1;


#line 91 "source.cog"
         DEREF(

#line 91 "source.cog"
  session).lastSourceLoc = 

#line 91 "source.cog"
                                            DEREF(

#line 91 "source.cog"
                                    DEREF(

#line 91 "source.cog"
                          sourceFile).lastLoc).raw;


#line 93 "source.cog"
            DEREF(

#line 93 "source.cog"
  sourceFile).next = 

#line 93 "source.cog"
                           DEREF(

#line 93 "source.cog"
                    session).sourceFiles;


#line 94 "source.cog"
         DEREF(

#line 94 "source.cog"
  session).sourceFiles = 

#line 94 "source.cog"
                        sourceFile;


#line 96 "source.cog"
  return 

#line 96 "source.cog"
         sourceFile;
}


#line 99 "source.cog"
 

#line 102 "source.cog"
     ExpandedSourceLoc expandLoc(

#line 100 "source.cog"
           Session session, 

#line 101 "source.cog"
       SourceLoc loc)
{


#line 104 "source.cog"
  

#line 104 "source.cog"
  

#line 104 "source.cog"
                 ExpandedSourceLoc expanded;


#line 105 "source.cog"
  if(

#line 105 "source.cog"
             

#line 105 "source.cog"
        DEREF(

#line 105 "source.cog"
     loc).raw 

#line 105 "source.cog"
             == 

#line 105 "source.cog"
                0)
{


#line 107 "source.cog"
           DEREF(

#line 107 "source.cog"
   expanded).file = 

#line 107 "source.cog"
                                       

#line 107 "source.cog"
                   TerminatedStringSpan(

#line 107 "source.cog"
                                        "");


#line 108 "source.cog"
           DEREF(

#line 108 "source.cog"
   expanded).line = 

#line 108 "source.cog"
                   0;


#line 109 "source.cog"
           DEREF(

#line 109 "source.cog"
   expanded).column = 

#line 109 "source.cog"
                     0;


#line 110 "source.cog"
   return 

#line 110 "source.cog"
          expanded;
}


#line 115 "source.cog"
  {


#line 115 "source.cog"
      

#line 115 "source.cog"
      auto f = 

#line 115 "source.cog"
                     DEREF(

#line 115 "source.cog"
              session).sourceFiles;
for(;

#line 115 "source.cog"
                                   f;

#line 115 "source.cog"
                                      f = 

#line 115 "source.cog"
                                           DEREF(

#line 115 "source.cog"
                                          f).next)
{
{


#line 117 "source.cog"
   if(

#line 117 "source.cog"
              

#line 117 "source.cog"
         DEREF(

#line 117 "source.cog"
      loc).raw 

#line 117 "source.cog"
              < 

#line 117 "source.cog"
                          DEREF(

#line 117 "source.cog"
                 DEREF(

#line 117 "source.cog"
                f).firstLoc).raw)
{


#line 118 "source.cog"
    continue;
}


#line 120 "source.cog"
   if(

#line 120 "source.cog"
              

#line 120 "source.cog"
         DEREF(

#line 120 "source.cog"
      loc).raw 

#line 120 "source.cog"
              > 

#line 120 "source.cog"
                         DEREF(

#line 120 "source.cog"
                 DEREF(

#line 120 "source.cog"
                f).lastLoc).raw)
{


#line 121 "source.cog"
    continue;
}


#line 123 "source.cog"
   

#line 123 "source.cog"
   auto line = 

#line 123 "source.cog"
              1;


#line 124 "source.cog"
   

#line 124 "source.cog"
   auto column = 

#line 124 "source.cog"
                1;


#line 125 "source.cog"
   

#line 125 "source.cog"
   auto cursor = 

#line 125 "source.cog"
                      DEREF(

#line 125 "source.cog"
                 DEREF(

#line 125 "source.cog"
                f).text).begin;


#line 126 "source.cog"
   

#line 126 "source.cog"
   auto offset = 

#line 126 "source.cog"
                        

#line 126 "source.cog"
                   DEREF(

#line 126 "source.cog"
                loc).raw 

#line 126 "source.cog"
                        - 

#line 126 "source.cog"
                                    DEREF(

#line 126 "source.cog"
                           DEREF(

#line 126 "source.cog"
                          f).firstLoc).raw;


#line 127 "source.cog"
   {


#line 127 "source.cog"
       

#line 127 "source.cog"
       auto ii = 

#line 127 "source.cog"
                0;
for(;

#line 127 "source.cog"
                      

#line 127 "source.cog"
                   ii 

#line 127 "source.cog"
                      < 

#line 127 "source.cog"
                        offset;

#line 127 "source.cog"
                                

#line 127 "source.cog"
                                ++

#line 127 "source.cog"
                                  ii)
{
{


#line 129 "source.cog"
    

#line 129 "source.cog"
    auto c = 

#line 129 "source.cog"
            

#line 129 "source.cog"
            *

#line 129 "source.cog"
             cursor;


#line 130 "source.cog"
    switch(

#line 130 "source.cog"
           c)
{
case 

#line 132 "source.cog"
         '\r':
case 

#line 132 "source.cog"
                    '\n':
{
{


#line 134 "source.cog"
      

#line 134 "source.cog"
      auto d = 

#line 134 "source.cog"
                    

#line 134 "source.cog"
              cursor[

#line 134 "source.cog"
                     1];


#line 135 "source.cog"
      if(

#line 135 "source.cog"
                 

#line 135 "source.cog"
         (

#line 135 "source.cog"
            

#line 135 "source.cog"
          c 

#line 135 "source.cog"
            ^ 

#line 135 "source.cog"
              d) 

#line 135 "source.cog"
                 == 

#line 135 "source.cog"
                    (

#line 135 "source.cog"
                          

#line 135 "source.cog"
                     '\r' 

#line 135 "source.cog"
                          ^ 

#line 135 "source.cog"
                            '\n'))
{


#line 137 "source.cog"
                           

#line 137 "source.cog"
                           

#line 137 "source.cog"
                         ii

#line 137 "source.cog"
                           ++;


#line 138 "source.cog"
             

#line 138 "source.cog"
             

#line 138 "source.cog"
       cursor

#line 138 "source.cog"
             ++;
}


#line 140 "source.cog"
          

#line 140 "source.cog"
          

#line 140 "source.cog"
      line

#line 140 "source.cog"
          ++;


#line 141 "source.cog"
      column = 

#line 141 "source.cog"
               1;
}
}
{


#line 143 "source.cog"
     break;
}
default:
{


#line 146 "source.cog"
           

#line 146 "source.cog"
           

#line 146 "source.cog"
     column

#line 146 "source.cog"
           ++;
}
{


#line 147 "source.cog"
     break;
}
}


#line 149 "source.cog"
          

#line 149 "source.cog"
          

#line 149 "source.cog"
    cursor

#line 149 "source.cog"
          ++;
}
}}


#line 152 "source.cog"
           DEREF(

#line 152 "source.cog"
   expanded).file = 

#line 152 "source.cog"
                    DEREF(

#line 152 "source.cog"
                   f).path;


#line 153 "source.cog"
           DEREF(

#line 153 "source.cog"
   expanded).line = 

#line 153 "source.cog"
                   line;


#line 154 "source.cog"
           DEREF(

#line 154 "source.cog"
   expanded).column = 

#line 154 "source.cog"
                     column;


#line 155 "source.cog"
   return 

#line 155 "source.cog"
          expanded;
}
}}


#line 159 "source.cog"
           

#line 159 "source.cog"
           

#line 159 "source.cog"
  cogAssert(

#line 159 "source.cog"
            false);


#line 160 "source.cog"
  return 

#line 160 "source.cog"
         expanded;
}


#line 3 "string.cog"
 

#line 70 "string.cog"
 

#line 70 "string.cog"
                                                 Bool operator==(

#line 70 "string.cog"
               StringSpan left, 

#line 70 "string.cog"
                                  StringSpan right)
{


#line 72 "string.cog"
  

#line 72 "string.cog"
  auto leftSize = 

#line 72 "string.cog"
                               

#line 72 "string.cog"
                     DEREF(

#line 72 "string.cog"
                 left).getLength();


#line 73 "string.cog"
  

#line 73 "string.cog"
  auto rightSize = 

#line 73 "string.cog"
                                 

#line 73 "string.cog"
                       DEREF(

#line 73 "string.cog"
                  right).getLength();


#line 75 "string.cog"
  if(

#line 75 "string.cog"
              

#line 75 "string.cog"
     leftSize 

#line 75 "string.cog"
              != 

#line 75 "string.cog"
                 rightSize)
{


#line 76 "string.cog"
   return 

#line 76 "string.cog"
          false;
}


#line 78 "string.cog"
  return 

#line 78 "string.cog"
                                                   

#line 78 "string.cog"
               

#line 78 "string.cog"
         memcmp(

#line 78 "string.cog"
                    DEREF(

#line 78 "string.cog"
                left).begin, 

#line 78 "string.cog"
                                 DEREF(

#line 78 "string.cog"
                            right).begin, 

#line 78 "string.cog"
                                         leftSize) 

#line 78 "string.cog"
                                                   == 

#line 78 "string.cog"
                                                      0;
}


#line 81 "string.cog"
 

#line 81 "string.cog"
                                                 Bool operator!=(

#line 81 "string.cog"
               StringSpan left, 

#line 81 "string.cog"
                                  StringSpan right)
{


#line 83 "string.cog"
  return 

#line 83 "string.cog"
         

#line 83 "string.cog"
         !

#line 83 "string.cog"
          (

#line 83 "string.cog"
                

#line 83 "string.cog"
           left 

#line 83 "string.cog"
                == 

#line 83 "string.cog"
                   right);
}


#line 3 "syntax.cog"
 

#line 18 "syntax.cog"
 

#line 18 "syntax.cog"
                                  Bool asBool(

#line 18 "syntax.cog"
                      TypeExp typeExp)
{


#line 20 "syntax.cog"
  return 

#line 20 "syntax.cog"
                DEREF(

#line 20 "syntax.cog"
         typeExp).exp;
}


#line 23 "syntax.cog"
 

#line 27 "syntax.cog"
  template<typename T > SyntaxListIterator<T > ::SyntaxListIterator(

#line 28 "syntax.cog"
            T current)
{


#line 30 "syntax.cog"
       DEREF(

#line 30 "syntax.cog"
   this).current = 

#line 30 "syntax.cog"
                  current;
}


#line 33 "syntax.cog"
  template<typename T > 

#line 33 "syntax.cog"
              T SyntaxListIterator<T > ::operator*()
{


#line 35 "syntax.cog"
   return 

#line 35 "syntax.cog"
          current;
}


#line 38 "syntax.cog"
  template<typename T > void SyntaxListIterator<T > ::operator++()
{


#line 40 "syntax.cog"
   current = 

#line 40 "syntax.cog"
             cast<

#line 40 "syntax.cog"
                  T>(

#line 40 "syntax.cog"
                            DEREF(

#line 40 "syntax.cog"
                     current).next);
}


#line 44 "syntax.cog"
 

#line 44 "syntax.cog"
      template<typename T > 

#line 47 "syntax.cog"
     Bool operator!=(

#line 45 "syntax.cog"
                          

#line 45 "syntax.cog"
        SyntaxListIterator<

#line 45 "syntax.cog"
                           T>  left, 

#line 46 "syntax.cog"
                           

#line 46 "syntax.cog"
         SyntaxListIterator<

#line 46 "syntax.cog"
                            T>  right)
{


#line 49 "syntax.cog"
  return 

#line 49 "syntax.cog"
                      

#line 49 "syntax.cog"
             DEREF(

#line 49 "syntax.cog"
         left).current 

#line 49 "syntax.cog"
                      != 

#line 49 "syntax.cog"
                              DEREF(

#line 49 "syntax.cog"
                         right).current;
}


#line 52 "syntax.cog"
 

#line 57 "syntax.cog"
  template<typename T, typename U > FilteredArrayIter<T, U > ::FilteredArrayIter(

#line 57 "syntax.cog"
                 

#line 57 "syntax.cog"
                U

#line 57 "syntax.cog"
                 * current, 

#line 57 "syntax.cog"
                          

#line 57 "syntax.cog"
                         U

#line 57 "syntax.cog"
                          * end)
{


#line 59 "syntax.cog"
       DEREF(

#line 59 "syntax.cog"
   this).end = 

#line 59 "syntax.cog"
              end;


#line 60 "syntax.cog"
       DEREF(

#line 60 "syntax.cog"
   this).current = 

#line 60 "syntax.cog"
                        

#line 60 "syntax.cog"
                  adjust(

#line 60 "syntax.cog"
                         current);
}


#line 63 "syntax.cog"
  template<typename T, typename U > 

#line 63 "syntax.cog"
                                            Bool FilteredArrayIter<T, U > ::operator!=(

#line 63 "syntax.cog"
                                  

#line 63 "syntax.cog"
                 FilteredArrayIter<

#line 63 "syntax.cog"
                                   T, 

#line 63 "syntax.cog"
                                     U>  other)
{


#line 65 "syntax.cog"
         return 

#line 65 "syntax.cog"
                        

#line 65 "syntax.cog"
                current 

#line 65 "syntax.cog"
                        != 

#line 65 "syntax.cog"
                                DEREF(

#line 65 "syntax.cog"
                           other).current;
}


#line 68 "syntax.cog"
     template<typename T, typename U > 

#line 68 "syntax.cog"
                 T FilteredArrayIter<T, U > ::operator*()
{


#line 68 "syntax.cog"
                     return 

#line 68 "syntax.cog"
                            

#line 68 "syntax.cog"
                            *

#line 68 "syntax.cog"
                             current;
}


#line 70 "syntax.cog"
  template<typename T, typename U > void FilteredArrayIter<T, U > ::operator++()
{


#line 72 "syntax.cog"
         current = 

#line 72 "syntax.cog"
                         

#line 72 "syntax.cog"
                   adjust(

#line 72 "syntax.cog"
                          cast<

#line 72 "syntax.cog"
                                  

#line 72 "syntax.cog"
                               Ptr<

#line 72 "syntax.cog"
                                   U> >(

#line 72 "syntax.cog"
                                                

#line 72 "syntax.cog"
                                        current 

#line 72 "syntax.cog"
                                                + 

#line 72 "syntax.cog"
                                                  1));
}


#line 75 "syntax.cog"
  template<typename T, typename U > 

#line 75 "syntax.cog"
                           

#line 75 "syntax.cog"
                          T

#line 75 "syntax.cog"
                           * FilteredArrayIter<T, U > ::adjust(

#line 75 "syntax.cog"
                    

#line 75 "syntax.cog"
                   U

#line 75 "syntax.cog"
                    * obj)
{


#line 77 "syntax.cog"
   while(

#line 77 "syntax.cog"
             

#line 77 "syntax.cog"
         obj 

#line 77 "syntax.cog"
             != 

#line 77 "syntax.cog"
                end)
{
{


#line 79 "syntax.cog"
    

#line 79 "syntax.cog"
    auto t = 

#line 79 "syntax.cog"
                 

#line 79 "syntax.cog"
              

#line 79 "syntax.cog"
            as<

#line 79 "syntax.cog"
               T> (

#line 79 "syntax.cog"
                  

#line 79 "syntax.cog"
                  *

#line 79 "syntax.cog"
                   obj);


#line 80 "syntax.cog"
    if(

#line 80 "syntax.cog"
       t)
{


#line 81 "syntax.cog"
     return 

#line 81 "syntax.cog"
            cast<

#line 81 "syntax.cog"
                    

#line 81 "syntax.cog"
                 Ptr<

#line 81 "syntax.cog"
                     T> >(

#line 81 "syntax.cog"
                          obj);
}


#line 82 "syntax.cog"
    obj = 

#line 82 "syntax.cog"
              

#line 82 "syntax.cog"
          obj 

#line 82 "syntax.cog"
              + 

#line 82 "syntax.cog"
                1;
}
}


#line 84 "syntax.cog"
   return 

#line 84 "syntax.cog"
          cast<

#line 84 "syntax.cog"
                  

#line 84 "syntax.cog"
               Ptr<

#line 84 "syntax.cog"
                   T> >(

#line 84 "syntax.cog"
                        end);
}


#line 90 "syntax.cog"
 

#line 96 "syntax.cog"
  template<typename T, typename U > 

#line 96 "syntax.cog"
                                   

#line 96 "syntax.cog"
                  FilteredArrayIter<

#line 96 "syntax.cog"
                                    T, 

#line 96 "syntax.cog"
                                      U>  FilteredArray<T, U > ::begin()
{


#line 98 "syntax.cog"
   return 

#line 98 "syntax.cog"
                                

#line 98 "syntax.cog"
                           

#line 98 "syntax.cog"
          FilteredArrayIter<

#line 98 "syntax.cog"
                            T, 

#line 98 "syntax.cog"
                              U> (

#line 98 "syntax.cog"
                                 beginPtr, 

#line 98 "syntax.cog"
                                           endPtr);
}


#line 101 "syntax.cog"
  template<typename T, typename U > 

#line 101 "syntax.cog"
                                 

#line 101 "syntax.cog"
                FilteredArrayIter<

#line 101 "syntax.cog"
                                  T, 

#line 101 "syntax.cog"
                                    U>  FilteredArray<T, U > ::end()
{


#line 103 "syntax.cog"
   return 

#line 103 "syntax.cog"
                                

#line 103 "syntax.cog"
                           

#line 103 "syntax.cog"
          FilteredArrayIter<

#line 103 "syntax.cog"
                            T, 

#line 103 "syntax.cog"
                              U> (

#line 103 "syntax.cog"
                                 endPtr, 

#line 103 "syntax.cog"
                                         endPtr);
}


#line 106 "syntax.cog"
  template<typename T, typename U > FilteredArray<T, U > ::FilteredArray()
{


#line 108 "syntax.cog"
       DEREF(

#line 108 "syntax.cog"
   this).beginPtr = 

#line 108 "syntax.cog"
                   nullptr;


#line 109 "syntax.cog"
       DEREF(

#line 109 "syntax.cog"
   this).endPtr = 

#line 109 "syntax.cog"
                 nullptr;
}


#line 112 "syntax.cog"
  template<typename T, typename U > FilteredArray<T, U > ::FilteredArray(

#line 112 "syntax.cog"
                  

#line 112 "syntax.cog"
                 U

#line 112 "syntax.cog"
                  * beginPtr, 

#line 112 "syntax.cog"
                              

#line 112 "syntax.cog"
                             U

#line 112 "syntax.cog"
                              * endPtr)
{


#line 114 "syntax.cog"
       DEREF(

#line 114 "syntax.cog"
   this).beginPtr = 

#line 114 "syntax.cog"
                   beginPtr;


#line 115 "syntax.cog"
       DEREF(

#line 115 "syntax.cog"
   this).endPtr = 

#line 115 "syntax.cog"
                 endPtr;
}


#line 118 "syntax.cog"
  template<typename T, typename U > FilteredArray<T, U > ::FilteredArray(

#line 118 "syntax.cog"
                     

#line 118 "syntax.cog"
             ConstRef<

#line 118 "syntax.cog"
                           

#line 118 "syntax.cog"
                      Array<

#line 118 "syntax.cog"
                            U> >  list)
{


#line 120 "syntax.cog"
       DEREF(

#line 120 "syntax.cog"
   this).beginPtr = 

#line 120 "syntax.cog"
                             

#line 120 "syntax.cog"
                       DEREF(

#line 120 "syntax.cog"
                   list).begin();


#line 121 "syntax.cog"
       DEREF(

#line 121 "syntax.cog"
   this).endPtr = 

#line 121 "syntax.cog"
                         

#line 121 "syntax.cog"
                     DEREF(

#line 121 "syntax.cog"
                 list).end();
}


#line 125 "syntax.cog"
 

#line 130 "syntax.cog"
 

#line 134 "syntax.cog"
 

#line 139 "syntax.cog"
 

#line 144 "syntax.cog"
 

#line 148 "syntax.cog"
  

#line 148 "syntax.cog"
                                              Attr StmtImpl::findAttrImpl(

#line 148 "syntax.cog"
                                  

#line 148 "syntax.cog"
                               Ptr<

#line 148 "syntax.cog"
                                   Class>  attrClass)
{


#line 150 "syntax.cog"
   for(auto a : 

#line 150 "syntax.cog"
                attrs)
{
{


#line 153 "syntax.cog"
    

#line 153 "syntax.cog"
    auto match = 

#line 153 "syntax.cog"
                  

#line 153 "syntax.cog"
                as(

#line 153 "syntax.cog"
                   a, 

#line 153 "syntax.cog"
                      attrClass);


#line 154 "syntax.cog"
    if(

#line 154 "syntax.cog"
       match)
{


#line 155 "syntax.cog"
     return 

#line 155 "syntax.cog"
            cast<

#line 155 "syntax.cog"
                 Attr>(

#line 155 "syntax.cog"
                       match);
}
}
}


#line 157 "syntax.cog"
   return 

#line 157 "syntax.cog"
          nullptr;
}


#line 160 "syntax.cog"
  

#line 160 "syntax.cog"
       template<typename T > 

#line 160 "syntax.cog"
                        T StmtImpl::findAttr()
{


#line 162 "syntax.cog"
   return 

#line 162 "syntax.cog"
          cast<

#line 162 "syntax.cog"
               T>(

#line 162 "syntax.cog"
                              

#line 162 "syntax.cog"
                  findAttrImpl(

#line 162 "syntax.cog"
                                          

#line 162 "syntax.cog"
                                       

#line 162 "syntax.cog"
                               getClass<

#line 162 "syntax.cog"
                                        T> ()));
}


#line 174 "syntax.cog"
 

#line 180 "syntax.cog"
  

#line 180 "syntax.cog"
                      ContainerStmt DeclImpl::getParent()
{


#line 182 "syntax.cog"
   return 

#line 182 "syntax.cog"
          parent;
}


#line 186 "syntax.cog"
 

#line 192 "syntax.cog"
 

#line 199 "syntax.cog"
 

#line 210 "syntax.cog"
 

#line 214 "syntax.cog"
 

#line 218 "syntax.cog"
  

#line 218 "syntax.cog"
                          

#line 218 "syntax.cog"
                     Array<

#line 218 "syntax.cog"
                           Stmt>  ContainerStmtImpl::getStmts()
{


#line 220 "syntax.cog"
   return 

#line 220 "syntax.cog"
          stmts;
}


#line 223 "syntax.cog"
  

#line 223 "syntax.cog"
                                  

#line 223 "syntax.cog"
                     FilteredArray<

#line 223 "syntax.cog"
                                   Decl, 

#line 223 "syntax.cog"
                                         Stmt>  ContainerStmtImpl::getDecls()
{


#line 225 "syntax.cog"
   return 

#line 225 "syntax.cog"
                                   

#line 225 "syntax.cog"
                       

#line 225 "syntax.cog"
          FilteredArray<

#line 225 "syntax.cog"
                        Decl, 

#line 225 "syntax.cog"
                              Stmt> (

#line 225 "syntax.cog"
                                    stmts);
}


#line 229 "syntax.cog"
 

#line 233 "syntax.cog"
  

#line 233 "syntax.cog"
                        

#line 233 "syntax.cog"
                     Ref<

#line 233 "syntax.cog"
                              

#line 233 "syntax.cog"
                         Array<

#line 233 "syntax.cog"
                               Decl> >  ContainerDeclImpl::getDecls()
{


#line 233 "syntax.cog"
                                         return 

#line 233 "syntax.cog"
                                                

#line 233 "syntax.cog"
                                                *

#line 233 "syntax.cog"
                                                 cast<

#line 233 "syntax.cog"
                                                         

#line 233 "syntax.cog"
                                                      Ptr<

#line 233 "syntax.cog"
                                                               

#line 233 "syntax.cog"
                                                          Array<

#line 233 "syntax.cog"
                                                                Decl> > >(

#line 233 "syntax.cog"
                                                                          

#line 233 "syntax.cog"
                                                                          &

#line 233 "syntax.cog"
                                                                           stmts);
}


#line 236 "syntax.cog"
 

#line 242 "syntax.cog"
  template<typename T > DeclRefListIterator<T > ::DeclRefListIterator(

#line 243 "syntax.cog"
                 

#line 243 "syntax.cog"
             Decl

#line 243 "syntax.cog"
                 * current, 

#line 244 "syntax.cog"
             

#line 244 "syntax.cog"
         Decl

#line 244 "syntax.cog"
             * end, 

#line 245 "syntax.cog"
                    Specializations specializations)
{


#line 247 "syntax.cog"
       DEREF(

#line 247 "syntax.cog"
   this).current = 

#line 247 "syntax.cog"
                  current;


#line 248 "syntax.cog"
       DEREF(

#line 248 "syntax.cog"
   this).end = 

#line 248 "syntax.cog"
              end;


#line 249 "syntax.cog"
       DEREF(

#line 249 "syntax.cog"
   this).specializations = 

#line 249 "syntax.cog"
                          specializations;


#line 251 "syntax.cog"
         

#line 251 "syntax.cog"
         

#line 251 "syntax.cog"
   adjust();
}


#line 254 "syntax.cog"
  template<typename T > void DeclRefListIterator<T > ::operator++()
{


#line 256 "syntax.cog"
   if(

#line 256 "syntax.cog"
              

#line 256 "syntax.cog"
      current 

#line 256 "syntax.cog"
              == 

#line 256 "syntax.cog"
                 end)
{


#line 257 "syntax.cog"
    return;
}


#line 258 "syntax.cog"
   current = 

#line 258 "syntax.cog"
                     

#line 258 "syntax.cog"
             current 

#line 258 "syntax.cog"
                     + 

#line 258 "syntax.cog"
                       1;


#line 259 "syntax.cog"
         

#line 259 "syntax.cog"
         

#line 259 "syntax.cog"
   adjust();
}


#line 262 "syntax.cog"
  template<typename T > 

#line 262 "syntax.cog"
                            

#line 262 "syntax.cog"
              DeclRefValImpl<

#line 262 "syntax.cog"
                             T>  DeclRefListIterator<T > ::operator*()
{


#line 264 "syntax.cog"
   return 

#line 264 "syntax.cog"
                           

#line 264 "syntax.cog"
                        

#line 264 "syntax.cog"
          DeclRefValImpl<

#line 264 "syntax.cog"
                         T> (

#line 265 "syntax.cog"
    cast<

#line 265 "syntax.cog"
         T>(

#line 265 "syntax.cog"
            

#line 265 "syntax.cog"
            *

#line 265 "syntax.cog"
             current), 

#line 266 "syntax.cog"
    specializations);
}


#line 269 "syntax.cog"
  template<typename T > void DeclRefListIterator<T > ::adjust()
{


#line 271 "syntax.cog"
   while(

#line 271 "syntax.cog"
                 

#line 271 "syntax.cog"
         current 

#line 271 "syntax.cog"
                 != 

#line 271 "syntax.cog"
                    end)
{
{


#line 273 "syntax.cog"
    

#line 273 "syntax.cog"
    auto declAsT = 

#line 273 "syntax.cog"
                       

#line 273 "syntax.cog"
                    

#line 273 "syntax.cog"
                  as<

#line 273 "syntax.cog"
                     T> (

#line 273 "syntax.cog"
                        

#line 273 "syntax.cog"
                        *

#line 273 "syntax.cog"
                         current);


#line 274 "syntax.cog"
    if(

#line 274 "syntax.cog"
       declAsT)
{


#line 275 "syntax.cog"
     return;
}


#line 277 "syntax.cog"
    current = 

#line 277 "syntax.cog"
                      

#line 277 "syntax.cog"
              current 

#line 277 "syntax.cog"
                      + 

#line 277 "syntax.cog"
                        1;
}
}
}


#line 282 "syntax.cog"
 

#line 287 "syntax.cog"
  template<typename T > 

#line 287 "syntax.cog"
                                     

#line 287 "syntax.cog"
                  DeclRefListIterator<

#line 287 "syntax.cog"
                                      T>  DeclRefList<T > ::begin()
{


#line 289 "syntax.cog"
   return 

#line 289 "syntax.cog"
                                

#line 289 "syntax.cog"
                             

#line 289 "syntax.cog"
          DeclRefListIterator<

#line 289 "syntax.cog"
                              T> (

#line 289 "syntax.cog"
                                            

#line 289 "syntax.cog"
                                      DEREF(

#line 289 "syntax.cog"
                                 decls).begin(), 

#line 289 "syntax.cog"
                                                         

#line 289 "syntax.cog"
                                                     DEREF(

#line 289 "syntax.cog"
                                                decls).end(), 

#line 289 "syntax.cog"
                                                             specializations);
}


#line 292 "syntax.cog"
  template<typename T > 

#line 292 "syntax.cog"
                                   

#line 292 "syntax.cog"
                DeclRefListIterator<

#line 292 "syntax.cog"
                                    T>  DeclRefList<T > ::end()
{


#line 294 "syntax.cog"
   return 

#line 294 "syntax.cog"
                                

#line 294 "syntax.cog"
                             

#line 294 "syntax.cog"
          DeclRefListIterator<

#line 294 "syntax.cog"
                              T> (

#line 294 "syntax.cog"
                                          

#line 294 "syntax.cog"
                                      DEREF(

#line 294 "syntax.cog"
                                 decls).end(), 

#line 294 "syntax.cog"
                                                       

#line 294 "syntax.cog"
                                                   DEREF(

#line 294 "syntax.cog"
                                              decls).end(), 

#line 294 "syntax.cog"
                                                           specializations);
}


#line 297 "syntax.cog"
  template<typename T > DeclRefList<T > ::DeclRefList()
{


#line 299 "syntax.cog"
       DEREF(

#line 299 "syntax.cog"
   this).decls = 

#line 299 "syntax.cog"
                           

#line 299 "syntax.cog"
                     

#line 299 "syntax.cog"
                Array<

#line 299 "syntax.cog"
                      Decl> ();


#line 300 "syntax.cog"
       DEREF(

#line 300 "syntax.cog"
   this).specializations = 

#line 300 "syntax.cog"
                          nullptr;
}


#line 303 "syntax.cog"
  template<typename T > DeclRefList<T > ::DeclRefList(

#line 303 "syntax.cog"
                   

#line 303 "syntax.cog"
              Array<

#line 303 "syntax.cog"
                    Decl>  decls, 

#line 303 "syntax.cog"
                                            Specializations specializations)
{


#line 305 "syntax.cog"
       DEREF(

#line 305 "syntax.cog"
   this).decls = 

#line 305 "syntax.cog"
                decls;


#line 306 "syntax.cog"
       DEREF(

#line 306 "syntax.cog"
   this).specializations = 

#line 306 "syntax.cog"
                          specializations;
}


#line 310 "syntax.cog"
 

#line 310 "syntax.cog"
      template<typename T > 

#line 312 "syntax.cog"
                                    Bool operator!=(

#line 311 "syntax.cog"
                           

#line 311 "syntax.cog"
        DeclRefListIterator<

#line 311 "syntax.cog"
                            T>  left, 

#line 312 "syntax.cog"
                            

#line 312 "syntax.cog"
         DeclRefListIterator<

#line 312 "syntax.cog"
                             T>  right)
{


#line 314 "syntax.cog"
  return 

#line 314 "syntax.cog"
                      

#line 314 "syntax.cog"
             DEREF(

#line 314 "syntax.cog"
         left).current 

#line 314 "syntax.cog"
                      != 

#line 314 "syntax.cog"
                              DEREF(

#line 314 "syntax.cog"
                         right).current;
}


#line 317 "syntax.cog"
 

#line 318 "syntax.cog"
                

#line 318 "syntax.cog"
     DeclRefList<

#line 318 "syntax.cog"
                 Decl>  getDecls(

#line 317 "syntax.cog"
                                        

#line 317 "syntax.cog"
                          DeclRefValImpl<

#line 317 "syntax.cog"
                                         ContainerDecl>  container)
{


#line 320 "syntax.cog"
  return 

#line 320 "syntax.cog"
                          

#line 320 "syntax.cog"
                    

#line 320 "syntax.cog"
         DeclRefList<

#line 320 "syntax.cog"
                     Decl> (

#line 321 "syntax.cog"
                               

#line 321 "syntax.cog"
                      DEREF(

#line 321 "syntax.cog"
                    

#line 321 "syntax.cog"
            DEREF(

#line 321 "syntax.cog"
   container).getDecl()).getDecls(), 

#line 322 "syntax.cog"
            DEREF(

#line 322 "syntax.cog"
   container).specializations);
}


#line 325 "syntax.cog"
 

#line 330 "syntax.cog"
 

#line 331 "syntax.cog"
     DeclRefVal getInner(

#line 330 "syntax.cog"
                                      

#line 330 "syntax.cog"
                        DeclRefValImpl<

#line 330 "syntax.cog"
                                       GenericDecl>  declRef)
{


#line 333 "syntax.cog"
  return 

#line 333 "syntax.cog"
                   

#line 333 "syntax.cog"
         DeclRefVal(

#line 334 "syntax.cog"
                    DEREF(

#line 334 "syntax.cog"
                  

#line 334 "syntax.cog"
          DEREF(

#line 334 "syntax.cog"
   declRef).getDecl()).inner, 

#line 335 "syntax.cog"
          DEREF(

#line 335 "syntax.cog"
   declRef).specializations);
}


#line 338 "syntax.cog"
 

#line 344 "syntax.cog"
 

#line 352 "syntax.cog"
 

#line 356 "syntax.cog"
 

#line 358 "syntax.cog"
     Type getBoundType(

#line 357 "syntax.cog"
                         

#line 357 "syntax.cog"
           DeclRefValImpl<

#line 357 "syntax.cog"
                          GenericParamDecl>  declRef)
{


#line 360 "syntax.cog"
  return 

#line 360 "syntax.cog"
                       

#line 360 "syntax.cog"
         specializeType(

#line 361 "syntax.cog"
                          DEREF(

#line 361 "syntax.cog"
                    DEREF(

#line 361 "syntax.cog"
                  

#line 361 "syntax.cog"
          DEREF(

#line 361 "syntax.cog"
   declRef).getDecl()).bound).type, 

#line 362 "syntax.cog"
          DEREF(

#line 362 "syntax.cog"
   declRef).specializations);
}


#line 365 "syntax.cog"
 

#line 369 "syntax.cog"
 

#line 373 "syntax.cog"
 

#line 377 "syntax.cog"
 

#line 382 "syntax.cog"
 

#line 386 "syntax.cog"
 

#line 390 "syntax.cog"
 

#line 396 "syntax.cog"
 

#line 398 "syntax.cog"
     Type getResultType(

#line 397 "syntax.cog"
                         

#line 397 "syntax.cog"
           DeclRefValImpl<

#line 397 "syntax.cog"
                          FuncDeclBase>  declRef)
{


#line 400 "syntax.cog"
  return 

#line 400 "syntax.cog"
                       

#line 400 "syntax.cog"
         specializeType(

#line 401 "syntax.cog"
                               DEREF(

#line 401 "syntax.cog"
                    DEREF(

#line 401 "syntax.cog"
                  

#line 401 "syntax.cog"
          DEREF(

#line 401 "syntax.cog"
   declRef).getDecl()).resultType).type, 

#line 402 "syntax.cog"
          DEREF(

#line 402 "syntax.cog"
   declRef).specializations);
}


#line 405 "syntax.cog"
 

#line 409 "syntax.cog"
 

#line 413 "syntax.cog"
 

#line 417 "syntax.cog"
 

#line 423 "syntax.cog"
 

#line 423 "syntax.cog"
                                                       Type getType(

#line 423 "syntax.cog"
                                     

#line 423 "syntax.cog"
                       DeclRefValImpl<

#line 423 "syntax.cog"
                                      VarDeclBase>  declRef)
{


#line 425 "syntax.cog"
  return 

#line 425 "syntax.cog"
                       

#line 425 "syntax.cog"
         specializeType(

#line 426 "syntax.cog"
                         DEREF(

#line 426 "syntax.cog"
                    DEREF(

#line 426 "syntax.cog"
                  

#line 426 "syntax.cog"
          DEREF(

#line 426 "syntax.cog"
   declRef).getDecl()).type).type, 

#line 427 "syntax.cog"
          DEREF(

#line 427 "syntax.cog"
   declRef).specializations);
}


#line 430 "syntax.cog"
 

#line 434 "syntax.cog"
 

#line 438 "syntax.cog"
 

#line 442 "syntax.cog"
 

#line 450 "syntax.cog"
 

#line 457 "syntax.cog"
 

#line 462 "syntax.cog"
 

#line 469 "syntax.cog"
 

#line 475 "syntax.cog"
 

#line 483 "syntax.cog"
 

#line 488 "syntax.cog"
 

#line 492 "syntax.cog"
 

#line 496 "syntax.cog"
 

#line 502 "syntax.cog"
 

#line 510 "syntax.cog"
 

#line 515 "syntax.cog"
 

#line 522 "syntax.cog"
 

#line 527 "syntax.cog"
 

#line 533 "syntax.cog"
 

#line 538 "syntax.cog"
 

#line 543 "syntax.cog"
 

#line 549 "syntax.cog"
 

#line 555 "syntax.cog"
 

#line 559 "syntax.cog"
 

#line 563 "syntax.cog"
 

#line 567 "syntax.cog"
 

#line 571 "syntax.cog"
 

#line 575 "syntax.cog"
 

#line 579 "syntax.cog"
 

#line 583 "syntax.cog"
 

#line 589 "syntax.cog"
 

#line 594 "syntax.cog"
 

#line 601 "syntax.cog"
 

#line 607 "syntax.cog"
 

#line 657 "syntax.cog"
 

#line 665 "syntax.cog"
 

#line 672 "syntax.cog"
 

#line 677 "syntax.cog"
 

#line 683 "syntax.cog"
 

#line 686 "syntax.cog"
 

#line 689 "syntax.cog"
 

#line 693 "syntax.cog"
 

#line 697 "syntax.cog"
 

#line 703 "syntax.cog"
 

#line 709 "syntax.cog"
 

#line 714 "syntax.cog"
 

#line 721 "syntax.cog"
 

#line 724 "syntax.cog"
 

#line 727 "syntax.cog"
 

#line 734 "syntax.cog"
 

#line 741 "syntax.cog"
 

#line 746 "syntax.cog"
 

#line 752 "syntax.cog"
 

#line 3 "token.cog"
 

#line 7 "token.cog"
 COG_DEFINE_CLASS(Session, cog::Object)
COG_DEFINE_CLASS(Syntax, cog::Object)
COG_DEFINE_CLASS(Attr, Syntax)
COG_DEFINE_CLASS(BuiltinAttr, Attr)
COG_DEFINE_CLASS(DeclRefClassAttr, Attr)
COG_DEFINE_CLASS(Stmt, Syntax)
COG_DEFINE_CLASS(Decl, Stmt)
COG_DEFINE_CLASS(SpecializationArg, Object)
COG_DEFINE_CLASS(Specializations, Object)
COG_DEFINE_CLASS(SpecializedDecl, Object)
COG_DEFINE_CLASS(Val, Object)
COG_DEFINE_CLASS(ContainerStmt, Decl)
COG_DEFINE_CLASS(ContainerDecl, ContainerStmt)
COG_DEFINE_CLASS(GenericDecl, ContainerDecl)
COG_DEFINE_CLASS(TypeVarDecl, Decl)
COG_DEFINE_CLASS(ImportDecl, Decl)
COG_DEFINE_CLASS(GenericParamDecl, TypeVarDecl)
COG_DEFINE_CLASS(TypeAliasDecl, TypeVarDecl)
COG_DEFINE_CLASS(ModuleDecl, ContainerDecl)
COG_DEFINE_CLASS(PatternDecl, ContainerDecl)
COG_DEFINE_CLASS(AggTypeDecl, PatternDecl)
COG_DEFINE_CLASS(ClassDecl, AggTypeDecl)
COG_DEFINE_CLASS(StructDecl, AggTypeDecl)
COG_DEFINE_CLASS(FuncDeclBase, PatternDecl)
COG_DEFINE_CLASS(FuncDecl, FuncDeclBase)
COG_DEFINE_CLASS(SubscriptDecl, FuncDeclBase)
COG_DEFINE_CLASS(InitializerDecl, FuncDeclBase)
COG_DEFINE_CLASS(VarDeclBase, Decl)
COG_DEFINE_CLASS(VarDecl, VarDeclBase)
COG_DEFINE_CLASS(LetDecl, VarDeclBase)
COG_DEFINE_CLASS(ParamDecl, LetDecl)
COG_DEFINE_CLASS(SyntaxDecl, Decl)
COG_DEFINE_CLASS(IfStmtBase, Stmt)
COG_DEFINE_CLASS(IfStmt, IfStmtBase)
COG_DEFINE_CLASS(IfLetStmt, IfStmtBase)
COG_DEFINE_CLASS(WhileStmt, Stmt)
COG_DEFINE_CLASS(ForStmt, ContainerStmt)
COG_DEFINE_CLASS(ReturnStmt, Stmt)
COG_DEFINE_CLASS(BreakStmt, Stmt)
COG_DEFINE_CLASS(ContinueStmt, Stmt)
COG_DEFINE_CLASS(SwitchCase, Syntax)
COG_DEFINE_CLASS(SwitchStmt, Stmt)
COG_DEFINE_CLASS(Arg, Syntax)
COG_DEFINE_CLASS(PositionalArg, Arg)
COG_DEFINE_CLASS(Exp, Stmt)
COG_DEFINE_CLASS(LitExp, Exp)
COG_DEFINE_CLASS(IntLitExp, LitExp)
COG_DEFINE_CLASS(StringLitExp, LitExp)
COG_DEFINE_CLASS(CharacterLitExp, LitExp)
COG_DEFINE_CLASS(AppExpBase, Exp)
COG_DEFINE_CLASS(GenericAppExp, AppExpBase)
COG_DEFINE_CLASS(AppExp, AppExpBase)
COG_DEFINE_CLASS(IndexExp, AppExpBase)
COG_DEFINE_CLASS(OperatorAppExp, AppExp)
COG_DEFINE_CLASS(InfixExp, OperatorAppExp)
COG_DEFINE_CLASS(PrefixExp, OperatorAppExp)
COG_DEFINE_CLASS(PostfixExp, OperatorAppExp)
COG_DEFINE_CLASS(AssignExp, Exp)
COG_DEFINE_CLASS(DeclRefExp, Exp)
COG_DEFINE_CLASS(NameExp, DeclRefExp)
COG_DEFINE_CLASS(MemberExp, DeclRefExp)
COG_DEFINE_CLASS(ErrorExp, Exp)
COG_DEFINE_CLASS(OverloadedExpr, Exp)
COG_DEFINE_CLASS(BlockStmt, ContainerDecl)
COG_DEFINE_CLASS(Type, Val)
COG_DEFINE_CLASS(DeclRefType, Type)
COG_DEFINE_CLASS(VoidType, DeclRefType)
COG_DEFINE_CLASS(NullType, DeclRefType)
COG_DEFINE_CLASS(PtrType, DeclRefType)
COG_DEFINE_CLASS(ClassType, DeclRefType)
COG_DEFINE_CLASS(TypeType, Type)
COG_DEFINE_CLASS(FuncType, Type)
COG_DEFINE_CLASS(ErrorType, Type)
COG_DEFINE_CLASS(OverloadGroupType, Type)
COG_DEFINE_CLASS(EnumDecl, AggTypeDecl)
COG_DEFINE_CLASS(EnumTagDecl, VarDeclBase)
COG_DEFINE_CLASS(ForEachStmt, Stmt)
COG_DEFINE_CLASS(ParenExp, Exp)
COG_DEFINE_CLASS(ThisExpr, Exp)
COG_DEFINE_CLASS(CastExpr, Exp)
COG_DEFINE_CLASS(NullLitExpr, Exp)
void init() {
registerClass(getClass<Session>());
registerClass(getClass<Syntax>());
registerClass(getClass<Attr>());
registerClass(getClass<BuiltinAttr>());
registerClass(getClass<DeclRefClassAttr>());
registerClass(getClass<Stmt>());
registerClass(getClass<Decl>());
registerClass(getClass<SpecializationArg>());
registerClass(getClass<Specializations>());
registerClass(getClass<SpecializedDecl>());
registerClass(getClass<Val>());
registerClass(getClass<ContainerStmt>());
registerClass(getClass<ContainerDecl>());
registerClass(getClass<GenericDecl>());
registerClass(getClass<TypeVarDecl>());
registerClass(getClass<ImportDecl>());
registerClass(getClass<GenericParamDecl>());
registerClass(getClass<TypeAliasDecl>());
registerClass(getClass<ModuleDecl>());
registerClass(getClass<PatternDecl>());
registerClass(getClass<AggTypeDecl>());
registerClass(getClass<ClassDecl>());
registerClass(getClass<StructDecl>());
registerClass(getClass<FuncDeclBase>());
registerClass(getClass<FuncDecl>());
registerClass(getClass<SubscriptDecl>());
registerClass(getClass<InitializerDecl>());
registerClass(getClass<VarDeclBase>());
registerClass(getClass<VarDecl>());
registerClass(getClass<LetDecl>());
registerClass(getClass<ParamDecl>());
registerClass(getClass<SyntaxDecl>());
registerClass(getClass<IfStmtBase>());
registerClass(getClass<IfStmt>());
registerClass(getClass<IfLetStmt>());
registerClass(getClass<WhileStmt>());
registerClass(getClass<ForStmt>());
registerClass(getClass<ReturnStmt>());
registerClass(getClass<BreakStmt>());
registerClass(getClass<ContinueStmt>());
registerClass(getClass<SwitchCase>());
registerClass(getClass<SwitchStmt>());
registerClass(getClass<Arg>());
registerClass(getClass<PositionalArg>());
registerClass(getClass<Exp>());
registerClass(getClass<LitExp>());
registerClass(getClass<IntLitExp>());
registerClass(getClass<StringLitExp>());
registerClass(getClass<CharacterLitExp>());
registerClass(getClass<AppExpBase>());
registerClass(getClass<GenericAppExp>());
registerClass(getClass<AppExp>());
registerClass(getClass<IndexExp>());
registerClass(getClass<OperatorAppExp>());
registerClass(getClass<InfixExp>());
registerClass(getClass<PrefixExp>());
registerClass(getClass<PostfixExp>());
registerClass(getClass<AssignExp>());
registerClass(getClass<DeclRefExp>());
registerClass(getClass<NameExp>());
registerClass(getClass<MemberExp>());
registerClass(getClass<ErrorExp>());
registerClass(getClass<OverloadedExpr>());
registerClass(getClass<BlockStmt>());
registerClass(getClass<Type>());
registerClass(getClass<DeclRefType>());
registerClass(getClass<VoidType>());
registerClass(getClass<NullType>());
registerClass(getClass<PtrType>());
registerClass(getClass<ClassType>());
registerClass(getClass<TypeType>());
registerClass(getClass<FuncType>());
registerClass(getClass<ErrorType>());
registerClass(getClass<OverloadGroupType>());
registerClass(getClass<EnumDecl>());
registerClass(getClass<EnumTagDecl>());
registerClass(getClass<ForEachStmt>());
registerClass(getClass<ParenExp>());
registerClass(getClass<ThisExpr>());
registerClass(getClass<CastExpr>());
registerClass(getClass<NullLitExpr>());
}
}
