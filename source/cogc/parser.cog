// parser.cog


typealias ParserFlags = UInt32;

enum ParserFlag : ParserFlags
{
    kParserFlag_Recovering          = 1 << 0,
    kParserFlag_InsideGenericClause = 1 << 1,
}

struct Parser
{
	var session: Session;
	var scope: Scope*;

	var begin: ConstPtr<Token>;
	var cursor: ConstPtr<Token>;
	var end: ConstPtr<Token>;

	var token: ConstPtr<Token>;

	var flags: ParserFlags;
}

func debugState(parser: Parser*)
{
/*
#if 0
	fprintf(stderr, "c:%p, e:%p, t:%d", parser.cursor, parser.end, parser.token.code);
	if(parser.token.code == kTokenCode_Identifier)
	{
		fprintf(stderr, " name:'%s'", getText((Name*) parser.token.rawData).begin);
	}
	fprintf(stderr, "\n");
#endif
*/
}

func advanceToken(
	parser: Parser*)
	-> ConstPtr<Token>
{
	let result = parser.token;
	parser.token = parser.cursor;
	if(parser.cursor != parser.end)
	{
		parser.cursor++;
	}
	debugState(parser);
	return result;
}

func advanceFragment(
	parser: Parser*)
	-> ConstPtr<Token>
{
	let result = parser.token;
    parser.token = parser.cursor;
    parser.cursor = parser.cursor + parser.cursor.advance + 1;
	if(parser.cursor != parser.end)
	{
		parser.cursor++;
	}
	debugState(parser);
	return result;
}

func initializeParser(
	parser: Parser*,
	session: Session,
	file: SourceFile*)
{
	let tokens = lexTokens(session, file);

	parser.session = session;
	parser.scope = 0;
	parser.begin = tokens.begin_;
	parser.cursor = tokens.begin_;
	parser.end = tokens.end_;
	parser.flags = 0;

	advanceToken(parser);
}

func finalizeParser(
	parser: Parser*)
{}

func pushScope(
	parser: Parser*,
	container: ContainerDecl)
{
	let scope = alloc<Scope>();
	scope.parent = parser.scope;

    // TODO: think about how this should be qualified!
	scope.directLink.container = container;

	parser.scope = scope;
}

func restoreScope(
    parser: Parser*,
    scope: Scope*)
{
    // TODO: should really confirm that this scope is valid
    parser.scope = scope;
}

func popScope(
	parser: Parser*)
{
    assert(parser.scope);
    restoreScope(parser, parser.scope.parent);
}


func getSink(parser: Parser*)
	-> DiagnosticSink*
{
	return &parser.session.sink;
}

func peekLoc(parser: Parser*)
	-> SourceLoc
{
	return SourceLoc(parser.token.rawLoc);
}

func peekTokenCode(parser: Parser*)
	-> TokenCode
{
	return parser.token.code;
}

func peekTokenCode(parser: Parser*, code: TokenCode)
	-> Bool
{
	return parser.token.code == code;
}

func isAtEnd(parser: Parser*)
	-> Bool
{
	return parser.cursor == parser.end;
}

func isRecovering(parser: Parser*)
	-> Bool
{
    return (parser.flags & kParserFlag_Recovering) != 0;
}

func unexpected(parser: Parser*)
{
    if(!isRecovering(parser))
	{
		diagnose(getSink(parser), peekLoc(parser), kDiagnostic_unexpectedToken, peekTokenCode(parser));
		parser.flags |= kParserFlag_Recovering;
	}
}

func unexpected(parser: Parser*, expected: TokenCode)
{
    if(!isRecovering(parser))
	{
		diagnose(getSink(parser), peekLoc(parser), kDiagnostic_unexpectedTokenExpectedToken, peekTokenCode(parser), expected);
        parser.flags |= kParserFlag_Recovering;
	}
}

func tokenIsInSet(
	needle: TokenCode,
	count: Int,
	haystack: ConstPtr<TokenCode>)
	-> Bool
{
    for(var ii = 0; ii < count; ++ii)
    {
        if(needle == haystack[ii])
        {
            return true;
        }
    }
    return false;
}

func recoverIfTokenIsInSet(
    parser: Parser*,
	needle: TokenCode,
	count: Int,
	haystack: ConstPtr<TokenCode>)
	-> Bool
{
    if(tokenIsInSet(needle, count, haystack))
    {
        parser.flags &= ~kParserFlag_Recovering;
        return true;
    }
    return false;
}

func tryRecover(
	parser: Parser*,
	recoverBeforeCount: Int,
	recoverBefore: ConstPtr<TokenCode>,
	recoverAfterCount: Int,
	recoverAfter: ConstPtr<TokenCode>)
{
	if(!isRecovering(parser))
		return;


	while(!isAtEnd(parser))
	{
		let peek = peekTokenCode(parser);

        // if we are beforce a token that allows recovery,
        // then do it...
        if(recoverIfTokenIsInSet(parser, peek, recoverBeforeCount, recoverBefore))
        {
            // Don't consume the token.
            return;
        }


		// if the token we just skipped would let
		// us recover, then do so...
        if(recoverIfTokenIsInSet(parser, peek, recoverAfterCount, recoverAfter))
        {
            // Consume the token.
            advanceToken(parser);
            return;
        }

        // If we see any kind of end token, we should bail out without
        // recovering
        switch(peek)
        {
        case kTokenCode_EndOfFile:
        case kTokenCode_RCurly:
        case kTokenCode_RParen:
        case kTokenCode_RSquare:
            // TODO: the problem here is that we *want* to skip
            // certain cases depending on how we are nested...
            return;

        default:
            break;
        }

        // Otherwise we are skipping. We need to be careful to skip balanced
        // tokens, so that we don't mess up nesting.
        advanceFragment(parser);
    }
}

// default recovering, suitable for use inside a statement or declaration context...
func tryRecover(parser: Parser*)
{
	if(!isRecovering(parser))
		return;

//    TokenCode recoverBefore[] = { kTokenCode_LCurly };
//    TokenCode recoverAfter[] = { kTokenCode_Semi, kTokenCode_RCurly };

	var recoverBefore : FixedSizeArray<1, TokenCode>;
	recoverBefore[0] = kTokenCode_LCurly;

	var recoverAfter : FixedSizeArray<2, TokenCode>;
	recoverAfter[0] = kTokenCode_Semi;
	recoverAfter[1] = kTokenCode_RCurly;


	tryRecover(parser, 1, recoverBefore, 2, recoverAfter);
}

// custom recovery
func tryRecoverBefore(parser: Parser*, code: TokenCode)
{
	if (!isRecovering(parser))
		return;

//	TokenCode recoverBefore[] = { code };
	var recoverBefore : FixedSizeArray<1, TokenCode>;
	recoverBefore[0] = code;

	tryRecover(parser, 1, recoverBefore, 0, nullptr);
}


func advanceIf(
	parser: Parser*,
	expected: TokenCode)
	-> ConstPtr<Token>
{
	if(peekTokenCode(parser) == expected)
	{
		return advanceToken(parser);
	}
	return 0;
}

func advanceIf(
    parser: Parser*,
	expected: StringSpan)
	-> ConstPtr<Token>
{
    switch(peekTokenCode(parser))
    {
    case kTokenCode_Identifier:
        if(getText((Name*)(parser.token.rawData)) == expected)
        {
            return advanceToken(parser);
        }

    default:
        break;
    }
    return 0;
}

func advanceIfFragment(
	parser: Parser*,
	expected: TokenCode)
	-> ConstPtr<Token>
{
	if(peekTokenCode(parser) == expected)
	{
		return advanceFragment(parser);
	}
	return 0;
}

func expect(
	parser: Parser*,
	expected: TokenCode)
	-> ConstPtr<Token>
{
	if(let token = advanceIf(parser, expected))
		return token;

	unexpected(parser, expected);
	return 0;
}

func expectFragment(
	parser: Parser*,
	expected: TokenCode)
	-> ConstPtr<Token>
{
	if(let token = advanceIfFragment(parser, expected))
		return token;

	unexpected(parser, expected);
	return 0;
}

func expectIdentifier(
	parser: Parser*)
	-> Name*
{
	if(let token = advanceIf(parser, kTokenCode_Identifier))
	{
		let name = cast<Ptr<Name> >(token.rawData);
		return name;
	}
	else
	{
		unexpected(parser, kTokenCode_Identifier);
		return 0;
	}
}


func advanceIfEnd(
	parser: Parser*,
	expected: TokenCode)
	-> ConstPtr<Token>
{
	if(isAtEnd(parser))
	{
		return expect(parser, expected);
	}

	// TODO: handle recovery
	return advanceIf(parser, expected);
}

func lookup(
	parser: Parser*,
	name: Name*)
	-> LookupResult
{
	return lookup(parser.scope, name);
}

// If this indicates we have syntax, then
// try to pick the right one...
func getSyntaxDecl(
	result: ConstRef<LookupResult>)
	-> SyntaxDecl
{
    foreach(item in UNCONST(result))
    {
        // TODO: pick the best ne...
        if(let syntaxDecl = as<SyntaxDecl>(item.decl))
        {
            return syntaxDecl;
        }
    }

    // nothing found, so bail
    return nullptr;
}

func createNameExp(
	parser: Parser*,
	token: ConstPtr<Token>)
	-> NameExp
{
	let name = cast<Ptr<Name> >(token.rawData);
	let exp = createObject<NameExp>();
	exp.loc = token.getLoc();
	exp.name = name;
	exp.scope = parser.scope;
	return exp;	
}

func createErrorExp(
    parser: Parser*)
	-> Exp
{
    let exp = createObject<ErrorExp>();
    exp.loc = peekLoc(parser);
    return exp;
}

func parseArg(parser: Parser*)
-> Arg
{
    let argExp = parseExp(parser);
    return createPositionalArg(parser, argExp);
}

func parseArgs(
    parser: Parser*)
	-> SyntaxList<Arg>
{
    var args: SyntaxListBuilder<Arg>;
    switch(peekTokenCode(parser))
    {
    case kTokenCode_RParen:
    case kTokenCode_RCurly:
    case kTokenCode_RSquare:
    case kTokenCode_EndOfFile:
        return args;

    default:
        break;
    }

    for(;;)
    {
        let arg = parseArg(parser);
        if(arg)
        {
            args.add(arg);
        }

        switch(peekTokenCode(parser))
        {
        case kTokenCode_RParen:
        case kTokenCode_RCurly:
        case kTokenCode_RSquare:
        case kTokenCode_EndOfFile:
            return args;

        default:
            break;
        }

        expect(parser, kTokenCode_Comma);

		tryRecoverBefore(parser, kTokenCode_RParen);
    }
}

func parseGenericArg(parser: Parser*)
	-> Arg
{
    let flags = parser.flags; 
    parser.flags |= kParserFlag_InsideGenericClause;
    let arg = parseArg(parser);
    parser.flags = flags;
    return arg;
}

func parseGenericArgs(
    parser: Parser*)
	-> SyntaxList<Arg> 
{
    var args: SyntaxListBuilder<Arg>;
    if(peekGenericClose(parser))
        return args;

    for(;;)
    {
        let arg = parseGenericArg(parser);
        if(arg)
        {
            args.add(arg);
        }

        if(peekGenericClose(parser))
            return args;

        expect(parser, kTokenCode_Comma);
    }
}

func peekGenericApp(
    inParser: Parser*)
	-> Bool
{
    // Save the parser state so we can rewind it!
    let parserImpl = *inParser;
    let parser = &parserImpl;

    // check for the opening `<`
    if(!tryParseGenericOpen(parser))
        return false;

    // now scan arguments
    for(;;)
    {
        if(peekGenericClose(parser))
            break;

        switch(peekTokenCode(parser))
        {
        case kTokenCode_EndOfFile:
        case kTokenCode_RParen:
        case kTokenCode_RSquare:
        case kTokenCode_RCurly:
		case kTokenCode_Semi:
			return false;

        default:
            // TODO: handle the annoying case of
            // an operator that ends with `>`...
            advanceFragment(parser);
            break;
        }
    }

    // consume the closing `>`
    expectGenericClose(parser);

    // inspect the token *after* the close, and see
    // if it is one we can use to disambiguate

    // TODO: implement that
    return true;
}

func maybeParseGenericApp(
    parser: Parser*,
	base: Exp)
	-> Exp
{
    if(!peekGenericApp(parser))
        return base;

    tryParseGenericOpen(parser);


    let args = parseGenericArgs(parser);

    expectGenericClose(parser);

    let exp = createObject<GenericAppExp>();
    exp.base = base;
    exp.args = args;
    return exp;
}

func getIntegerLiteralVal(
	token: ConstRef<Token>)
	-> IntLitVal 
{
    let textBegin = cast<ConstPtr<Char> >(token.rawData);
    let textEnd = textBegin + token.rawSize;

    var val : IntLitVal = 0;
    var base = 10;

    var tt = textBegin;
    if(tt != textEnd && *tt == '0')
    {
        ++tt;

        if(tt == textEnd)
            return 0;

        switch(*tt)
        {
        case 'x': case 'X':
            base = 16;
            tt++;
            break;
        case 'b': case 'B':
            base = 2;
            tt++;
            break;
        default:
            break;
        }
    }

    while(tt != textEnd)
    {
        let c = *tt++;
        if((c >= '0') && (c <= '9'))
        {
            val = val*base + (c - '0');
        }
    }
    return val;
}

func getStringLiteralVal(
	token: ConstRef<Token>)
	-> String
{
    let textBegin = cast<ConstPtr<Char> >(token.rawData);
    let textEnd = textBegin + token.rawSize;

    // TODO: actually extract value:

    var cursor = textBegin;

	var val : String;

    let delimeter = *cursor++;
    for(;;)
    {
        let c = *cursor++;

        if(c == delimeter)
            break;

        switch(c)
        {
        case '\\':
            {
                let d = *cursor++;
                switch(d)
                {
                case 'r': val.append('\r'); break;
                case 'n': val.append('\n'); break;
                case 't': val.append('\t'); break;
                case '\\': val.append('\\'); break;
				case '\"': val.append('\"'); break;
				case '\'': val.append('\''); break;

                default:
                    assert(!"unimplemented");
                    break;
                }
            }
            break;
        default:
            val.append(c);
            break;
        }
    }

    return val;
}

func parseAtomicExp(
	parser: Parser*)
	-> Exp
{
	switch(peekTokenCode(parser))
	{
	case kTokenCode_Identifier:
		{
			let nameToken = advanceToken(parser);
			let exp = createNameExp(parser, nameToken);
            return maybeParseGenericApp(parser, exp);
		}

    case kTokenCode_IntegerLiteral:
        {
            let token = advanceToken(parser);
            let exp = createObject<IntLitExp>();
            exp.loc = token.getLoc();
            exp.val = getIntegerLiteralVal(*token);
            return exp;
        }

    case kTokenCode_StringLiteral:
        {
            let token = advanceToken(parser);
            let exp = createObject<StringLitExp>();
            exp.loc = token.getLoc();
            exp.val = getStringLiteralVal(*token);
            return exp;
        }

    case kTokenCode_CharacterLiteral:
        {
            let token = advanceToken(parser);
            let exp = createObject<CharacterLitExp>();
            exp.loc = token.getLoc();
            exp.val = getStringLiteralVal(*token);
            return exp;
        }

    case kTokenCode_LParen:
        {
            let open = advanceToken(parser);
            let inner = parseExp(parser);
            expect(parser, kTokenCode_RParen);

            // TODO: actual construct an identity expression here

			let exp = createObject<ParenExp>();
			exp.loc = open.getLoc();
			exp.base = inner;

            return exp;
        }

    default:
		unexpected(parser);
        return createErrorExp(parser);
	}
}

func createPositionalArg(
	parser: Parser*,
	exp: Exp)
	-> Arg
{
	let arg = createObject<PositionalArg>();
	arg.loc = exp.loc;
	arg.exp = exp;
	return arg;
}

func createApp(
	parser: Parser*,
	exp: AppExpBase,
	op: ConstPtr<Token>,
	argExp: Exp)
	-> AppExpBase
{
	exp.loc = op.getLoc();
	exp.base = createNameExp(parser, op);

	var args: SyntaxListBuilder<Arg>;
	args.add(createPositionalArg(parser, argExp));
	exp.args = args;
	return exp;
}

func createApp(
	parser: Parser*,
	exp: AppExpBase,
	op: ConstPtr<Token>,
	argExp0: Exp,
	argExp1: Exp)
	-> AppExpBase
{
	exp.loc = op.getLoc();
	exp.base = createNameExp(parser, op);

	var args: SyntaxListBuilder<Arg>;
	args.add(createPositionalArg(parser, argExp0));
	args.add(createPositionalArg(parser, argExp1));
	exp.args = args;
	return exp;
}

func isInGenericClause(
    parser: Parser*)
	-> Bool
{
    return (parser.flags & kParserFlag_InsideGenericClause) != 0;
}

func parsePostfixExp(
	parser: Parser*)
	-> Exp
{
	var exp = parseAtomicExp(parser);
    for(;;)
    {
        switch(peekTokenCode(parser))
        {
        case kTokenCode_PostfixOperator:
            {
                // bail out if we shouldn't parse this here...
                if(isInGenericClause(parser) && peekGenericClose(parser))
                    return exp;

                let op = advanceToken(parser);
                exp = createApp(parser, createObject<PostfixExp>(), op, exp);
            }
            break;

        case kTokenCode_LParen:
            {
                let lParen = advanceToken(parser);
                let args = parseArgs(parser);
                expect(parser, kTokenCode_RParen);

                let app = createObject<AppExp>();
                app.loc = lParen.getLoc();
                app.base = exp;
                app.args = args;
                exp = app;
            }
            break;

        case kTokenCode_LSquare:
            {
                let lParen = advanceToken(parser);
                let args = parseArgs(parser);
                expect(parser, kTokenCode_RSquare);

                let app = createObject<IndexExp>();
                app.loc = lParen.getLoc();
                app.base = exp;
                app.args = args;
                exp = app;
            }
            break;

		case kTokenCode_Arrow:
			diagnose(getSink(parser), peekLoc(parser), kDiagnostic_youMeanDot);
		case kTokenCode_Dot:
            {
                let dot = advanceToken(parser);
                let memberName = expectIdentifier(parser);

                let memberExp = createObject<MemberExp>();
                memberExp.loc = dot.getLoc();
                memberExp.base = exp;
                memberExp.memberName = memberName;

				exp = maybeParseGenericApp(parser, memberExp);
            }
            break;

        default:
            return exp;
        }
    }
}

func parsePrefixExp(
	parser: Parser*)
	-> Exp
{
	if(peekTokenCode(parser) == kTokenCode_PrefixOperator)
	{
		let op = advanceToken(parser);
		let arg = parsePrefixExp(parser);

		return createApp(parser, createObject<PrefixExp>(), op, arg);
	}
	else
	{
		return parsePostfixExp(parser);
	}
}

func parseInfixExp(
	parser: Parser*)
	-> Exp
{
	var left = parsePrefixExp(parser);
    for(;;)
    {
        switch(peekTokenCode(parser))
        {
        case kTokenCode_InfixOperator:
            {
                // Don't parse an operator starting with `>` if we are in a generic context.
                if(isInGenericClause(parser) && peekGenericClose(parser))
                    return left;

                let op = advanceToken(parser);
                let right = parseInfixExp(parser);

                left = createApp(parser, createObject<InfixExp>(), op, left, right);
            }
            break;

        case kTokenCode_Assign:
            {
                // Assignment isn't just another binary operator, but we need to handle it here...
                // Don't parse an operator starting with `>` if we are in a generic context.
                let op = advanceToken(parser);

                let assign = createObject<AssignExp>();
                assign.left = left;
                assign.right = parseInfixExp(parser);

                left = assign;
            }
            break;

        default:
            return left;
        }
    }
    return left;
}

func parseExp(
	parser: Parser*)
	-> Exp
{
	return parseInfixExp(parser);
}

func parseType(
	parser: Parser*)
	-> TypeExp
{
	let exp = parsePostfixExp(parser);

	var typeExp : TypeExp;
	typeExp.exp = exp;
	return typeExp;
}

func parseDecl(
	parser: Parser*)
	-> Decl
{
    var attrs: SyntaxListBuilder<Attr>;

    for(;;)
    {
        switch(peekTokenCode(parser))
        {
        case kTokenCode_Identifier:
        {
            let loc = peekLoc(parser);

            // An identifier might name a declaration keyword
            let name = expectIdentifier(parser);
            let result = lookup(parser, name);

            if(let syntax = getSyntaxDecl(result))
            {
                // we have a syntax declaration, but does it provide to resolve to a decl?
                let syntaxClass = syntax.syntaxClass;
                if(isSubClass(syntaxClass, getClass<Decl>()))
                {
                    // TODO: enforce validity
                    let result = syntax.callback(parser);
                    let resultDecl = as<Decl>(result);

                    // Attach the attributes to the declaration...
                    if(let genericDecl = as<GenericDecl>(resultDecl))
                    {
                        // For a generic declaration, we attach the attributes to the inner declaration
                        genericDecl.inner.attrs = attrs;
                    }
                    else
                    {
                        resultDecl.attrs = attrs;
                    }

                    resultDecl.loc = loc;
                    return resultDecl;
                }
                else if(isSubClass(syntaxClass, getClass<Attr>()))
                {
                    let result = syntax.callback(parser);
                    let resultAttr = as<Attr>(result);
                    attrs.add(resultAttr);

                    // Now that we have the attribute, look after it...
                    continue;
                }

                // now we need to parse using that decl



            }
            else
            {
                diagnose(getSink(parser), peekLoc(parser), kDiagnostic_unexpectedDeclName, name);
                // error
                assert(false);
                return 0;
            }
        }
        break;

        default:
            // TODO: error
            unexpected(parser);
            return 0;
        }
    }
}

func findOrImportModule(
    session: Session,
	loc: SourceLoc,
	name: Name*)
	-> ModuleDecl
{
    // we need to find the damn module

    for(var mm = session.loadedModules; mm; mm = cast<ModuleDecl>(mm.next))
    {
        if(mm.name == name)
        {
            return mm;
        }
    }

    // now we need to load the damn thing!
    
    let nameText = getText(name);

	var path : FixedSizeArray<1024, Char>;
    sprintf(path, "source/%.*s/%.*s.cog",
        (int)(nameText.end - nameText.begin),
        nameText.begin,
        (int)(nameText.end - nameText.begin),
        nameText.begin);

    let file: SourceFile* = getSourceFile(session, TerminatedStringSpan(path));
    if(!file)
    {
        sprintf(path, "../../source/%.*s.cog", (int)(nameText.end - nameText.begin), nameText.begin);
        file = getSourceFile(session, TerminatedStringSpan(path));
    }
    if(!file)
    {
        sprintf(path, "../../source/thetalib/%.*s.cog", (int)(nameText.end - nameText.begin), nameText.begin);
        file = getSourceFile(session, TerminatedStringSpan(path));
    }
    if(!file)
    {
        sprintf(path, "source/thetalib/%.*s.cog", (int)(nameText.end - nameText.begin), nameText.begin);
        file = getSourceFile(session, TerminatedStringSpan(path));
    }
    if(!file)
    {
	assert(!"unimplemented");
//        throw 99;
    }

    let moduleDecl = createObject<ModuleDecl>();
    moduleDecl.name = name;

    parseFileIntoModule(session, file, moduleDecl);

    // Note: we link the module into our session before
    // checking it, so that it can resolve references
    // into itself (in the case of the stdlib module)

    moduleDecl.next = session.loadedModules;
    session.loadedModules = moduleDecl;

    // TODO: what if we have errors here?
    checkModule(session, moduleDecl);

    return moduleDecl;
}

func parseDeclsInBody(
	parser: Parser* )
	-> SyntaxList<Decl> 
{
    let savedScope = parser.scope;

	var decls: SyntaxListBuilder<Decl>;
    while(!isAtEnd(parser))
	{
		switch(peekTokenCode(parser))
		{
		case kTokenCode_RParen:
		case kTokenCode_RCurly:
		case kTokenCode_EndOfFile:
			return decls;

		default:
			break;
		}

		let decl = parseDecl(parser);
		if(decl)
		{
            decl.parent = parser.scope.directLink.container;
            decls.add(decl);

		}

        restoreScope(parser, savedScope);

		tryRecover(parser);
	}
    return decls;
}

func  parseDeclBody(
	parser: Parser* )
	-> SyntaxList<Decl> 
{
	expect(parser, kTokenCode_LCurly);
	let decls = parseDeclsInBody(parser);
	expect(parser, kTokenCode_RCurly);
	return decls;
}

func  parseDeclBody(
	parser: Parser*,
	decl: ContainerDecl)
{
	pushScope(parser, decl);
	decl.getDecls() = parseDeclBody(parser);

    foreach(dd in decl.getDecls())
    {
        dd.parent = decl;
    }

	popScope(parser);
}

func  parseExpStmt(
    parser: Parser*)
	-> Stmt
{
    let exp = parseExp(parser);
    expect(parser, kTokenCode_Semi);
    return exp;
}

func  parseStmt(
	parser: Parser*)
	-> Stmt
{
	switch(peekTokenCode(parser))
	{
	case kTokenCode_Identifier:
		{
			// An identifier might name a declaration keyword
            let loc = peekLoc(parser);
            let name = cast<Ptr<Name> >(parser.token.rawData);
			let result = lookup(parser, name);

            if(let syntax = getSyntaxDecl(result))
            {
                advanceToken(parser);

                // TODO: also check that it defines a statement or declaration...
                // (don't want to use this branch to parse an expression)

                // now we need to parse using that decl

                let result = syntax.callback(parser);
                let resultStmt = as<Stmt>(result);

                // TODO: enforce validity

                resultStmt.loc = loc;

                return resultStmt;
            }

            // default case is to parse an expression statement
            return parseExpStmt(parser);
		}
		break;

    case kTokenCode_LCurly:
        return parseStmtBody(parser);

    case kTokenCode_PrefixOperator:
        return parseExpStmt(parser);

	default:
		// TODO: error
		unexpected(parser);
		return 0;
	}
}

func parseStmtsInBody(
	parser: Parser* )
	-> SyntaxListBuilder<Stmt> 
{
	var stmts: SyntaxListBuilder<Stmt>;
    while(!isAtEnd(parser))
	{
		switch(peekTokenCode(parser))
		{
		case kTokenCode_RParen:
		case kTokenCode_RCurly:
		case kTokenCode_EndOfFile:
			return stmts;

		default:
			break;
		}

		let stmt = parseStmt(parser);
		if(stmt)
		{
			stmts.add(stmt);
		}

		tryRecover(parser);
	}
    return stmts;
}

func parseStmtBody(
	parser: Parser* )
	-> Stmt
{
	let stmt = createObject<BlockStmt>();

    pushScope(parser, stmt);
	expect(parser, kTokenCode_LCurly);
	let stmts = parseStmtsInBody(parser);
	expect(parser, kTokenCode_RCurly);
    popScope(parser);

	stmt.stmts = stmts;

	return stmt;
}

func peekGenericClose(parser: Parser*) -> Bool
{
	switch(peekTokenCode(parser))
	{
	default:
		// definitely not a generic close
		return false;

	case kTokenCode_InfixOperator:
	case kTokenCode_PrefixOperator:
	case kTokenCode_PostfixOperator:
		break;
	}

	let name = cast<Ptr<Name> >( parser.token.rawData );
	let nameText = getText(name);

	// TODO: allow `>` to be just a prefix
	if(nameText != TerminatedStringSpan(">"))
		return false;

	return true;
}

func tryParseGenericClose(parser: Parser*) -> Bool
{
	if(!peekGenericClose(parser))
		return false;

	// consume the `>`
	advanceToken(parser);
	return true;
}

func expectGenericClose(parser: Parser*)
{
	if(!tryParseGenericClose(parser))
	{
		// TODO: proper diagnostic
		unexpected(parser);
	}
}

func parseGenericParam(parser: Parser*) -> Decl
{
	let loc = peekLoc(parser);
	let name = expectIdentifier(parser);

	// TODO: handle constraints

	let decl = createObject<GenericParamDecl>();
	decl.loc = loc;
	decl.name = name;
	return decl;
}

func parseGenericParams(parser: Parser*, ioDecls: Ptr<SyntaxListBuilder<Decl> >)
{
	// TODO: should we keep references?
	let decls : ConstRef<SyntaxListBuilder<Decl> > = *ioDecls;

	if(peekGenericClose(parser))
		return;

	for(;;)
	{
		let decl = parseGenericParam(parser);
		if(decl)
		{
			decls.add(decl);
		}

		if(peekGenericClose(parser))
			return;

		expect(parser, kTokenCode_Comma);
	}
}

func tryParseGenericOpen(parser: Parser*) -> Bool
{
    switch(peekTokenCode(parser))
    {
    default:
        // definitely not a generic param list
//		diagnose(getSink(parser), peekLoc(parser), kDiagnostic_notGeneric, "start");
        return false;

    case kTokenCode_InfixOperator:
    case kTokenCode_PrefixOperator:
    case kTokenCode_PostfixOperator:
        break;
    }

    let name = cast<Ptr<Name> >(parser.token.rawData);
    let nameText = getText(name);

    // TODO: allow `<` to be just a prefix
    if(nameText != TerminatedStringSpan("<"))
        return false;

    // consume the starting `<`
    advanceToken(parser);

    return true;
}

func maybeParseGenericParams(parser: Parser*,decl: Decl) -> Decl
{
    if(!tryParseGenericOpen(parser))
        return decl;


	let genericDecl = createObject<GenericDecl>();

	var decls: SyntaxListBuilder<Decl>;
	parseGenericParams(parser, &decls);

	genericDecl.name = decl.name;
	genericDecl.getDecls() = decls;
	genericDecl.inner = decl;

    decl.parent = genericDecl;

    pushScope(parser, genericDecl);

	expectGenericClose(parser);
	return genericDecl;
}

func parseAggTypeDeclCommon(parser: Parser*, decl: AggTypeDecl) -> Decl
{
	decl.name = expectIdentifier(parser);

	// generic args, if any
	let result = maybeParseGenericParams(parser, decl);

    // DEBUGGING
    if(result != decl)
    {
        fprintf(stderr, "BEGIN PARSE GENERIC: %s\n", getText(decl.name).begin);
    }

	// inheritance clause
	if(advanceIf(parser, kTokenCode_Colon))
	{
		decl.base = parseType(parser);
	}

	// body
	parseDeclBody(parser, decl);

    if(result != decl)
    {
        fprintf(stderr, "END PARSE GENERIC: %s\n", getText(decl.name).begin);
    }

    return result;
}

func parseClassDecl(parser: Parser*) -> Syntax
{
	let decl = createObject<ClassDecl>();
    return parseAggTypeDeclCommon(parser, decl);
}

func parseStructDecl(parser: Parser*) -> Syntax
{
	let decl = createObject<StructDecl>();
	return parseAggTypeDeclCommon(parser, decl);
}

func parseEnumTags(parser: Parser*) -> SyntaxList<Decl>
{
	var decls: SyntaxListBuilder<Decl>;
	for (;;)
	{
		switch (peekTokenCode(parser))
		{
		case kTokenCode_RCurly:
		case kTokenCode_RParen:
		case kTokenCode_EndOfFile:
			return decls;

		default:
			break;
		}

		// parse one tag
		let tag = createObject<EnumTagDecl>();
		tag.name = expectIdentifier(parser);
		if (advanceIf(parser, kTokenCode_Assign))
		{
			tag.init = parseExp(parser);
		}

		decls.add(tag);

		switch (peekTokenCode(parser))
		{
		case kTokenCode_RCurly:
		case kTokenCode_RParen:
		case kTokenCode_EndOfFile:
			return decls;

		default:
			break;
		}

		expect(parser, kTokenCode_Comma);
	}
}

func parseEnumDecl(parser: Parser*) -> Syntax
{
	let decl = createObject<EnumDecl>();

	decl.name = expectIdentifier(parser);

	// generic args, if any
	let result = maybeParseGenericParams(parser, decl);

	// TODO: have an enum be a general-purpose type declaration...

	if (advanceIf(parser, kTokenCode_Colon))
	{
		decl.base = parseType(parser);
	}

	expect(parser, kTokenCode_LCurly);
	let decls = parseEnumTags(parser);
	expect(parser, kTokenCode_RCurly);

	decl.stmts = decls.head;

	return result;
}

func parseImportDecl(parser: Parser*) -> Syntax
{
    let decl = createObject<ImportDecl>();
    decl.scope = parser.scope;
    decl.name = expectIdentifier(parser);
    expect(parser, kTokenCode_Semi);
    return decl;
}


func parseVarDeclCommon(parser: Parser*, decl: VarDeclBase)
{
	decl.name = expectIdentifier(parser);

	// type clause
	if(advanceIf(parser, kTokenCode_Colon))
	{
		decl.type = parseType(parser);
	}

	// init clause
	if(advanceIf(parser, kTokenCode_Assign))
	{
		decl.init = parseExp(parser);
	}
}

func parseVarDecl(parser: Parser*) -> Syntax
{
	let decl = createObject<VarDecl>();
	parseVarDeclCommon(parser, decl);
	expect(parser, kTokenCode_Semi);
	return decl;
}

func parseLetDecl(parser: Parser*) -> Syntax
{
    let decl = createObject<LetDecl>();
    parseVarDeclCommon(parser, decl);
    expect(parser, kTokenCode_Semi);
    return decl;
}

func parseTypeVarDeclSuffixCommon(parser: Parser*, decl: TypeVarDecl)
{
	// constraint clause
	if(advanceIf(parser, kTokenCode_Colon))
	{
		decl.bound = parseType(parser);
	}

	// init clause
	if(advanceIf(parser, kTokenCode_Assign))
	{
		decl.init = parseType(parser);
	}
}

func parseTypeVarDeclCommon(parser: Parser*, decl: TypeVarDecl)
{
	decl.name = expectIdentifier(parser);
	parseTypeVarDeclSuffixCommon(parser, decl);
}

func expectOperatorOrIdentifier(parser: Parser*) -> Name*
{
	switch(peekTokenCode(parser))
	{
	default:
		return expectIdentifier(parser);

	case kTokenCode_Identifier:
	case kTokenCode_InfixOperator:
	case kTokenCode_PrefixOperator:
	case kTokenCode_PostfixOperator:
		return cast<Ptr<Name> >(advanceToken(parser).rawData);
	}
}

func parseTypeAliasDecl(parser: Parser*) -> Syntax
{
	let decl = createObject<TypeAliasDecl>();

	decl.name = expectOperatorOrIdentifier(parser);
	let result = maybeParseGenericParams(parser, decl);

	parseTypeVarDeclSuffixCommon(parser, decl);
	expect(parser, kTokenCode_Semi);
	return result;
}

func parseIfStmt(parser: Parser*) -> Syntax
{
    expect(parser, kTokenCode_LParen);

	// special case `if(let ...)` for now
	if (advanceIf(parser, TerminatedStringSpan("let")))
	{
		let stmt = createObject<IfLetStmt>();
		stmt.name = expectIdentifier(parser);
		expect(parser, kTokenCode_Assign);
		stmt.init = parseExp(parser);
		expect(parser, kTokenCode_RParen);
		stmt.thenStmt = parseStmt(parser);
		if (advanceIf(parser, TerminatedStringSpan("else")))
		{
			stmt.elseStmt = parseStmt(parser);
		}
		return stmt;
	}
	else
	{
		let stmt = createObject<IfStmt>();
		stmt.condition = parseExp(parser);
		expect(parser, kTokenCode_RParen);
		stmt.thenStmt = parseStmt(parser);
		if (advanceIf(parser, TerminatedStringSpan("else")))
		{
			stmt.elseStmt = parseStmt(parser);
		}
		return stmt;
	}
}

func parseWhileStmt(parser: Parser*) -> Syntax
{
    let stmt = createObject<WhileStmt>();
    expect(parser, kTokenCode_LParen);
    stmt.condition = parseExp(parser);
    expect(parser, kTokenCode_RParen);
    stmt.body = parseStmt(parser);
    return stmt;
}

func parseForStmt(parser: Parser*) -> Syntax
{
	let stmt = createObject<ForStmt>();
	expect(parser, kTokenCode_LParen);

	// initialization clause
	switch (peekTokenCode(parser))
	{
	case kTokenCode_Semi:
		advanceToken(parser);
		break;

	default:
		// HACK: accept *any* statement, even if it doesn't make sense
		stmt.init = parseStmt(parser);
		break;
	}

	// condition clause
	switch (peekTokenCode(parser))
	{
	case kTokenCode_Semi:
		advanceToken(parser);
		break;

		// TODO: handle a declaration keyword here!!!

	default:
		stmt.condition = parseExp(parser);
		expect(parser, kTokenCode_Semi);
		break;
	}

	// iteration clause
	switch (peekTokenCode(parser))
	{
	case kTokenCode_RParen:
		break;

	default:
		stmt.iter = parseExp(parser);
		break;
	}

	expect(parser, kTokenCode_RParen);
	stmt.body = parseStmt(parser);
	return stmt;
}

func parseForEachStmt(parser: Parser*) -> Syntax
{
	let stmt = createObject<ForEachStmt>();
	expect(parser, kTokenCode_LParen);

	stmt.name = expectIdentifier(parser);

	if (!advanceIf(parser, TerminatedStringSpan("in")))
	{
		expect(parser, kTokenCode_Colon);
	}

	stmt.exp = parseExp(parser);

	expect(parser, kTokenCode_RParen);
	stmt.body = parseStmt(parser);
	return stmt;
}

func parseSwitchStmt(parser: Parser*) -> Syntax
{
	let stmt = createObject<SwitchStmt>();
	expect(parser, kTokenCode_LParen);
	stmt.condition = parseExp(parser);
	expect(parser, kTokenCode_RParen);

	expect(parser, kTokenCode_LCurly);

	var caseLink = &stmt.cases;

	for (;;)
	{
		switch (peekTokenCode(parser))
		{
		case kTokenCode_RCurly:
		case kTokenCode_RParen:
		case kTokenCode_EndOfFile:
			expect(parser, kTokenCode_RCurly);
			return stmt;
		
		default:
			break;
		}

		let caseStart = peekLoc(parser);
		let c = createObject<SwitchCase>();
		c.loc = caseStart;

		var valueLink = &c.values;

		// parse cases...
		for (;;)
		{
			var arg : Arg = nullptr;
			if (advanceIf(parser, TerminatedStringSpan("case")))
			{
				arg = createObject<Arg>();
				arg.exp = parseExp(parser);
				expect(parser, kTokenCode_Colon);
			}
			else if (advanceIf(parser, TerminatedStringSpan("default")))
			{
				arg = createObject<Arg>();
				arg.exp = nullptr;
				expect(parser, kTokenCode_Colon);
			}
			else
			{
				// done with cases, I guess
				break;
			}

			*valueLink = arg;
			valueLink = &arg.next;
		}

		if (!*valueLink)
		{
			// there was nothing to match!!!
			// TODO: diagnose!
		}

		// TODO: need to handle stmts until we see another `case` or `default`...
		c.body = parseStmt(parser);

		*caseLink = c;
		caseLink = &c.next;

		tryRecover(parser);
	}
}

func parseReturnStmt(parser: Parser*) -> Syntax
{
    let stmt = createObject<ReturnStmt>();
    if(peekTokenCode(parser) != kTokenCode_Semi)
    {
        stmt.value = parseExp(parser);
    }
    expect(parser, kTokenCode_Semi);
    return stmt;
}

func parseBreakStmt(parser: Parser*) -> Syntax
{
    let stmt = createObject<BreakStmt>();
    expect(parser, kTokenCode_Semi);
    return stmt;
}

func parseContinueStmt(parser: Parser*) -> Syntax
{
    let stmt = createObject<ContinueStmt>();
    expect(parser, kTokenCode_Semi);
    return stmt;
}

func parseBuiltinAttr(parser: Parser*) -> Syntax
{
    let attr = createObject<BuiltinAttr>();
    expect(parser, kTokenCode_LParen);
    attr.name = expectIdentifier(parser);
    expect(parser, kTokenCode_RParen);
    return attr;
}

func parseParam(parser: Parser*) -> ParamDecl
{
	let decl = createObject<ParamDecl>();
	parseVarDeclCommon(parser, decl);
	return decl;
}

func parseParams(parser: Parser*, decl: ContainerDecl)
{
	var params: SyntaxListBuilder<Decl>;

	switch(peekTokenCode(parser))
	{
	case kTokenCode_RCurly:
	case kTokenCode_RParen:
	case kTokenCode_EndOfFile:
		return;

	default:
		break;
	}


	for(;;)
	{
		let param = parseParam(parser);
		if(param)
		{
			params.add(param);
		}

		tryRecover(parser);

		switch(peekTokenCode(parser))
		{
		case kTokenCode_RCurly:
		case kTokenCode_RParen:
		case kTokenCode_EndOfFile:
			{
				decl.getDecls() = params;
			}
			return;

		default:
			break;
		}

		expect(parser, kTokenCode_Comma);

	}

	decl.getDecls() = params;
}



func parseFuncDecl(parser: Parser*) -> Syntax
{
	let decl = createObject<FuncDecl>();
    decl.loc = peekLoc(parser);

	decl.name = expectOperatorOrIdentifier(parser);

    // generic args, if any
    let result = maybeParseGenericParams(parser, decl);

    pushScope(parser, decl);

	if(expect(parser, kTokenCode_LParen))
	{
		parseParams(parser, decl);
	}
	expect(parser, kTokenCode_RParen);

	if(advanceIf(parser, kTokenCode_Arrow))
	{
		decl.resultType = parseType(parser);
	}

	if(peekTokenCode(parser, kTokenCode_LCurly))
	{
		decl.body = parseStmtBody(parser);
	}
	else
	{
		expect(parser, kTokenCode_Semi);
	}

    popScope(parser);

	return result;
}

func parseSubscriptDecl(parser: Parser*) -> Syntax
{
    let decl = createObject<SubscriptDecl>();

    pushScope(parser, decl);

    if(expect(parser, kTokenCode_LParen))
    {
        parseParams(parser, decl);
    }
    expect(parser, kTokenCode_RParen);

    if(advanceIf(parser, kTokenCode_Arrow))
    {
        decl.resultType = parseType(parser);
    }

    if(peekTokenCode(parser, kTokenCode_LCurly))
    {
        decl.body = parseStmtBody(parser);
    }
    else
    {
        expect(parser, kTokenCode_Semi);
    }

    popScope(parser);

    return decl;
}

func parseInitializerDecl(parser: Parser*) -> Syntax
{
    let decl = createObject<InitializerDecl>();

    pushScope(parser, decl);

    if(expect(parser, kTokenCode_LParen))
    {
        parseParams(parser, decl);
    }
    expect(parser, kTokenCode_RParen);

    // Note(tfoley): This should be an error, and we'll need to report it as such...
    if(advanceIf(parser, kTokenCode_Arrow))
    {
        decl.resultType = parseType(parser);
    }

    if(peekTokenCode(parser, kTokenCode_LCurly))
    {
        decl.body = parseStmtBody(parser);
    }
    else
    {
        expect(parser, kTokenCode_Semi);
    }

    popScope(parser);

    return decl;
}

func createSyntaxDecl(
	session: Session,
	name: ConstPtr<Char>,
	callback: SyntaxCallback,
	syntaxClass: Class*)
	-> SyntaxDecl
{
	let syntaxDecl = createObject<SyntaxDecl>();
	syntaxDecl.name = getName(session, UNCONST(name));
    syntaxDecl.syntaxClass = syntaxClass;
	syntaxDecl.callback = callback;
	return syntaxDecl;
}

func createSyntaxDecl<T>(
	session: Session,
	name: ConstPtr<Char>,
	callback: SyntaxCallback)
	-> SyntaxDecl
{
    return createSyntaxDecl(session, name, callback, getClass<T>());
}

func parseFileIntoModule(
    session: Session,
    file: SourceFile*,
    moduleDecl: ModuleDecl)
{
    var parser: Parser;
    initializeParser(&parser, session, file);

    // set up decl list to add to
    var moduleDeclList: SyntaxListBuilder<Decl>;
    moduleDeclList.head = moduleDecl.getDecls().head;

	// TODO: support ?:
    //moduleDeclList.link = moduleDeclList.head ? session.moduleDeclLink : &moduleDeclList.head;
	if(moduleDeclList.head)
	{
	    moduleDeclList.link = cast<Ptr<Decl> >(session.moduleDeclLink);
	}
	else
	{
	    moduleDeclList.link = &moduleDeclList.head;
	}

    //	parser.stmtList = &moduleDeclList;

    // set up super-global scope

    let globals = createObject<ContainerDecl>();
    var globalDecls: SyntaxListBuilder<Decl>;

    // add decls here!
    globalDecls.add(createSyntaxDecl<Decl>(session, "import", &parseImportDecl));
    globalDecls.add(createSyntaxDecl<Decl>(session, "class", &parseClassDecl));
    globalDecls.add(createSyntaxDecl<Decl>(session, "struct", &parseStructDecl));
	globalDecls.add(createSyntaxDecl<Decl>(session, "enum", &parseEnumDecl));
	globalDecls.add(createSyntaxDecl<Decl>(session, "var", &parseVarDecl));
    globalDecls.add(createSyntaxDecl<Decl>(session, "let", &parseLetDecl));
    globalDecls.add(createSyntaxDecl<Decl>(session, "func", &parseFuncDecl));
    globalDecls.add(createSyntaxDecl<Decl>(session, "subscript", &parseSubscriptDecl));
    globalDecls.add(createSyntaxDecl<Decl>(session, "init", &parseInitializerDecl));
    globalDecls.add(createSyntaxDecl<Decl>(session, "typealias", &parseTypeAliasDecl));
    globalDecls.add(createSyntaxDecl<Stmt>(session, "if", &parseIfStmt));
    globalDecls.add(createSyntaxDecl<Stmt>(session, "while", &parseWhileStmt));
	globalDecls.add(createSyntaxDecl<Stmt>(session, "for", &parseForStmt));
	globalDecls.add(createSyntaxDecl<Stmt>(session, "foreach", &parseForEachStmt));
	globalDecls.add(createSyntaxDecl<Stmt>(session, "return", &parseReturnStmt));
    globalDecls.add(createSyntaxDecl<Stmt>(session, "break", &parseBreakStmt));
    globalDecls.add(createSyntaxDecl<Stmt>(session, "continue", &parseContinueStmt));
	globalDecls.add(createSyntaxDecl<Stmt>(session, "switch", &parseSwitchStmt));
	globalDecls.add(createSyntaxDecl<Attr>(session, "@__builtin", &parseBuiltinAttr));

    globals.getDecls() = globalDecls;

    let globalScope = alloc<Scope>();
    globalScope.parent = 0;
    globalScope.directLink.container = globals;

    parser.scope = globalScope;

    //


    // TODO: really need to construct a custom scope for the file...
    pushScope(&parser, moduleDecl);
    let fileDecls = parseDeclsInBody(&parser);
    foreach(dd in fileDecls)
        dd.parent = moduleDecl;
    popScope(&parser);

    expect(&parser, kTokenCode_EndOfFile);

    moduleDeclList.append(fileDecls);

    moduleDecl.getDecls() = moduleDeclList;

    finalizeParser(&parser);
}

func parseFile(
	session: Session,
	file: SourceFile*)
{
//    fprintf(stderr, "PARSING\n");

	// set up module if needed
	var moduleDecl = session.moduleDecl;
	if(!moduleDecl)
	{
		moduleDecl = createObject<ModuleDecl>();
        moduleDecl.name = getModuleName(session);
		session.moduleDecl = moduleDecl;
		session.moduleDeclLink = &moduleDecl.getDecls().head;
	}

    parseFileIntoModule(session, file, moduleDecl);
}
